"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useChatbot.ts":
/*!*********************************!*\
  !*** ./src/hooks/useChatbot.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChatbot: function() { return /* binding */ useChatbot; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _services_chatbot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/services/chatbot */ \"(app-pages-browser)/./src/services/chatbot.ts\");\n/* harmony import */ var _lib_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/storage */ \"(app-pages-browser)/./src/lib/storage.ts\");\n/* harmony import */ var _services_taxiService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/taxiService */ \"(app-pages-browser)/./src/services/taxiService.ts\");\n/* __next_internal_client_entry_do_not_use__ useChatbot auto */ \n\n\n\nfunction useChatbot() {\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Load chat history from localStorage on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const savedMessages = localStorage.getItem(\"chat_history\");\n        if (savedMessages) {\n            setMessages(JSON.parse(savedMessages));\n        }\n    }, []);\n    // Save messages to localStorage whenever they change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        localStorage.setItem(\"chat_history\", JSON.stringify(messages));\n    }, [\n        messages\n    ]);\n    const handleScheduleConflict = (newEvent, existingEvents)=>{\n        console.log(\"Checking conflicts for new event:\", {\n            title: newEvent.title,\n            start: newEvent.startTime,\n            priority: newEvent.priority\n        });\n        console.log(\"Existing events:\", existingEvents);\n        // Sort existing events by priority\n        const priorityOrder = {\n            \"urgent-important\": 3,\n            \"important\": 2,\n            \"urgent\": 1,\n            \"neither\": 0\n        };\n        // Find conflicting events\n        const conflicts = existingEvents.filter((event)=>{\n            const newStart = new Date(newEvent.startTime);\n            const newEnd = new Date(newEvent.endTime);\n            const eventStart = new Date(event.startTime);\n            const eventEnd = new Date(event.endTime);\n            const hasConflict = newStart >= eventStart && newStart < eventEnd || newEnd > eventStart && newEnd <= eventEnd || newStart <= eventStart && newEnd >= eventEnd;\n            if (hasConflict) {\n                console.log(\"Found conflict:\", {\n                    existingEvent: event.title,\n                    existingPriority: event.priority,\n                    newEvent: newEvent.title,\n                    newPriority: newEvent.priority\n                });\n            }\n            return hasConflict;\n        });\n        if (conflicts.length === 0) {\n            console.log(\"No conflicts found\");\n            return newEvent;\n        }\n        // Check if new event has higher priority\n        const newPriorityScore = priorityOrder[newEvent.priority];\n        const highestConflictScore = Math.max(...conflicts.map((e)=>priorityOrder[e.priority]));\n        console.log(\"Priority comparison:\", {\n            newEventScore: newPriorityScore,\n            highestConflictScore,\n            willRescheduleConflicts: newPriorityScore > highestConflictScore\n        });\n        if (newPriorityScore > highestConflictScore) {\n            // Move conflicting events\n            console.log(\"Moving conflicting events...\");\n            const storage = _lib_storage__WEBPACK_IMPORTED_MODULE_2__.StorageService.getInstance();\n            conflicts.forEach((conflict)=>{\n                // Move to next available time\n                const duration = new Date(conflict.endTime).getTime() - new Date(conflict.startTime).getTime();\n                const newStartTime = new Date(newEvent.endTime);\n                const newEndTime = new Date(newStartTime.getTime() + duration);\n                const updatedEvent = {\n                    ...conflict,\n                    startTime: newStartTime.toISOString(),\n                    endTime: newEndTime.toISOString()\n                };\n                console.log(\"Moving event:\", {\n                    event: conflict.title,\n                    from: conflict.startTime,\n                    to: updatedEvent.startTime\n                });\n                storage.updateTimeBlock(updatedEvent);\n            });\n            return newEvent;\n        } else {\n            // Find next available time for new event\n            console.log(\"Finding next available time for new event...\");\n            const duration = new Date(newEvent.endTime).getTime() - new Date(newEvent.startTime).getTime();\n            const lastConflict = conflicts.sort((a, b)=>new Date(b.endTime).getTime() - new Date(a.endTime).getTime())[0];\n            const newStartTime = new Date(lastConflict.endTime);\n            const newEndTime = new Date(newStartTime.getTime() + duration);\n            const rescheduledEvent = {\n                ...newEvent,\n                startTime: newStartTime.toISOString(),\n                endTime: newEndTime.toISOString()\n            };\n            console.log(\"Rescheduled new event:\", {\n                from: newEvent.startTime,\n                to: rescheduledEvent.startTime\n            });\n            return rescheduledEvent;\n        }\n    };\n    const parseTimeString = (timeStr)=>{\n        // Try ISO format first\n        let date = new Date(timeStr);\n        if (!isNaN(date.getTime())) {\n            return date;\n        }\n        // Try parsing human-readable time formats\n        const today = new Date();\n        const timeRegex = /(\\d{1,2}):(\\d{2})\\s*(AM|PM|am|pm)?/;\n        const match = timeStr.match(timeRegex);\n        if (match) {\n            let [_, hours, minutes, meridiem] = match;\n            let hour = parseInt(hours);\n            // Convert to 24-hour format if meridiem is provided\n            if (meridiem) {\n                if (meridiem.toUpperCase() === \"PM\" && hour < 12) hour += 12;\n                if (meridiem.toUpperCase() === \"AM\" && hour === 12) hour = 0;\n            }\n            date = new Date(today);\n            date.setHours(hour, parseInt(minutes), 0, 0);\n            return date;\n        }\n        throw new Error(\"Unable to parse time: \".concat(timeStr));\n    };\n    const parseDate = (dateStr)=>{\n        try {\n            // If it's just a time string, parse it as time\n            if (dateStr.match(/^\\d{1,2}:\\d{2}(\\s*[AaPp][Mm])?$/)) {\n                return parseTimeString(dateStr);\n            }\n            // Try parsing as full date\n            const date = new Date(dateStr);\n            if (!isNaN(date.getTime())) {\n                return date;\n            }\n            throw new Error(\"Invalid date: \".concat(dateStr));\n        } catch (error) {\n            console.error(\"Date parsing error:\", error);\n            throw new Error(\"Invalid date format: \".concat(dateStr));\n        }\n    };\n    const sendMessage = async (content)=>{\n        console.log(\"=== START sendMessage ===\");\n        setIsLoading(true);\n        try {\n            // Initialize agent\n            console.log(\"Initializing agent...\");\n            const { agent, prompt, functionHandlers } = await (0,_services_chatbot__WEBPACK_IMPORTED_MODULE_1__.initializeAgent)();\n            console.log(\"Agent initialized successfully\");\n            // Format the prompt\n            const formattedPrompt = await prompt.formatMessages({\n                input: content\n            });\n            // Call agent\n            console.log(\"Calling agent...\");\n            const response = await agent.invoke(formattedPrompt);\n            console.log(\"Agent response received:\", response);\n            // Extract content\n            let messageContent = response.content;\n            // Look for schedule task\n            const codeBlockMatch = messageContent.match(/```[\\s\\S]*?schedule_task\\(([\\s\\S]*?)\\)[\\s\\S]*?```/);\n            if (codeBlockMatch) {\n                const paramsText = codeBlockMatch[1];\n                const params = {\n                    title: (paramsText.match(/title=\"([^\"]+)\"/) || [])[1],\n                    startTime: (paramsText.match(/startTime=\"([^\"]+)\"/) || [])[1],\n                    endTime: (paramsText.match(/endTime=\"([^\"]+)\"/) || [])[1],\n                    priority: (paramsText.match(/priority=\"([^\"]+)\"/) || [])[1],\n                    location: (paramsText.match(/location=\"([^\"]+)\"/) || [])[1],\n                    needsTransport: paramsText.includes(\"needsTransport=True\"),\n                    delegatable: paramsText.includes(\"delegatable=True\")\n                };\n                if (params.title && params.startTime) {\n                    // Validate and parse dates\n                    const startTime = parseDate(params.startTime);\n                    const endTime = params.endTime ? parseDate(params.endTime) : new Date(startTime.getTime() + 60 * 60 * 1000);\n                    const storage = _lib_storage__WEBPACK_IMPORTED_MODULE_2__.StorageService.getInstance();\n                    const existingEvents = storage.getTimeBlocks();\n                    // Handle transportation if needed\n                    let transportDetails = null;\n                    if (params.needsTransport && params.location) {\n                        const taxiService = _services_taxiService__WEBPACK_IMPORTED_MODULE_3__.TaxiService.getInstance();\n                        const estimate = await taxiService.estimateTrip(\"current_location\", params.location);\n                        if (estimate.available) {\n                            // Add buffer time for transportation\n                            const pickupTime = new Date(startTime.getTime());\n                            pickupTime.setMinutes(pickupTime.getMinutes() - estimate.duration);\n                            // Process payment first\n                            const paymentDetails = await taxiService.getPaymentDetails(\"current_location\", params.location);\n                            let paymentStatus = \"Pending\";\n                            let transactionHash = \"\";\n                            if (paymentDetails.txHash) {\n                                // Wait for transaction confirmation\n                                const isConfirmed = await taxiService.verifyPayment(paymentDetails.txHash);\n                                paymentStatus = isConfirmed ? \"Confirmed\" : \"Failed\";\n                                transactionHash = paymentDetails.txHash;\n                                if (!isConfirmed) {\n                                    throw new Error(\"Payment failed to confirm\");\n                                }\n                            }\n                            const scheduledEvent = {\n                                _id: crypto.randomUUID(),\n                                title: params.title,\n                                startTime: pickupTime.toISOString(),\n                                endTime: endTime.toISOString(),\n                                priority: params.priority || \"important\",\n                                location: params.location,\n                                transportDetails: {\n                                    pickupTime: pickupTime.toISOString(),\n                                    paymentHash: transactionHash,\n                                    paymentStatus\n                                },\n                                delegatable: params.delegatable || false,\n                                status: \"scheduled\",\n                                created_at: new Date().toISOString(),\n                                updated_at: new Date().toISOString()\n                            };\n                            messageContent = \"\\uD83D\\uDCC5 Event Scheduled: \".concat(params.title, \"\\n⏰ Time: \").concat(startTime.toLocaleString(), \" - \").concat(endTime.toLocaleString(), \"\\n\\uD83D\\uDCCD Location: \").concat(params.location, \"\\n\\uD83D\\uDE95 Transport: Taxi booked for \").concat(pickupTime.toLocaleTimeString(), \"\\n\\uD83D\\uDCB0 Payment: \").concat(paymentStatus, \"\\n\").concat(transactionHash ? \"\\uD83D\\uDCB3 Transaction: \".concat(transactionHash, \"\\n\\uD83D\\uDD0D View on BaseScan: https://sepolia.basescan.org/tx/\").concat(transactionHash) : \"\");\n                            const finalEvent = handleScheduleConflict(scheduledEvent, existingEvents);\n                            storage.addTimeBlock(finalEvent);\n                            const event = new CustomEvent(\"calendarUpdate\", {\n                                detail: finalEvent\n                            });\n                            window.dispatchEvent(event);\n                        }\n                    }\n                }\n            }\n            // Add message to chat history\n            setMessages((prev)=>[\n                    ...prev,\n                    {\n                        content: messageContent,\n                        role: \"assistant\",\n                        timestamp: new Date().toISOString()\n                    }\n                ]);\n        } catch (error) {\n            console.error(\"Error in sendMessage:\", error);\n            setMessages((prev)=>[\n                    ...prev,\n                    {\n                        content: \"Error: \".concat(error.message),\n                        role: \"system\",\n                        timestamp: new Date().toISOString()\n                    }\n                ]);\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    return {\n        messages,\n        setMessages,\n        isLoading,\n        sendMessage\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VDaGF0Ym90LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztnRUFFNEM7QUFDUztBQUNOO0FBQ007QUFFOUMsU0FBU0s7SUFDZCxNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR1AsK0NBQVFBLENBQVEsRUFBRTtJQUNsRCxNQUFNLENBQUNRLFdBQVdDLGFBQWEsR0FBR1QsK0NBQVFBLENBQUM7SUFFM0MsK0NBQStDO0lBQy9DQyxnREFBU0EsQ0FBQztRQUNSLE1BQU1TLGdCQUFnQkMsYUFBYUMsT0FBTyxDQUFDO1FBQzNDLElBQUlGLGVBQWU7WUFDakJILFlBQVlNLEtBQUtDLEtBQUssQ0FBQ0o7UUFDekI7SUFDRixHQUFHLEVBQUU7SUFFTCxxREFBcUQ7SUFDckRULGdEQUFTQSxDQUFDO1FBQ1JVLGFBQWFJLE9BQU8sQ0FBQyxnQkFBZ0JGLEtBQUtHLFNBQVMsQ0FBQ1Y7SUFDdEQsR0FBRztRQUFDQTtLQUFTO0lBRWIsTUFBTVcseUJBQXlCLENBQUNDLFVBQXFCQztRQUNuREMsUUFBUUMsR0FBRyxDQUFDLHFDQUFxQztZQUMvQ0MsT0FBT0osU0FBU0ksS0FBSztZQUNyQkMsT0FBT0wsU0FBU00sU0FBUztZQUN6QkMsVUFBVVAsU0FBU08sUUFBUTtRQUM3QjtRQUNBTCxRQUFRQyxHQUFHLENBQUMsb0JBQW9CRjtRQUVoQyxtQ0FBbUM7UUFDbkMsTUFBTU8sZ0JBQWdCO1lBQ3BCLG9CQUFvQjtZQUNwQixhQUFhO1lBQ2IsVUFBVTtZQUNWLFdBQVc7UUFDYjtRQUVBLDBCQUEwQjtRQUMxQixNQUFNQyxZQUFZUixlQUFlUyxNQUFNLENBQUNDLENBQUFBO1lBQ3RDLE1BQU1DLFdBQVcsSUFBSUMsS0FBS2IsU0FBU00sU0FBUztZQUM1QyxNQUFNUSxTQUFTLElBQUlELEtBQUtiLFNBQVNlLE9BQU87WUFDeEMsTUFBTUMsYUFBYSxJQUFJSCxLQUFLRixNQUFNTCxTQUFTO1lBQzNDLE1BQU1XLFdBQVcsSUFBSUos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QUM1QmpELFNBQVNTO3dCQUNUeUMsTUFBTTt3QkFDTkMsV0FBVyxJQUFJM0csT0FBTzJCLFdBQVc7b0JBQ25DO2lCQUFFO1FBRUosRUFBRSxPQUFPMkIsT0FBTztZQUNkakUsUUFBUWlFLEtBQUssQ0FBQyx5QkFBeUJBO1lBQ3ZDOUUsWUFBWWlJLENBQUFBLE9BQVE7dUJBQUlBO29CQUFNO3dCQUM1QmpELFNBQVMsVUFBd0IsT0FBZEYsTUFBTXNELE9BQU87d0JBQ2hDRixNQUFNO3dCQUNOQyxXQUFXLElBQUkzRyxPQUFPMkIsV0FBVztvQkFDbkM7aUJBQUU7UUFDSixTQUFVO1lBQ1JqRCxhQUFhO1FBQ2Y7SUFDRjtJQUVBLE9BQU87UUFDTEg7UUFDQUM7UUFDQUM7UUFDQThFO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaG9va3MvdXNlQ2hhdGJvdC50cz9kNDZmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGluaXRpYWxpemVBZ2VudCB9IGZyb20gJ0Avc2VydmljZXMvY2hhdGJvdCc7XG5pbXBvcnQgeyBTdG9yYWdlU2VydmljZSB9IGZyb20gJ0AvbGliL3N0b3JhZ2UnO1xuaW1wb3J0IHsgVGF4aVNlcnZpY2UgfSBmcm9tICdAL3NlcnZpY2VzL3RheGlTZXJ2aWNlJztcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoYXRib3QoKSB7XG4gIGNvbnN0IFttZXNzYWdlcywgc2V0TWVzc2FnZXNdID0gdXNlU3RhdGU8YW55W10+KFtdKTtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAvLyBMb2FkIGNoYXQgaGlzdG9yeSBmcm9tIGxvY2FsU3RvcmFnZSBvbiBtb3VudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHNhdmVkTWVzc2FnZXMgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnY2hhdF9oaXN0b3J5Jyk7XG4gICAgaWYgKHNhdmVkTWVzc2FnZXMpIHtcbiAgICAgIHNldE1lc3NhZ2VzKEpTT04ucGFyc2Uoc2F2ZWRNZXNzYWdlcykpO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8vIFNhdmUgbWVzc2FnZXMgdG8gbG9jYWxTdG9yYWdlIHdoZW5ldmVyIHRoZXkgY2hhbmdlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2NoYXRfaGlzdG9yeScsIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2VzKSk7XG4gIH0sIFttZXNzYWdlc10pO1xuXG4gIGNvbnN0IGhhbmRsZVNjaGVkdWxlQ29uZmxpY3QgPSAobmV3RXZlbnQ6IFRpbWVCbG9jaywgZXhpc3RpbmdFdmVudHM6IFRpbWVCbG9ja1tdKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ0NoZWNraW5nIGNvbmZsaWN0cyBmb3IgbmV3IGV2ZW50OicsIHtcbiAgICAgIHRpdGxlOiBuZXdFdmVudC50aXRsZSxcbiAgICAgIHN0YXJ0OiBuZXdFdmVudC5zdGFydFRpbWUsXG4gICAgICBwcmlvcml0eTogbmV3RXZlbnQucHJpb3JpdHlcbiAgICB9KTtcbiAgICBjb25zb2xlLmxvZygnRXhpc3RpbmcgZXZlbnRzOicsIGV4aXN0aW5nRXZlbnRzKTtcblxuICAgIC8vIFNvcnQgZXhpc3RpbmcgZXZlbnRzIGJ5IHByaW9yaXR5XG4gICAgY29uc3QgcHJpb3JpdHlPcmRlciA9IHtcbiAgICAgICd1cmdlbnQtaW1wb3J0YW50JzogMyxcbiAgICAgICdpbXBvcnRhbnQnOiAyLFxuICAgICAgJ3VyZ2VudCc6IDEsXG4gICAgICAnbmVpdGhlcic6IDBcbiAgICB9O1xuXG4gICAgLy8gRmluZCBjb25mbGljdGluZyBldmVudHNcbiAgICBjb25zdCBjb25mbGljdHMgPSBleGlzdGluZ0V2ZW50cy5maWx0ZXIoZXZlbnQgPT4ge1xuICAgICAgY29uc3QgbmV3U3RhcnQgPSBuZXcgRGF0ZShuZXdFdmVudC5zdGFydFRpbWUpO1xuICAgICAgY29uc3QgbmV3RW5kID0gbmV3IERhdGUobmV3RXZlbnQuZW5kVGltZSk7XG4gICAgICBjb25zdCBldmVudFN0YXJ0ID0gbmV3IERhdGUoZXZlbnQuc3RhcnRUaW1lKTtcbiAgICAgIGNvbnN0IGV2ZW50RW5kID0gbmV3IERhdGUoZXZlbnQuZW5kVGltZSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGhhc0NvbmZsaWN0ID0gKFxuICAgICAgICAobmV3U3RhcnQgPj0gZXZlbnRTdGFydCAmJiBuZXdTdGFydCA8IGV2ZW50RW5kKSB8fFxuICAgICAgICAobmV3RW5kID4gZXZlbnRTdGFydCAmJiBuZXdFbmQgPD0gZXZlbnRFbmQpIHx8XG4gICAgICAgIChuZXdTdGFydCA8PSBldmVudFN0YXJ0ICYmIG5ld0VuZCA+PSBldmVudEVuZClcbiAgICAgICk7XG5cbiAgICAgIGlmIChoYXNDb25mbGljdCkge1xuICAgICAgICBjb25zb2xlLmxvZygnRm91bmQgY29uZmxpY3Q6Jywge1xuICAgICAgICAgIGV4aXN0aW5nRXZlbnQ6IGV2ZW50LnRpdGxlLFxuICAgICAgICAgIGV4aXN0aW5nUHJpb3JpdHk6IGV2ZW50LnByaW9yaXR5LFxuICAgICAgICAgIG5ld0V2ZW50OiBuZXdFdmVudC50aXRsZSxcbiAgICAgICAgICBuZXdQcmlvcml0eTogbmV3RXZlbnQucHJpb3JpdHlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBoYXNDb25mbGljdDtcbiAgICB9KTtcblxuICAgIGlmIChjb25mbGljdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zb2xlLmxvZygnTm8gY29uZmxpY3RzIGZvdW5kJyk7XG4gICAgICByZXR1cm4gbmV3RXZlbnQ7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgbmV3IGV2ZW50IGhhcyBoaWdoZXIgcHJpb3JpdHlcbiAgICBjb25zdCBuZXdQcmlvcml0eVNjb3JlID0gcHJpb3JpdHlPcmRlcltuZXdFdmVudC5wcmlvcml0eV07XG4gICAgY29uc3QgaGlnaGVzdENvbmZsaWN0U2NvcmUgPSBNYXRoLm1heChcbiAgICAgIC4uLmNvbmZsaWN0cy5tYXAoZSA9PiBwcmlvcml0eU9yZGVyW2UucHJpb3JpdHldKVxuICAgICk7XG5cbiAgICBjb25zb2xlLmxvZygnUHJpb3JpdHkgY29tcGFyaXNvbjonLCB7XG4gICAgICBuZXdFdmVudFNjb3JlOiBuZXdQcmlvcml0eVNjb3JlLFxuICAgICAgaGlnaGVzdENvbmZsaWN0U2NvcmUsXG4gICAgICB3aWxsUmVzY2hlZHVsZUNvbmZsaWN0czogbmV3UHJpb3JpdHlTY29yZSA+IGhpZ2hlc3RDb25mbGljdFNjb3JlXG4gICAgfSk7XG5cbiAgICBpZiAobmV3UHJpb3JpdHlTY29yZSA+IGhpZ2hlc3RDb25mbGljdFNjb3JlKSB7XG4gICAgICAvLyBNb3ZlIGNvbmZsaWN0aW5nIGV2ZW50c1xuICAgICAgY29uc29sZS5sb2coJ01vdmluZyBjb25mbGljdGluZyBldmVudHMuLi4nKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2UgPSBTdG9yYWdlU2VydmljZS5nZXRJbnN0YW5jZSgpO1xuICAgICAgY29uZmxpY3RzLmZvckVhY2goY29uZmxpY3QgPT4ge1xuICAgICAgICAvLyBNb3ZlIHRvIG5leHQgYXZhaWxhYmxlIHRpbWVcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBuZXcgRGF0ZShjb25mbGljdC5lbmRUaW1lKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShjb25mbGljdC5zdGFydFRpbWUpLmdldFRpbWUoKTtcbiAgICAgICAgY29uc3QgbmV3U3RhcnRUaW1lID0gbmV3IERhdGUobmV3RXZlbnQuZW5kVGltZSk7XG4gICAgICAgIGNvbnN0IG5ld0VuZFRpbWUgPSBuZXcgRGF0ZShuZXdTdGFydFRpbWUuZ2V0VGltZSgpICsgZHVyYXRpb24pO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgdXBkYXRlZEV2ZW50ID0ge1xuICAgICAgICAgIC4uLmNvbmZsaWN0LFxuICAgICAgICAgIHN0YXJ0VGltZTogbmV3U3RhcnRUaW1lLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgZW5kVGltZTogbmV3RW5kVGltZS50b0lTT1N0cmluZygpXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZygnTW92aW5nIGV2ZW50OicsIHtcbiAgICAgICAgICBldmVudDogY29uZmxpY3QudGl0bGUsXG4gICAgICAgICAgZnJvbTogY29uZmxpY3Quc3RhcnRUaW1lLFxuICAgICAgICAgIHRvOiB1cGRhdGVkRXZlbnQuc3RhcnRUaW1lXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgc3RvcmFnZS51cGRhdGVUaW1lQmxvY2sodXBkYXRlZEV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ld0V2ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGaW5kIG5leHQgYXZhaWxhYmxlIHRpbWUgZm9yIG5ldyBldmVudFxuICAgICAgY29uc29sZS5sb2coJ0ZpbmRpbmcgbmV4dCBhdmFpbGFibGUgdGltZSBmb3IgbmV3IGV2ZW50Li4uJyk7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IG5ldyBEYXRlKG5ld0V2ZW50LmVuZFRpbWUpLmdldFRpbWUoKSAtIG5ldyBEYXRlKG5ld0V2ZW50LnN0YXJ0VGltZSkuZ2V0VGltZSgpO1xuICAgICAgY29uc3QgbGFzdENvbmZsaWN0ID0gY29uZmxpY3RzLnNvcnQoKGEsIGIpID0+IFxuICAgICAgICBuZXcgRGF0ZShiLmVuZFRpbWUpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGEuZW5kVGltZSkuZ2V0VGltZSgpXG4gICAgICApWzBdO1xuICAgICAgXG4gICAgICBjb25zdCBuZXdTdGFydFRpbWUgPSBuZXcgRGF0ZShsYXN0Q29uZmxpY3QuZW5kVGltZSk7XG4gICAgICBjb25zdCBuZXdFbmRUaW1lID0gbmV3IERhdGUobmV3U3RhcnRUaW1lLmdldFRpbWUoKSArIGR1cmF0aW9uKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzY2hlZHVsZWRFdmVudCA9IHtcbiAgICAgICAgLi4ubmV3RXZlbnQsXG4gICAgICAgIHN0YXJ0VGltZTogbmV3U3RhcnRUaW1lLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGVuZFRpbWU6IG5ld0VuZFRpbWUudG9JU09TdHJpbmcoKVxuICAgICAgfTtcblxuICAgICAgY29uc29sZS5sb2coJ1Jlc2NoZWR1bGVkIG5ldyBldmVudDonLCB7XG4gICAgICAgIGZyb206IG5ld0V2ZW50LnN0YXJ0VGltZSxcbiAgICAgICAgdG86IHJlc2NoZWR1bGVkRXZlbnQuc3RhcnRUaW1lXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlc2NoZWR1bGVkRXZlbnQ7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHBhcnNlVGltZVN0cmluZyA9ICh0aW1lU3RyOiBzdHJpbmcpOiBEYXRlID0+IHtcbiAgICAvLyBUcnkgSVNPIGZvcm1hdCBmaXJzdFxuICAgIGxldCBkYXRlID0gbmV3IERhdGUodGltZVN0cik7XG4gICAgaWYgKCFpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIC8vIFRyeSBwYXJzaW5nIGh1bWFuLXJlYWRhYmxlIHRpbWUgZm9ybWF0c1xuICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCB0aW1lUmVnZXggPSAvKFxcZHsxLDJ9KTooXFxkezJ9KVxccyooQU18UE18YW18cG0pPy87XG4gICAgY29uc3QgbWF0Y2ggPSB0aW1lU3RyLm1hdGNoKHRpbWVSZWdleCk7XG4gICAgXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBsZXQgW18sIGhvdXJzLCBtaW51dGVzLCBtZXJpZGllbV0gPSBtYXRjaDtcbiAgICAgIGxldCBob3VyID0gcGFyc2VJbnQoaG91cnMpO1xuICAgICAgXG4gICAgICAvLyBDb252ZXJ0IHRvIDI0LWhvdXIgZm9ybWF0IGlmIG1lcmlkaWVtIGlzIHByb3ZpZGVkXG4gICAgICBpZiAobWVyaWRpZW0pIHtcbiAgICAgICAgaWYgKG1lcmlkaWVtLnRvVXBwZXJDYXNlKCkgPT09ICdQTScgJiYgaG91ciA8IDEyKSBob3VyICs9IDEyO1xuICAgICAgICBpZiAobWVyaWRpZW0udG9VcHBlckNhc2UoKSA9PT0gJ0FNJyAmJiBob3VyID09PSAxMikgaG91ciA9IDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGRhdGUgPSBuZXcgRGF0ZSh0b2RheSk7XG4gICAgICBkYXRlLnNldEhvdXJzKGhvdXIsIHBhcnNlSW50KG1pbnV0ZXMpLCAwLCAwKTtcbiAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHBhcnNlIHRpbWU6ICR7dGltZVN0cn1gKTtcbiAgfTtcblxuICBjb25zdCBwYXJzZURhdGUgPSAoZGF0ZVN0cjogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIElmIGl0J3MganVzdCBhIHRpbWUgc3RyaW5nLCBwYXJzZSBpdCBhcyB0aW1lXG4gICAgICBpZiAoZGF0ZVN0ci5tYXRjaCgvXlxcZHsxLDJ9OlxcZHsyfShcXHMqW0FhUHBdW01tXSk/JC8pKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVRpbWVTdHJpbmcoZGF0ZVN0cik7XG4gICAgICB9XG5cbiAgICAgIC8vIFRyeSBwYXJzaW5nIGFzIGZ1bGwgZGF0ZVxuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGRhdGVTdHIpO1xuICAgICAgaWYgKCFpc05hTihkYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRlOiAke2RhdGVTdHJ9YCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0RhdGUgcGFyc2luZyBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGF0ZSBmb3JtYXQ6ICR7ZGF0ZVN0cn1gKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgc2VuZE1lc3NhZ2UgPSBhc3luYyAoY29udGVudDogc3RyaW5nKSA9PiB7XG4gICAgY29uc29sZS5sb2coJz09PSBTVEFSVCBzZW5kTWVzc2FnZSA9PT0nKTtcbiAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gSW5pdGlhbGl6ZSBhZ2VudFxuICAgICAgY29uc29sZS5sb2coJ0luaXRpYWxpemluZyBhZ2VudC4uLicpO1xuICAgICAgY29uc3QgeyBhZ2VudCwgcHJvbXB0LCBmdW5jdGlvbkhhbmRsZXJzIH0gPSBhd2FpdCBpbml0aWFsaXplQWdlbnQoKTtcbiAgICAgIGNvbnNvbGUubG9nKCdBZ2VudCBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHknKTtcblxuICAgICAgLy8gRm9ybWF0IHRoZSBwcm9tcHRcbiAgICAgIGNvbnN0IGZvcm1hdHRlZFByb21wdCA9IGF3YWl0IHByb21wdC5mb3JtYXRNZXNzYWdlcyh7XG4gICAgICAgIGlucHV0OiBjb250ZW50XG4gICAgICB9KTtcblxuICAgICAgLy8gQ2FsbCBhZ2VudFxuICAgICAgY29uc29sZS5sb2coJ0NhbGxpbmcgYWdlbnQuLi4nKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWdlbnQuaW52b2tlKGZvcm1hdHRlZFByb21wdCk7XG4gICAgICBjb25zb2xlLmxvZygnQWdlbnQgcmVzcG9uc2UgcmVjZWl2ZWQ6JywgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBFeHRyYWN0IGNvbnRlbnRcbiAgICAgIGxldCBtZXNzYWdlQ29udGVudCA9IHJlc3BvbnNlLmNvbnRlbnQ7XG5cbiAgICAgIC8vIExvb2sgZm9yIHNjaGVkdWxlIHRhc2tcbiAgICAgIGNvbnN0IGNvZGVCbG9ja01hdGNoID0gbWVzc2FnZUNvbnRlbnQubWF0Y2goL2BgYFtcXHNcXFNdKj9zY2hlZHVsZV90YXNrXFwoKFtcXHNcXFNdKj8pXFwpW1xcc1xcU10qP2BgYC8pO1xuICAgICAgaWYgKGNvZGVCbG9ja01hdGNoKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtc1RleHQgPSBjb2RlQmxvY2tNYXRjaFsxXTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgIHRpdGxlOiAocGFyYW1zVGV4dC5tYXRjaCgvdGl0bGU9XCIoW15cIl0rKVwiLykgfHwgW10pWzFdLFxuICAgICAgICAgIHN0YXJ0VGltZTogKHBhcmFtc1RleHQubWF0Y2goL3N0YXJ0VGltZT1cIihbXlwiXSspXCIvKSB8fCBbXSlbMV0sXG4gICAgICAgICAgZW5kVGltZTogKHBhcmFtc1RleHQubWF0Y2goL2VuZFRpbWU9XCIoW15cIl0rKVwiLykgfHwgW10pWzFdLFxuICAgICAgICAgIHByaW9yaXR5OiAocGFyYW1zVGV4dC5tYXRjaCgvcHJpb3JpdHk9XCIoW15cIl0rKVwiLykgfHwgW10pWzFdLFxuICAgICAgICAgIGxvY2F0aW9uOiAocGFyYW1zVGV4dC5tYXRjaCgvbG9jYXRpb249XCIoW15cIl0rKVwiLykgfHwgW10pWzFdLFxuICAgICAgICAgIG5lZWRzVHJhbnNwb3J0OiBwYXJhbXNUZXh0LmluY2x1ZGVzKCduZWVkc1RyYW5zcG9ydD1UcnVlJyksXG4gICAgICAgICAgZGVsZWdhdGFibGU6IHBhcmFtc1RleHQuaW5jbHVkZXMoJ2RlbGVnYXRhYmxlPVRydWUnKVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChwYXJhbXMudGl0bGUgJiYgcGFyYW1zLnN0YXJ0VGltZSkge1xuICAgICAgICAgIC8vIFZhbGlkYXRlIGFuZCBwYXJzZSBkYXRlc1xuICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBhcnNlRGF0ZShwYXJhbXMuc3RhcnRUaW1lKTtcbiAgICAgICAgICBjb25zdCBlbmRUaW1lID0gcGFyYW1zLmVuZFRpbWUgPyBwYXJzZURhdGUocGFyYW1zLmVuZFRpbWUpIDogXG4gICAgICAgICAgICBuZXcgRGF0ZShzdGFydFRpbWUuZ2V0VGltZSgpICsgNjAgKiA2MCAqIDEwMDApO1xuXG4gICAgICAgICAgY29uc3Qgc3RvcmFnZSA9IFN0b3JhZ2VTZXJ2aWNlLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdFdmVudHMgPSBzdG9yYWdlLmdldFRpbWVCbG9ja3MoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBIYW5kbGUgdHJhbnNwb3J0YXRpb24gaWYgbmVlZGVkXG4gICAgICAgICAgbGV0IHRyYW5zcG9ydERldGFpbHMgPSBudWxsO1xuICAgICAgICAgIGlmIChwYXJhbXMubmVlZHNUcmFuc3BvcnQgJiYgcGFyYW1zLmxvY2F0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCB0YXhpU2VydmljZSA9IFRheGlTZXJ2aWNlLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgICBjb25zdCBlc3RpbWF0ZSA9IGF3YWl0IHRheGlTZXJ2aWNlLmVzdGltYXRlVHJpcCgnY3VycmVudF9sb2NhdGlvbicsIHBhcmFtcy5sb2NhdGlvbik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChlc3RpbWF0ZS5hdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgLy8gQWRkIGJ1ZmZlciB0aW1lIGZvciB0cmFuc3BvcnRhdGlvblxuICAgICAgICAgICAgICBjb25zdCBwaWNrdXBUaW1lID0gbmV3IERhdGUoc3RhcnRUaW1lLmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgIHBpY2t1cFRpbWUuc2V0TWludXRlcyhwaWNrdXBUaW1lLmdldE1pbnV0ZXMoKSAtIGVzdGltYXRlLmR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFByb2Nlc3MgcGF5bWVudCBmaXJzdFxuICAgICAgICAgICAgICBjb25zdCBwYXltZW50RGV0YWlscyA9IGF3YWl0IHRheGlTZXJ2aWNlLmdldFBheW1lbnREZXRhaWxzKCdjdXJyZW50X2xvY2F0aW9uJywgcGFyYW1zLmxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgbGV0IHBheW1lbnRTdGF0dXMgPSAnUGVuZGluZyc7XG4gICAgICAgICAgICAgIGxldCB0cmFuc2FjdGlvbkhhc2ggPSAnJztcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmIChwYXltZW50RGV0YWlscy50eEhhc2gpIHtcbiAgICAgICAgICAgICAgICAvLyBXYWl0IGZvciB0cmFuc2FjdGlvbiBjb25maXJtYXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBpc0NvbmZpcm1lZCA9IGF3YWl0IHRheGlTZXJ2aWNlLnZlcmlmeVBheW1lbnQocGF5bWVudERldGFpbHMudHhIYXNoKTtcbiAgICAgICAgICAgICAgICBwYXltZW50U3RhdHVzID0gaXNDb25maXJtZWQgPyAnQ29uZmlybWVkJyA6ICdGYWlsZWQnO1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaCA9IHBheW1lbnREZXRhaWxzLnR4SGFzaDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ29uZmlybWVkKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BheW1lbnQgZmFpbGVkIHRvIGNvbmZpcm0nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGNvbnN0IHNjaGVkdWxlZEV2ZW50ID0ge1xuICAgICAgICAgICAgICAgIF9pZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcbiAgICAgICAgICAgICAgICB0aXRsZTogcGFyYW1zLnRpdGxlLFxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogcGlja3VwVGltZS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIGVuZFRpbWU6IGVuZFRpbWUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBwcmlvcml0eTogcGFyYW1zLnByaW9yaXR5IHx8IFwiaW1wb3J0YW50XCIsXG4gICAgICAgICAgICAgICAgbG9jYXRpb246IHBhcmFtcy5sb2NhdGlvbixcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnREZXRhaWxzOiB7XG4gICAgICAgICAgICAgICAgICBwaWNrdXBUaW1lOiBwaWNrdXBUaW1lLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICBwYXltZW50SGFzaDogdHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgICAgICAgcGF5bWVudFN0YXR1c1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVsZWdhdGFibGU6IHBhcmFtcy5kZWxlZ2F0YWJsZSB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdzY2hlZHVsZWQnLFxuICAgICAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBtZXNzYWdlQ29udGVudCA9IGDwn5OFIEV2ZW50IFNjaGVkdWxlZDogJHtwYXJhbXMudGl0bGV9XG7ij7AgVGltZTogJHtzdGFydFRpbWUudG9Mb2NhbGVTdHJpbmcoKX0gLSAke2VuZFRpbWUudG9Mb2NhbGVTdHJpbmcoKX1cbvCfk40gTG9jYXRpb246ICR7cGFyYW1zLmxvY2F0aW9ufVxu8J+alSBUcmFuc3BvcnQ6IFRheGkgYm9va2VkIGZvciAke3BpY2t1cFRpbWUudG9Mb2NhbGVUaW1lU3RyaW5nKCl9XG7wn5KwIFBheW1lbnQ6ICR7cGF5bWVudFN0YXR1c31cbiR7dHJhbnNhY3Rpb25IYXNoID8gYPCfkrMgVHJhbnNhY3Rpb246ICR7dHJhbnNhY3Rpb25IYXNofVxu8J+UjSBWaWV3IG9uIEJhc2VTY2FuOiBodHRwczovL3NlcG9saWEuYmFzZXNjYW4ub3JnL3R4LyR7dHJhbnNhY3Rpb25IYXNofWAgOiAnJ31gO1xuXG4gICAgICAgICAgICAgIGNvbnN0IGZpbmFsRXZlbnQgPSBoYW5kbGVTY2hlZHVsZUNvbmZsaWN0KHNjaGVkdWxlZEV2ZW50LCBleGlzdGluZ0V2ZW50cyk7XG4gICAgICAgICAgICAgIHN0b3JhZ2UuYWRkVGltZUJsb2NrKGZpbmFsRXZlbnQpO1xuXG4gICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdjYWxlbmRhclVwZGF0ZScsIHtcbiAgICAgICAgICAgICAgICBkZXRhaWw6IGZpbmFsRXZlbnRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWRkIG1lc3NhZ2UgdG8gY2hhdCBoaXN0b3J5XG4gICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IFsuLi5wcmV2LCB7XG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2VDb250ZW50LFxuICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH1dKTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBzZW5kTWVzc2FnZTonLCBlcnJvcik7XG4gICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IFsuLi5wcmV2LCB7XG4gICAgICAgIGNvbnRlbnQ6IGBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICAgIHJvbGU6ICdzeXN0ZW0nLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfV0pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG1lc3NhZ2VzLFxuICAgIHNldE1lc3NhZ2VzLFxuICAgIGlzTG9hZGluZyxcbiAgICBzZW5kTWVzc2FnZVxuICB9O1xufSAiXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJpbml0aWFsaXplQWdlbnQiLCJTdG9yYWdlU2VydmljZSIsIlRheGlTZXJ2aWNlIiwidXNlQ2hhdGJvdCIsIm1lc3NhZ2VzIiwic2V0TWVzc2FnZXMiLCJpc0xvYWRpbmciLCJzZXRJc0xvYWRpbmciLCJzYXZlZE1lc3NhZ2VzIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIkpTT04iLCJwYXJzZSIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJoYW5kbGVTY2hlZHVsZUNvbmZsaWN0IiwibmV3RXZlbnQiLCJleGlzdGluZ0V2ZW50cyIsImNvbnNvbGUiLCJsb2ciLCJ0aXRsZSIsInN0YXJ0Iiwic3RhcnRUaW1lIiwicHJpb3JpdHkiLCJwcmlvcml0eU9yZGVyIiwiY29uZmxpY3RzIiwiZmlsdGVyIiwiZXZlbnQiLCJuZXdTdGFydCIsIkRhdGUiLCJuZXdFbmQiLCJlbmRUaW1lIiwiZXZlbnRTdGFydCIsImV2ZW50RW5kIiwiaGFzQ29uZmxpY3QiLCJleGlzdGluZ0V2ZW50IiwiZXhpc3RpbmdQcmlvcml0eSIsIm5ld1ByaW9yaXR5IiwibGVuZ3RoIiwibmV3UHJpb3JpdHlTY29yZSIsImhpZ2hlc3RDb25mbGljdFNjb3JlIiwiTWF0aCIsIm1heCIsIm1hcCIsImUiLCJuZXdFdmVudFNjb3JlIiwid2lsbFJlc2NoZWR1bGVDb25mbGljdHMiLCJzdG9yYWdlIiwiZ2V0SW5zdGFuY2UiLCJmb3JFYWNoIiwiY29uZmxpY3QiLCJkdXJhdGlvbiIsImdldFRpbWUiLCJuZXdTdGFydFRpbWUiLCJuZXdFbmRUaW1lIiwidXBkYXRlZEV2ZW50IiwidG9JU09TdHJpbmciLCJmcm9tIiwidG8iLCJ1cGRhdGVUaW1lQmxvY2siLCJsYXN0Q29uZmxpY3QiLCJzb3J0IiwiYSIsImIiLCJyZXNjaGVkdWxlZEV2ZW50IiwicGFyc2VUaW1lU3RyaW5nIiwidGltZVN0ciIsImRhdGUiLCJpc05hTiIsInRvZGF5IiwidGltZVJlZ2V4IiwibWF0Y2giLCJfIiwiaG91cnMiLCJtaW51dGVzIiwibWVyaWRpZW0iLCJob3VyIiwicGFyc2VJbnQiLCJ0b1VwcGVyQ2FzZSIsInNldEhvdXJzIiwiRXJyb3IiLCJwYXJzZURhdGUiLCJkYXRlU3RyIiwiZXJyb3IiLCJzZW5kTWVzc2FnZSIsImNvbnRlbnQiLCJhZ2VudCIsInByb21wdCIsImZ1bmN0aW9uSGFuZGxlcnMiLCJmb3JtYXR0ZWRQcm9tcHQiLCJmb3JtYXRNZXNzYWdlcyIsImlucHV0IiwicmVzcG9uc2UiLCJpbnZva2UiLCJtZXNzYWdlQ29udGVudCIsImNvZGVCbG9ja01hdGNoIiwicGFyYW1zVGV4dCIsInBhcmFtcyIsImxvY2F0aW9uIiwibmVlZHNUcmFuc3BvcnQiLCJpbmNsdWRlcyIsImRlbGVnYXRhYmxlIiwiZ2V0VGltZUJsb2NrcyIsInRyYW5zcG9ydERldGFpbHMiLCJ0YXhpU2VydmljZSIsImVzdGltYXRlIiwiZXN0aW1hdGVUcmlwIiwiYXZhaWxhYmxlIiwicGlja3VwVGltZSIsInNldE1pbnV0ZXMiLCJnZXRNaW51dGVzIiwicGF5bWVudERldGFpbHMiLCJnZXRQYXltZW50RGV0YWlscyIsInBheW1lbnRTdGF0dXMiLCJ0cmFuc2FjdGlvbkhhc2giLCJ0eEhhc2giLCJpc0NvbmZpcm1lZCIsInZlcmlmeVBheW1lbnQiLCJzY2hlZHVsZWRFdmVudCIsIl9pZCIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJwYXltZW50SGFzaCIsInN0YXR1cyIsImNyZWF0ZWRfYXQiLCJ1cGRhdGVkX2F0IiwidG9Mb2NhbGVTdHJpbmciLCJ0b0xvY2FsZVRpbWVTdHJpbmciLCJmaW5hbEV2ZW50IiwiYWRkVGltZUJsb2NrIiwiQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJ3aW5kb3ciLCJkaXNwYXRjaEV2ZW50IiwicHJldiIsInJvbGUiLCJ0aW1lc3RhbXAiLCJtZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useChatbot.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/services/faucetService.ts":
/*!***************************************!*\
  !*** ./src/services/faucetService.ts ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FaucetService: function() { return /* binding */ FaucetService; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/../../../node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/../../../node_modules/ethers/lib.esm/wallet/wallet.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/../../../node_modules/ethers/lib.esm/utils/units.js\");\n\nclass FaucetService {\n    async initializeWallet() {\n        try {\n            console.log(\"Initializing wallet...\");\n            // Initialize provider first\n            this.provider = new ethers__WEBPACK_IMPORTED_MODULE_0__.JsonRpcProvider(\"https://sepolia.base.org\");\n            await this.provider.ready; // Wait for provider to be ready\n            const privateKey = \"2b945b366efae3ee40b09211fbab0622e12bcac71b2fadb12aff3e9a1661ad4b\";\n            if (!privateKey) {\n                throw new Error(\"Please set NEXT_PUBLIC_WALLET_PRIVATE_KEY in your environment variables\");\n            }\n            // Create wallet with provider\n            this.wallet = new ethers__WEBPACK_IMPORTED_MODULE_1__.Wallet(privateKey).connect(this.provider);\n            // Verify wallet is connected\n            try {\n                const address = await this.wallet.getAddress();\n                console.log(\"Wallet initialized for address:\", address);\n            } catch (error) {\n                throw new Error(\"Failed to connect wallet to provider\");\n            }\n        } catch (error) {\n            console.error(\"Failed to initialize wallet:\", error);\n            throw error;\n        }\n    }\n    static getInstance() {\n        if (!FaucetService.instance) {\n            FaucetService.instance = new FaucetService();\n        }\n        return FaucetService.instance;\n    }\n    async requestAndSendETH(toAddress, amount) {\n        try {\n            var _receipt_gasUsed;\n            await this.initialized;\n            if (!this.wallet || !this.provider) {\n                throw new Error(\"Wallet not initialized\");\n            }\n            // Check current balance\n            const senderAddress = await this.wallet.getAddress();\n            console.log(\"\\uD83D\\uDCB0 Payment Details:\", {\n                from: senderAddress,\n                to: toAddress,\n                amount: amount,\n                network: \"Base Sepolia\"\n            });\n            const currentBalance = await this.provider.getBalance(senderAddress);\n            console.log(\"Current wallet balance:\", ethers__WEBPACK_IMPORTED_MODULE_2__.formatEther(currentBalance), \"ETH\");\n            const requiredAmount = ethers__WEBPACK_IMPORTED_MODULE_2__.parseEther(amount.toString());\n            if (currentBalance < requiredAmount) {\n                throw new Error(\"Insufficient balance. Have: \".concat(ethers__WEBPACK_IMPORTED_MODULE_2__.formatEther(currentBalance), \" ETH, Need: \").concat(amount, \" ETH\"));\n            }\n            // Send payment\n            console.log(\"\\uD83D\\uDE80 Initiating payment...\");\n            const tx = await this.wallet.sendTransaction({\n                to: toAddress,\n                value: requiredAmount\n            });\n            console.log(\"⏳ Waiting for transaction confirmation...\");\n            const receipt = await tx.wait();\n            console.log(\"✅ Payment confirmed:\", {\n                transactionHash: receipt.hash,\n                blockNumber: receipt.blockNumber,\n                from: receipt.from,\n                to: receipt.to,\n                amount: ethers__WEBPACK_IMPORTED_MODULE_2__.formatEther(receipt.value || requiredAmount),\n                gasUsed: (_receipt_gasUsed = receipt.gasUsed) === null || _receipt_gasUsed === void 0 ? void 0 : _receipt_gasUsed.toString()\n            });\n            // Verify final balance\n            const newBalance = await this.provider.getBalance(senderAddress);\n            console.log(\"New wallet balance:\", ethers__WEBPACK_IMPORTED_MODULE_2__.formatEther(newBalance), \"ETH\");\n            // Add Etherscan link\n            console.log(\"\\uD83D\\uDD0D View transaction: https://sepolia.basescan.org/tx/\".concat(receipt.hash));\n            return receipt.hash;\n        } catch (error) {\n            console.error(\"❌ Error in payment service:\", error);\n            throw error;\n        }\n    }\n    async verifyTransaction(txHash) {\n        try {\n            await this.initialized;\n            if (!this.provider) {\n                throw new Error(\"Provider not initialized\");\n            }\n            const receipt = await this.provider.getTransactionReceipt(txHash);\n            return receipt !== null && receipt.status === 1;\n        } catch (error) {\n            console.error(\"Error verifying transaction:\", error);\n            return false;\n        }\n    }\n    constructor(){\n        this.provider = null;\n        this.wallet = null;\n        this.initialized = this.initializeWallet();\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9mYXVjZXRTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0M7QUFFekIsTUFBTUM7SUFVWCxNQUFjQyxtQkFBbUI7UUFDL0IsSUFBSTtZQUNGQyxRQUFRQyxHQUFHLENBQUM7WUFFWiw0QkFBNEI7WUFDNUIsSUFBSSxDQUFDQyxRQUFRLEdBQUcsSUFBSUwsbURBQXNCLENBQUM7WUFDM0MsTUFBTSxJQUFJLENBQUNLLFFBQVEsQ0FBQ0UsS0FBSyxFQUFFLGdDQUFnQztZQUUzRCxNQUFNQyxhQUFhQyxrRUFBMEM7WUFDN0QsSUFBSSxDQUFDRCxZQUFZO2dCQUNmLE1BQU0sSUFBSUksTUFBTTtZQUNsQjtZQUVBLDhCQUE4QjtZQUM5QixJQUFJLENBQUNDLE1BQU0sR0FBRyxJQUFJYiwwQ0FBYSxDQUFDUSxZQUFZTyxPQUFPLENBQUMsSUFBSSxDQUFDVixRQUFRO1lBRWpFLDZCQUE2QjtZQUM3QixJQUFJO2dCQUNGLE1BQU1XLFVBQVUsTUFBTSxJQUFJLENBQUNILE1BQU0sQ0FBQ0ksVUFBVTtnQkFDNUNkLFFBQVFDLEdBQUcsQ0FBQyxtQ0FBbUNZO1lBQ2pELEVBQUUsT0FBT0UsT0FBTztnQkFDZCxNQUFNLElBQUlOLE1BQU07WUFDbEI7UUFFRixFQUFFLE9BQU9NLE9BQU87WUFDZGYsUUFBUWUsS0FBSyxDQUFDLGdDQUFnQ0E7WUFDOUMsTUFBTUE7UUFDUjtJQUNGO0lBRUEsT0FBT0MsY0FBNkI7UUFDbEMsSUFBSSxDQUFDbEIsY0FBY21CLFFBQVEsRUFBRTtZQUMzQm5CLGNBQWNtQixRQUFRLEdBQUcsSUFBSW5CO1FBQy9CO1FBQ0EsT0FBT0EsY0FBY21CLFFBQVE7SUFDL0I7SUFFQSxNQUFNQyxrQkFBa0JDLFNBQWlCLEVBQUVDLE1BQWMsRUFBbUI7UUFDMUUsSUFBSTtnQkF3Q1NDO1lBdkNYLE1BQU0sSUFBSSxDQUFDQyxXQUFXO1lBRXRCLElBQUksQ0FBQyxJQUFJLENBQUNaLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQ1IsUUFBUSxFQUFFO2dCQUNsQyxNQUFNLElBQUlPLE1BQU07WUFDbEI7WUFFQSx3QkFBd0I7WUFDeEIsTUFBTWMsZ0JBQWdCLE1BQU0sSUFBSSxDQUFDYixNQUFNLENBQUNJLFVBQVU7WUFDbERkLFFBQVFDLEdBQUcsQ0FBQyxpQ0FBdUI7Z0JBQ2pDdUIsTUFBTUQ7Z0JBQ05FLElBQUlOO2dCQUNKQyxRQUFRQTtnQkFDUk0sU0FBUztZQUNYO1lBRUEsTUFBTUMsaUJBQWlCLE1BQU0sSUFBSSxDQUFDekIsUUFBUSxDQUFDMEIsVUFBVSxDQUFDTDtZQUN0RHZCLFFBQVFDLEdBQUcsQ0FBQywyQkFBMkJKLCtDQUFrQixDQUFDOEIsaUJBQWlCO1lBRTNFLE1BQU1HLGlCQUFpQmpDLDhDQUFpQixDQUFDdUIsT0FBT1ksUUFBUTtZQUN4RCxJQUFJTCxpQkFBaUJHLGdCQUFnQjtnQkFDbkMsTUFBTSxJQUFJckIsTUFBTSwrQkFBZ0ZXLE9BQWpEdkIsK0NBQWtCLENBQUM4QixpQkFBZ0IsZ0JBQXFCLE9BQVBQLFFBQU87WUFDekc7WUFFQSxlQUFlO1lBQ2ZwQixRQUFRQyxHQUFHLENBQUM7WUFDWixNQUFNZ0MsS0FBSyxNQUFNLElBQUksQ0FBQ3ZCLE1BQU0sQ0FBQ3dCLGVBQWUsQ0FBQztnQkFDM0NULElBQUlOO2dCQUNKZ0IsT0FBT0w7WUFDVDtZQUVBOUIsUUFBUUMsR0FBRyxDQUFDO1lBQ1osTUFBTW9CLFVBQVUsTUFBTVksR0FBR0csSUFBSTtZQUU3QnBDLFFBQVFDLEdBQUcsQ0FBQyx3QkFBd0I7Z0JBQ2xDb0MsaUJBQWlCaEIsUUFBUWlCLElBQUk7Z0JBQzdCQyxhQUFhbEIsUUFBUWtCLFdBQVc7Z0JBQ2hDZixNQUFNSCxRQUFRRyxJQUFJO2dCQUNsQkMsSUFBSUosUUFBUUksRUFBRTtnQkFDZEwsUUFBUXZCLCtDQUFrQixDQUFDd0IsUUFBUWMsS0FBSyxJQUFJTDtnQkFDNUNVLE9BQU8sR0FBRW5CLG1CQUFBQSxRQUFRbUIsT0FBTyxjQUFmbkIsdUNBQUFBLGlCQUFpQlcsUUFBUTtZQUNwQztZQUVBLHVCQUF1QjtZQUN2QixNQUFNUyxhQUFhLE1BQU0sSUFBSSxDQUFDdkMsUUFBUSxDQUFDMEIsVUFBVSxDQUFDTDtZQUNsRHZCLFFBQVFDLEdBQUcsQ0FBQyx1QkFBdUJKLCtDQUFrQixDQUFDNEMsYUFBYTtZQUVuRSxxQkFBcUI7WUFDckJ6QyxRQUFRQyxHQUFHLENBQUMsa0VBQXFFLE9BQWJvQixRQUFRaUIsSUFBSTtZQUVoRixPQUFPakIsUUFBUWlCLElBQUk7UUFDckIsRUFBRSxPQUFPdkIsT0FBTztZQUNkZixRQUFRZSxLQUFLLENBQUMsK0JBQStCQTtZQUM3QyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxNQUFNMkIsa0JBQWtCQyxNQUFjLEVBQW9CO1FBQ3hELElBQUk7WUFDRixNQUFNLElBQUksQ0FBQ3JCLFdBQVc7WUFDdEIsSUFBSSxDQUFDLElBQUksQ0FBQ3BCLFFBQVEsRUFBRTtnQkFDbEIsTUFBTSxJQUFJTyxNQUFNO1lBQ2xCO1lBRUEsTUFBTVksVUFBVSxNQUFNLElBQUksQ0FBQ25CLFFBQVEsQ0FBQzBDLHFCQUFxQixDQUFDRDtZQUMxRCxPQUFPdEIsWUFBWSxRQUFRQSxRQUFRd0IsTUFBTSxLQUFLO1FBQ2hELEVBQUUsT0FBTzlCLE9BQU87WUFDZGYsUUFBUWUsS0FBSyxDQUFDLGdDQUFnQ0E7WUFDOUMsT0FBTztRQUNUO0lBQ0Y7SUFoSEEsYUFBc0I7YUFKZGIsV0FBMEM7YUFDMUNRLFNBQStCO1FBSXJDLElBQUksQ0FBQ1ksV0FBVyxHQUFHLElBQUksQ0FBQ3ZCLGdCQUFnQjtJQUMxQztBQStHRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc2VydmljZXMvZmF1Y2V0U2VydmljZS50cz9kMzM0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV0aGVycyB9IGZyb20gXCJldGhlcnNcIjtcblxuZXhwb3J0IGNsYXNzIEZhdWNldFNlcnZpY2Uge1xuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogRmF1Y2V0U2VydmljZTtcbiAgcHJpdmF0ZSBwcm92aWRlcjogZXRoZXJzLkpzb25ScGNQcm92aWRlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIHdhbGxldDogZXRoZXJzLldhbGxldCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGluaXRpYWxpemVkOiBQcm9taXNlPHZvaWQ+O1xuICBcbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gdGhpcy5pbml0aWFsaXplV2FsbGV0KCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGluaXRpYWxpemVXYWxsZXQoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCdJbml0aWFsaXppbmcgd2FsbGV0Li4uJyk7XG4gICAgICBcbiAgICAgIC8vIEluaXRpYWxpemUgcHJvdmlkZXIgZmlyc3RcbiAgICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcignaHR0cHM6Ly9zZXBvbGlhLmJhc2Uub3JnJyk7XG4gICAgICBhd2FpdCB0aGlzLnByb3ZpZGVyLnJlYWR5OyAvLyBXYWl0IGZvciBwcm92aWRlciB0byBiZSByZWFkeVxuICAgICAgXG4gICAgICBjb25zdCBwcml2YXRlS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfV0FMTEVUX1BSSVZBVEVfS0VZO1xuICAgICAgaWYgKCFwcml2YXRlS2V5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHNldCBORVhUX1BVQkxJQ19XQUxMRVRfUFJJVkFURV9LRVkgaW4geW91ciBlbnZpcm9ubWVudCB2YXJpYWJsZXMnKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIHdhbGxldCB3aXRoIHByb3ZpZGVyXG4gICAgICB0aGlzLndhbGxldCA9IG5ldyBldGhlcnMuV2FsbGV0KHByaXZhdGVLZXkpLmNvbm5lY3QodGhpcy5wcm92aWRlcik7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSB3YWxsZXQgaXMgY29ubmVjdGVkXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdGhpcy53YWxsZXQuZ2V0QWRkcmVzcygpO1xuICAgICAgICBjb25zb2xlLmxvZygnV2FsbGV0IGluaXRpYWxpemVkIGZvciBhZGRyZXNzOicsIGFkZHJlc3MpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY29ubmVjdCB3YWxsZXQgdG8gcHJvdmlkZXInKTtcbiAgICAgIH1cbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSB3YWxsZXQ6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IEZhdWNldFNlcnZpY2Uge1xuICAgIGlmICghRmF1Y2V0U2VydmljZS5pbnN0YW5jZSkge1xuICAgICAgRmF1Y2V0U2VydmljZS5pbnN0YW5jZSA9IG5ldyBGYXVjZXRTZXJ2aWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBGYXVjZXRTZXJ2aWNlLmluc3RhbmNlO1xuICB9XG5cbiAgYXN5bmMgcmVxdWVzdEFuZFNlbmRFVEgodG9BZGRyZXNzOiBzdHJpbmcsIGFtb3VudDogbnVtYmVyKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplZDtcblxuICAgICAgaWYgKCF0aGlzLndhbGxldCB8fCAhdGhpcy5wcm92aWRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dhbGxldCBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgY3VycmVudCBiYWxhbmNlXG4gICAgICBjb25zdCBzZW5kZXJBZGRyZXNzID0gYXdhaXQgdGhpcy53YWxsZXQuZ2V0QWRkcmVzcygpO1xuICAgICAgY29uc29sZS5sb2coJ/CfkrAgUGF5bWVudCBEZXRhaWxzOicsIHtcbiAgICAgICAgZnJvbTogc2VuZGVyQWRkcmVzcyxcbiAgICAgICAgdG86IHRvQWRkcmVzcyxcbiAgICAgICAgYW1vdW50OiBhbW91bnQsXG4gICAgICAgIG5ldHdvcms6ICdCYXNlIFNlcG9saWEnXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgY3VycmVudEJhbGFuY2UgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldEJhbGFuY2Uoc2VuZGVyQWRkcmVzcyk7XG4gICAgICBjb25zb2xlLmxvZygnQ3VycmVudCB3YWxsZXQgYmFsYW5jZTonLCBldGhlcnMuZm9ybWF0RXRoZXIoY3VycmVudEJhbGFuY2UpLCAnRVRIJyk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlcXVpcmVkQW1vdW50ID0gZXRoZXJzLnBhcnNlRXRoZXIoYW1vdW50LnRvU3RyaW5nKCkpO1xuICAgICAgaWYgKGN1cnJlbnRCYWxhbmNlIDwgcmVxdWlyZWRBbW91bnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN1ZmZpY2llbnQgYmFsYW5jZS4gSGF2ZTogJHtldGhlcnMuZm9ybWF0RXRoZXIoY3VycmVudEJhbGFuY2UpfSBFVEgsIE5lZWQ6ICR7YW1vdW50fSBFVEhgKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2VuZCBwYXltZW50XG4gICAgICBjb25zb2xlLmxvZygn8J+agCBJbml0aWF0aW5nIHBheW1lbnQuLi4nKTtcbiAgICAgIGNvbnN0IHR4ID0gYXdhaXQgdGhpcy53YWxsZXQuc2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgdG86IHRvQWRkcmVzcyxcbiAgICAgICAgdmFsdWU6IHJlcXVpcmVkQW1vdW50XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ+KPsyBXYWl0aW5nIGZvciB0cmFuc2FjdGlvbiBjb25maXJtYXRpb24uLi4nKTtcbiAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0eC53YWl0KCk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgUGF5bWVudCBjb25maXJtZWQ6Jywge1xuICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IHJlY2VpcHQuaGFzaCxcbiAgICAgICAgYmxvY2tOdW1iZXI6IHJlY2VpcHQuYmxvY2tOdW1iZXIsXG4gICAgICAgIGZyb206IHJlY2VpcHQuZnJvbSxcbiAgICAgICAgdG86IHJlY2VpcHQudG8sXG4gICAgICAgIGFtb3VudDogZXRoZXJzLmZvcm1hdEV0aGVyKHJlY2VpcHQudmFsdWUgfHwgcmVxdWlyZWRBbW91bnQpLFxuICAgICAgICBnYXNVc2VkOiByZWNlaXB0Lmdhc1VzZWQ/LnRvU3RyaW5nKClcbiAgICAgIH0pO1xuXG4gICAgICAvLyBWZXJpZnkgZmluYWwgYmFsYW5jZVxuICAgICAgY29uc3QgbmV3QmFsYW5jZSA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0QmFsYW5jZShzZW5kZXJBZGRyZXNzKTtcbiAgICAgIGNvbnNvbGUubG9nKCdOZXcgd2FsbGV0IGJhbGFuY2U6JywgZXRoZXJzLmZvcm1hdEV0aGVyKG5ld0JhbGFuY2UpLCAnRVRIJyk7XG5cbiAgICAgIC8vIEFkZCBFdGhlcnNjYW4gbGlua1xuICAgICAgY29uc29sZS5sb2coYPCflI0gVmlldyB0cmFuc2FjdGlvbjogaHR0cHM6Ly9zZXBvbGlhLmJhc2VzY2FuLm9yZy90eC8ke3JlY2VpcHQuaGFzaH1gKTtcblxuICAgICAgcmV0dXJuIHJlY2VpcHQuaGFzaDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGluIHBheW1lbnQgc2VydmljZTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBhc3luYyB2ZXJpZnlUcmFuc2FjdGlvbih0eEhhc2g6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVkO1xuICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZXIgbm90IGluaXRpYWxpemVkJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlY2VpcHQgPSBhd2FpdCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gpO1xuICAgICAgcmV0dXJuIHJlY2VpcHQgIT09IG51bGwgJiYgcmVjZWlwdC5zdGF0dXMgPT09IDE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHZlcmlmeWluZyB0cmFuc2FjdGlvbjonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59ICJdLCJuYW1lcyI6WyJldGhlcnMiLCJGYXVjZXRTZXJ2aWNlIiwiaW5pdGlhbGl6ZVdhbGxldCIsImNvbnNvbGUiLCJsb2ciLCJwcm92aWRlciIsIkpzb25ScGNQcm92aWRlciIsInJlYWR5IiwicHJpdmF0ZUtleSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19XQUxMRVRfUFJJVkFURV9LRVkiLCJFcnJvciIsIndhbGxldCIsIldhbGxldCIsImNvbm5lY3QiLCJhZGRyZXNzIiwiZ2V0QWRkcmVzcyIsImVycm9yIiwiZ2V0SW5zdGFuY2UiLCJpbnN0YW5jZSIsInJlcXVlc3RBbmRTZW5kRVRIIiwidG9BZGRyZXNzIiwiYW1vdW50IiwicmVjZWlwdCIsImluaXRpYWxpemVkIiwic2VuZGVyQWRkcmVzcyIsImZyb20iLCJ0byIsIm5ldHdvcmsiLCJjdXJyZW50QmFsYW5jZSIsImdldEJhbGFuY2UiLCJmb3JtYXRFdGhlciIsInJlcXVpcmVkQW1vdW50IiwicGFyc2VFdGhlciIsInRvU3RyaW5nIiwidHgiLCJzZW5kVHJhbnNhY3Rpb24iLCJ2YWx1ZSIsIndhaXQiLCJ0cmFuc2FjdGlvbkhhc2giLCJoYXNoIiwiYmxvY2tOdW1iZXIiLCJnYXNVc2VkIiwibmV3QmFsYW5jZSIsInZlcmlmeVRyYW5zYWN0aW9uIiwidHhIYXNoIiwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0Iiwic3RhdHVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/faucetService.ts\n"));

/***/ })

});