"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useChatbot.ts":
/*!*********************************!*\
  !*** ./src/hooks/useChatbot.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChatbot: function() { return /* binding */ useChatbot; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _services_chatbot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/services/chatbot */ \"(app-pages-browser)/./src/services/chatbot.ts\");\n/* harmony import */ var _lib_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/storage */ \"(app-pages-browser)/./src/lib/storage.ts\");\n/* harmony import */ var _services_taxiService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/taxiService */ \"(app-pages-browser)/./src/services/taxiService.ts\");\n/* __next_internal_client_entry_do_not_use__ useChatbot auto */ \n\n\n\nfunction useChatbot() {\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const handleScheduleConflict = (newEvent, existingEvents)=>{\n        console.log(\"Checking conflicts for new event:\", {\n            title: newEvent.title,\n            start: newEvent.startTime,\n            priority: newEvent.priority\n        });\n        console.log(\"Existing events:\", existingEvents);\n        // Sort existing events by priority\n        const priorityOrder = {\n            \"urgent-important\": 3,\n            \"important\": 2,\n            \"urgent\": 1,\n            \"neither\": 0\n        };\n        // Find conflicting events\n        const conflicts = existingEvents.filter((event)=>{\n            const newStart = new Date(newEvent.startTime);\n            const newEnd = new Date(newEvent.endTime);\n            const eventStart = new Date(event.startTime);\n            const eventEnd = new Date(event.endTime);\n            const hasConflict = newStart >= eventStart && newStart < eventEnd || newEnd > eventStart && newEnd <= eventEnd || newStart <= eventStart && newEnd >= eventEnd;\n            if (hasConflict) {\n                console.log(\"Found conflict:\", {\n                    existingEvent: event.title,\n                    existingPriority: event.priority,\n                    newEvent: newEvent.title,\n                    newPriority: newEvent.priority\n                });\n            }\n            return hasConflict;\n        });\n        if (conflicts.length === 0) {\n            console.log(\"No conflicts found\");\n            return newEvent;\n        }\n        // Check if new event has higher priority\n        const newPriorityScore = priorityOrder[newEvent.priority];\n        const highestConflictScore = Math.max(...conflicts.map((e)=>priorityOrder[e.priority]));\n        console.log(\"Priority comparison:\", {\n            newEventScore: newPriorityScore,\n            highestConflictScore,\n            willRescheduleConflicts: newPriorityScore > highestConflictScore\n        });\n        if (newPriorityScore > highestConflictScore) {\n            // Move conflicting events\n            console.log(\"Moving conflicting events...\");\n            const storage = _lib_storage__WEBPACK_IMPORTED_MODULE_2__.StorageService.getInstance();\n            conflicts.forEach((conflict)=>{\n                // Move to next available time\n                const duration = new Date(conflict.endTime).getTime() - new Date(conflict.startTime).getTime();\n                const newStartTime = new Date(newEvent.endTime);\n                const newEndTime = new Date(newStartTime.getTime() + duration);\n                const updatedEvent = {\n                    ...conflict,\n                    startTime: newStartTime.toISOString(),\n                    endTime: newEndTime.toISOString()\n                };\n                console.log(\"Moving event:\", {\n                    event: conflict.title,\n                    from: conflict.startTime,\n                    to: updatedEvent.startTime\n                });\n                storage.updateTimeBlock(updatedEvent);\n            });\n            return newEvent;\n        } else {\n            // Find next available time for new event\n            console.log(\"Finding next available time for new event...\");\n            const duration = new Date(newEvent.endTime).getTime() - new Date(newEvent.startTime).getTime();\n            const lastConflict = conflicts.sort((a, b)=>new Date(b.endTime).getTime() - new Date(a.endTime).getTime())[0];\n            const newStartTime = new Date(lastConflict.endTime);\n            const newEndTime = new Date(newStartTime.getTime() + duration);\n            const rescheduledEvent = {\n                ...newEvent,\n                startTime: newStartTime.toISOString(),\n                endTime: newEndTime.toISOString()\n            };\n            console.log(\"Rescheduled new event:\", {\n                from: newEvent.startTime,\n                to: rescheduledEvent.startTime\n            });\n            return rescheduledEvent;\n        }\n    };\n    const sendMessage = async (content)=>{\n        console.log(\"=== START sendMessage ===\");\n        setIsLoading(true);\n        try {\n            // Initialize agent\n            console.log(\"Initializing agent...\");\n            const { agent, prompt, functionHandlers } = await (0,_services_chatbot__WEBPACK_IMPORTED_MODULE_1__.initializeAgent)();\n            console.log(\"Agent initialized successfully\");\n            // Format the prompt\n            const formattedPrompt = await prompt.formatMessages({\n                input: content\n            });\n            // Call agent\n            console.log(\"Calling agent...\");\n            const response = await agent.invoke(formattedPrompt);\n            console.log(\"Agent response received:\", response);\n            // Extract content\n            let messageContent = response.content;\n            // Look for schedule task\n            const codeBlockMatch = messageContent.match(/```[\\s\\S]*?schedule_task\\(([\\s\\S]*?)\\)[\\s\\S]*?```/);\n            if (codeBlockMatch) {\n                const paramsText = codeBlockMatch[1];\n                const params = {\n                    title: (paramsText.match(/title=\"([^\"]+)\"/) || [])[1],\n                    startTime: (paramsText.match(/startTime=\"([^\"]+)\"/) || [])[1],\n                    endTime: (paramsText.match(/endTime=\"([^\"]+)\"/) || [])[1],\n                    priority: (paramsText.match(/priority=\"([^\"]+)\"/) || [])[1],\n                    location: (paramsText.match(/location=\"([^\"]+)\"/) || [])[1],\n                    needsTransport: paramsText.includes(\"needsTransport=True\"),\n                    delegatable: paramsText.includes(\"delegatable=True\")\n                };\n                if (params.title && params.startTime) {\n                    const storage = _lib_storage__WEBPACK_IMPORTED_MODULE_2__.StorageService.getInstance();\n                    const existingEvents = storage.getTimeBlocks();\n                    // Handle transportation if needed\n                    let transportDetails = null;\n                    if (params.needsTransport && params.location) {\n                        const taxiService = _services_taxiService__WEBPACK_IMPORTED_MODULE_3__.TaxiService.getInstance();\n                        const estimate = await taxiService.estimateTrip(\"current_location\", params.location);\n                        if (estimate.available) {\n                            // Add buffer time for transportation\n                            const eventStart = new Date(params.startTime);\n                            eventStart.setMinutes(eventStart.getMinutes() - estimate.duration);\n                            params.startTime = eventStart.toISOString();\n                            // Get payment details\n                            const paymentDetails = await taxiService.getPaymentDetails(\"current_location\", params.location);\n                            messageContent += \"\\n\\nTransportation arranged:\\n- Taxi booked for \".concat(estimate.duration, \" minutes before event\\n- Please send \").concat(estimate.cost, \" ETH to \").concat(paymentDetails.address, \" on \").concat(paymentDetails.network, \"\\n- After payment, the taxi will be confirmed\");\n                        }\n                    }\n                    const scheduledEvent = {\n                        _id: crypto.randomUUID(),\n                        title: params.title,\n                        startTime: new Date(params.startTime).toISOString(),\n                        endTime: params.endTime ? new Date(params.endTime).toISOString() : new Date(new Date(params.startTime).getTime() + 60 * 60 * 1000).toISOString(),\n                        priority: params.priority || \"important\",\n                        location: params.location,\n                        transportDetails,\n                        delegatable: params.delegatable || false,\n                        status: \"scheduled\",\n                        created_at: new Date().toISOString(),\n                        updated_at: new Date().toISOString()\n                    };\n                    const finalEvent = handleScheduleConflict(scheduledEvent, existingEvents);\n                    storage.addTimeBlock(finalEvent);\n                    const event = new CustomEvent(\"calendarUpdate\", {\n                        detail: finalEvent\n                    });\n                    window.dispatchEvent(event);\n                    // Extract taxi booking function call\n                    const taxiMatch = messageContent.match(/```[\\s\\S]*?book_taxi\\(([\\s\\S]*?)\\)[\\s\\S]*?```/);\n                    if (taxiMatch) {\n                        const taxiParams = {\n                            pickup: (taxiMatch[1].match(/pickup=\"([^\"]+)\"/) || [])[1],\n                            destination: (taxiMatch[1].match(/destination=\"([^\"]+)\"/) || [])[1],\n                            pickupTime: (taxiMatch[1].match(/pickupTime=\"([^\"]+)\"/) || [])[1]\n                        };\n                        // Execute taxi booking\n                        const paymentDetails = await functionHandlers.book_taxi(taxiParams);\n                        if (paymentDetails.txHash) {\n                            // Verify payment\n                            const verified = await functionHandlers.verify_payment({\n                                txHash: paymentDetails.txHash\n                            });\n                            messageContent += \"\\n\\nPayment status: \".concat(verified ? \"Successful\" : \"Failed\", \"\\nTransaction hash: \").concat(paymentDetails.txHash);\n                        }\n                    }\n                }\n            }\n            // Add message to chat history\n            setMessages((prev)=>[\n                    ...prev,\n                    {\n                        content: messageContent,\n                        role: \"assistant\",\n                        timestamp: new Date().toISOString()\n                    }\n                ]);\n        } catch (error) {\n            console.error(\"Error in sendMessage:\", error);\n            setMessages((prev)=>[\n                    ...prev,\n                    {\n                        content: \"Error: \".concat(error.message),\n                        role: \"system\",\n                        timestamp: new Date().toISOString()\n                    }\n                ]);\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    return {\n        messages,\n        isLoading,\n        sendMessage\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VDaGF0Ym90LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztnRUFFaUM7QUFDb0I7QUFDTjtBQUNNO0FBRTlDLFNBQVNJO0lBQ2QsTUFBTSxDQUFDQyxVQUFVQyxZQUFZLEdBQUdOLCtDQUFRQSxDQUFRLEVBQUU7SUFDbEQsTUFBTSxDQUFDTyxXQUFXQyxhQUFhLEdBQUdSLCtDQUFRQSxDQUFDO0lBRTNDLE1BQU1TLHlCQUF5QixDQUFDQyxVQUFxQkM7UUFDbkRDLFFBQVFDLEdBQUcsQ0FBQyxxQ0FBcUM7WUFDL0NDLE9BQU9KLFNBQVNJLEtBQUs7WUFDckJDLE9BQU9MLFNBQVNNLFNBQVM7WUFDekJDLFVBQVVQLFNBQVNPLFFBQVE7UUFDN0I7UUFDQUwsUUFBUUMsR0FBRyxDQUFDLG9CQUFvQkY7UUFFaEMsbUNBQW1DO1FBQ25DLE1BQU1PLGdCQUFnQjtZQUNwQixvQkFBb0I7WUFDcEIsYUFBYTtZQUNiLFVBQVU7WUFDVixXQUFXO1FBQ2I7UUFFQSwwQkFBMEI7UUFDMUIsTUFBTUMsWUFBWVIsZUFBZVMsTUFBTSxDQUFDQyxDQUFBQTtZQUN0QyxNQUFNQyxXQUFXLElBQUlDLEtBQUtiLFNBQVNNLFNBQVM7WUFDNUMsTUFBTVEsU0FBUyxJQUFJRCxLQUFLYixTQUFTZSxPQUFPO1lBQ3hDLE1BQU1DLGFBQWEsSUFBSUgsS0FBS0YsTUFBTUwsU0FBUztZQUMzQyxNQUFNVyxXQUFXLElBQUlKLEtBQUtGLE1BQU1JLE9BQU87WUFFdkMsTUFBTUcsY0FDSixZQUFhRixjQUFjSixXQUFXSyxZQUNyQ0gsU0FBU0UsY0FBY0YsVUFBVUcsWUFDakNMLFlBQVlJLGNBQWNGLFVBQVVHO1lBR3ZDLElBQUlDLGFBQWE7Z0JBQ2ZoQixRQUFRQyxHQUFHLENBQUMsbUJBQW1CO29CQUM3QmdCLGVBQWVSLE1BQU1QLEtBQUs7b0JBQzFCZ0Isa0JBQWtCVCxNQUFNSixRQUFRO29CQUNoQ1AsVUFBVUEsU0FBU0ksS0FBSztvQkFDeEJpQixhQUFhckIsU0FBU08sUUFBUTtnQkFDaEM7WUFDRjtZQUVBLE9BQU9XO1FBQ1Q7UUFFQSxJQUFJVCxVQUFVYSxNQUFNLEtBQUssR0FBRztZQUMxQnBCLFFBQVFDLEdBQUcsQ0FBQztZQUNaLE9BQU9IO1FBQ1Q7UUFFQSx5Q0FBeUM7UUFDekMsTUFBTXVCLG1CQUFtQmYsYUFBYSxDQUFDUixTQUFTTyxRQUFRLENBQUM7UUFDekQsTUFBTWlCLHVCQUF1QkMsS0FBS0MsR0FBRyxJQUNoQ2pCLFVBQVVrQixHQUFHLENBQUNDLENBQUFBLElBQUtwQixhQUFhLENBQUNvQixFQUFFckIsUUFBUSxDQUFDO1FBR2pETCxRQUFRQyxHQUFHLENBQUMsd0JBQXdCO1lBQ2xDMEIsZUFBZU47WUFDZkM7WUFDQU0seUJBQXlCUCxtQkFBbUJDO1FBQzlDO1FBRUEsSUFBSUQsbUJBQW1CQyxzQkFBc0I7WUFDM0MsMEJBQTBCO1lBQzFCdEIsUUFBUUMsR0FBRyxDQUFDO1lBQ1osTUFBTTRCLFVBQVV2Qyx3REFBY0EsQ0FBQ3dDLFdBQVc7WUFDMUN2QixVQUFVd0IsT0FBTyxDQUFDQyxDQUFBQTtnQkFDaEIsOEJBQThCO2dCQUM5QixNQUFNQyxXQUFXLElBQUl0QixLQUFLcUIsU0FBU25CLE9BQU8sRUFBRXFCLE9BQU8sS0FBSyxJQUFJdkIsS0FBS3FCLFNBQVM1QixTQUFTLEVBQUU4QixPQUFPO2dCQUM1RixNQUFNQyxlQUFlLElBQUl4QixLQUFLYixTQUFTZSxPQUFPO2dCQUM5QyxNQUFNdUIsYUFBYSxJQUFJekIsS0FBS3dCLGFBQWFELE9BQU8sS0FBS0Q7Z0JBRXJELE1BQU1JLGVBQWU7b0JBQ25CLEdBQUdMLFFBQVE7b0JBQ1g1QixXQUFXK0IsYUFBYUcsV0FBVztvQkFDbkN6QixTQUFTdUIsV0FBV0UsV0FBVztnQkFDakM7Z0JBRUF0QyxRQUFRQyxHQUFHLENBQUMsaUJBQWlCO29CQUMzQlEsT0FBT3VCLFNBQVM5QixLQUFLO29CQUNyQnFDLE1BQU1QLFNBQVM1QixTQUFTO29CQUN4Qm9DLElBQUlILGFBQWFqQyxTQUFTO2dCQUM1QjtnQkFFQXlCLFFBQVFZLGVBQWUsQ0FBQ0o7WUFDMUI7WUFDQSxPQUFPdkM7UUFDVCxPQUFPO1lBQ0wseUNBQXlDO1lBQ3pDRSxRQUFRQyxHQUFHLENBQUM7WUFDWixNQUFNZ0MsV0FBVyxJQUFJdEIsS0FBS2IsU0FBU2UsT0FBTyxFQUFFcUIsT0FBTyxLQUFLLElBQUl2QixLQUFLYixTQUFTTSxTQUFTLEVBQUU4QixPQUFPO1lBQzVGLE1BQU1RLGVBQWVuQyxVQUFVb0MsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQ3RDLElBQUlsQyxLQUFLa0MsRUFBRWhDLE9BQU8sRUFBRXFCLE9BQU8sS0FBSyxJQUFJdkIsS0FBS2lDLEVBQUUvQixPQUFPLEVBQUVxQixPQUFPLEdBQzVELENBQUMsRUFBRTtZQUVKLE1BQU1DLGVBQWUsSUFBSXhCLEtBQUsrQixhQUFhN0IsT0FBTztZQUNsRCxNQUFNdUIsYUFBYSxJQUFJekIsS0FBS3dCLGFBQWFELE9BQU8sS0FBS0Q7WUFFckQsTUFBTWEsbUJBQW1CO2dCQUN2QixHQUFHaEQsUUFBUTtnQkFDWE0sV0FBVytCLGFBQWFHLFdBQVc7Z0JBQ25DekIsU0FBU3VCLFdBQVdFLFdBQVc7WUFDakM7WUFFQXRDLFFBQVFDLEdBQUcsQ0FBQywwQkFBMEI7Z0JBQ3BDc0MsTUFBTXpDLFNBQVNNLFNBQVM7Z0JBQ3hCb0MsSUFBSU0saUJBQWlCMUMsU0FBUztZQUNoQztZQUVBLE9BQU8wQztRQUNUO0lBQ0Y7SUFFQSxNQUFNQyxjQUFjLE9BQU9DO1FBQ3pCaEQsUUFBUUMsR0FBRyxDQUFDO1FBQ1pMLGFBQWE7UUFFYixJQUFJO1lBQ0YsbUJBQW1CO1lBQ25CSSxRQUFRQyxHQUFHLENBQUM7WUFDWixNQUFNLEVBQUVnRCxLQUFLLEVBQUVDLE1BQU0sRUFBRUMsZ0JBQWdCLEVBQUUsR0FBRyxNQUFNOUQsa0VBQWVBO1lBQ2pFVyxRQUFRQyxHQUFHLENBQUM7WUFFWixvQkFBb0I7WUFDcEIsTUFBTW1ELGtCQUFrQixNQUFNRixPQUFPRyxjQUFjLENBQUM7Z0JBQ2xEQyxPQUFPTjtZQUNUO1lBRUEsYUFBYTtZQUNiaEQsUUFBUUMsR0FBRyxDQUFDO1lBQ1osTUFBTXNELFdBQVcsTUFBTU4sTUFBTU8sTUFBTSxDQUFDSjtZQUNwQ3BELFFBQVFDLEdBQUcsQ0FBQyw0QkFBNEJzRDtZQUV4QyxrQkFBa0I7WUFDbEIsSUFBSUUsaUJBQWlCRixTQUFTUCxPQUFPO1lBRXJDLHlCQUF5QjtZQUN6QixNQUFNVSxpQkFBaUJELGVBQWVFLEtBQUssQ0FBQztZQUM1QyxJQUFJRCxnQkFBZ0I7Z0JBQ2xCLE1BQU1FLGFBQWFGLGNBQWMsQ0FBQyxFQUFFO2dCQUNwQyxNQUFNRyxTQUFTO29CQUNiM0QsT0FBTyxDQUFDMEQsV0FBV0QsS0FBSyxDQUFDLHNCQUFzQixFQUFFLENBQUMsQ0FBQyxFQUFFO29CQUNyRHZELFdBQVcsQ0FBQ3dELFdBQVdELEtBQUssQ0FBQywwQkFBMEIsRUFBRSxDQUFDLENBQUMsRUFBRTtvQkFDN0Q5QyxTQUFTLENBQUMrQyxXQUFXRCxLQUFLLENBQUMsd0JBQXdCLEVBQUUsQ0FBQyxDQUFDLEVBQUU7b0JBQ3pEdEQsVUFBVSxDQUFDdUQsV0FBV0QsS0FBSyxDQUFDLHlCQUF5QixFQUFFLENBQUMsQ0FBQyxFQUFFO29CQUMzREcsVUFBVSxDQUFDRixXQUFXRCxLQUFLLENBQUMseUJBQXlCLEVBQUUsQ0FBQyxDQUFDLEVBQUU7b0JBQzNESSxnQkFBZ0JILFdBQVdJLFFBQVEsQ0FBQztvQkFDcENDLGFBQWFMLFdBQVdJLFFBQVEsQ0FBQztnQkFDbkM7Z0JBRUEsSUFBSUgsT0FBTzNELEtBQUssSUFBSTJELE9BQU96RCxTQUFTLEVBQUU7b0JBQ3BDLE1BQU15QixVQUFVdkMsd0RBQWNBLENBQUN3QyxXQUFXO29CQUMxQyxNQUFNL0IsaUJBQWlCOEIsUUFBUXFDLGFBQWE7b0JBRTVDLGtDQUFrQztvQkFDbEMsSUFBSUMsbUJBQW1CO29CQUN2QixJQUFJTixPQUFPRSxjQUFjLElBQUlGLE9BQU9DLFFBQVEsRUFBRTt3QkFDNUMsTUFBTU0sY0FBYzdFLDhEQUFXQSxDQUFDdUMsV0FBVzt3QkFDM0MsTUFBTXVDLFdBQVcsTUFBTUQsWUFBWUUsWUFBWSxDQUFDLG9CQUFvQlQsT0FBT0MsUUFBUTt3QkFFbkYsSUFBSU8sU0FBU0UsU0FBUyxFQUFFOzRCQUN0QixxQ0FBcUM7NEJBQ3JDLE1BQU16RCxhQUFhLElBQUlILEtBQUtrRCxPQUFPekQsU0FBUzs0QkFDNUNVLFdBQVcwRCxVQUFVLENBQUMxRCxXQUFXMkQsVUFBVSxLQUFLSixTQUFTcEMsUUFBUTs0QkFDakU0QixPQUFPekQsU0FBUyxHQUFHVSxXQUFXd0IsV0FBVzs0QkFFekMsc0JBQXNCOzRCQUN0QixNQUFNb0MsaUJBQWlCLE1BQU1OLFlBQVlPLGlCQUFpQixDQUFDLG9CQUFvQmQsT0FBT0MsUUFBUTs0QkFDOUZMLGtCQUFrQixtREFFaEJZLE9BRElBLFNBQVNwQyxRQUFRLEVBQUMseUNBQ0V5QyxPQUF4QkwsU0FBU08sSUFBSSxFQUFDLFlBQXVDRixPQUE3QkEsZUFBZUcsT0FBTyxFQUFDLFFBQTZCLE9BQXZCSCxlQUFlSSxPQUFPLEVBQUM7d0JBRWhGO29CQUNGO29CQUVBLE1BQU1DLGlCQUFpQjt3QkFDckJDLEtBQUtDLE9BQU9DLFVBQVU7d0JBQ3RCaEYsT0FBTzJELE9BQU8zRCxLQUFLO3dCQUNuQkUsV0FBVyxJQUFJTyxLQUFLa0QsT0FBT3pELFNBQVMsRUFBRWtDLFdBQVc7d0JBQ2pEekIsU0FBU2dELE9BQU9oRCxPQUFPLEdBQUcsSUFBSUYsS0FBS2tELE9BQU9oRCxPQUFPLEVBQUV5QixXQUFXLEtBQzVELElBQUkzQixLQUFLLElBQUlBLEtBQUtrRCxPQUFPekQsU0FBUyxFQUFFOEIsT0FBTyxLQUFLLEtBQUssS0FBSyxNQUFNSSxXQUFXO3dCQUM3RWpDLFVBQVV3RCxPQUFPeEQsUUFBUSxJQUFJO3dCQUM3QnlELFVBQVVELE9BQU9DLFFBQVE7d0JBQ3pCSzt3QkFDQUYsYUFBYUosT0FBT0ksV0FBVyxJQUFJO3dCQUNuQ2tCLFFBQVE7d0JBQ1JDLFlBQVksSUFBSXpFLE9BQU8yQixXQUFXO3dCQUNsQytDLFlBQVksSUFBSTFFLE9BQU8yQixXQUFXO29CQUNwQztvQkFFQSxNQUFNZ0QsYUFBYXpGLHVCQUF1QmtGLGdCQUFnQmhGO29CQUMxRDhCLFFBQVEwRCxZQUFZLENBQUNEO29CQUVyQixNQUFNN0UsUUFBUSxJQUFJK0UsWUFBWSxrQkFBa0I7d0JBQzlDQyxRQUFRSDtvQkFDVjtvQkFDQUksT0FBT0MsYUFBYSxDQUFDbEY7b0JBRXJCLHFDQUFxQztvQkFDckMsTUFBTW1GLFlBQVluQyxlQUFlRSxLQUFLLENBQUM7b0JBQ3ZDLElBQUlpQyxXQUFXO3dCQUNiLE1BQU1DLGFBQWE7NEJBQ2pCQyxRQUFRLENBQUNGLFNBQVMsQ0FBQyxFQUFFLENBQUNqQyxLQUFLLENBQUMsdUJBQXVCLEVBQUUsQ0FBQyxDQUFDLEVBQUU7NEJBQ3pEb0MsYUFBYSxDQUFDSCxTQUFTLENBQUMsRUFBRSxDQUFDakMsS0FBSyxDQUFDLDRCQUE0QixFQUFFLENBQUMsQ0FBQyxFQUFFOzRCQUNuRXFDLFlBQVksQ0FBQ0osU0FBUyxDQUFDLEVBQUUsQ0FBQ2pDLEtBQUssQ0FBQywyQkFBMkIsRUFBRSxDQUFDLENBQUMsRUFBRTt3QkFDbkU7d0JBRUEsdUJBQXVCO3dCQUN2QixNQUFNZSxpQkFBaUIsTUFBTXZCLGlCQUFpQjhDLFNBQVMsQ0FBQ0o7d0JBRXhELElBQUluQixlQUFld0IsTUFBTSxFQUFFOzRCQUN6QixpQkFBaUI7NEJBQ2pCLE1BQU1DLFdBQVcsTUFBTWhELGlCQUFpQmlELGNBQWMsQ0FBQztnQ0FDckRGLFFBQVF4QixlQUFld0IsTUFBTTs0QkFDL0I7NEJBRUF6QyxrQkFBa0IsdUJBQ1ppQixPQURtQ3lCLFdBQVcsZUFBZSxVQUFTLHdCQUNoRCxPQUF0QnpCLGVBQWV3QixNQUFNO3dCQUM3QjtvQkFDRjtnQkFDRjtZQUNGO1lBRUEsOEJBQThCO1lBQzlCeEcsWUFBWTJHLENBQUFBLE9BQVE7dUJBQUlBO29CQUFNO3dCQUM1QnJELFNBQVNTO3dCQUNUNkMsTUFBTTt3QkFDTkMsV0FBVyxJQUFJNUYsT0FBTzJCLFdBQVc7b0JBQ25DO2lCQUFFO1FBRUosRUFBRSxPQUFPa0UsT0FBTztZQUNkeEcsUUFBUXdHLEtBQUssQ0FBQyx5QkFBeUJBO1lBQ3ZDOUcsWUFBWTJHLENBQUFBLE9BQVE7dUJBQUlBO29CQUFNO3dCQUM1QnJELFNBQVMsVUFBd0IsT0FBZHdELE1BQU1DLE9BQU87d0JBQ2hDSCxNQUFNO3dCQUNOQyxXQUFXLElBQUk1RixPQUFPMkIsV0FBVztvQkFDbkM7aUJBQUU7UUFDSixTQUFVO1lBQ1IxQyxhQUFhO1FBQ2Y7SUFDRjtJQUVBLE9BQU87UUFDTEg7UUFDQUU7UUFDQW9EO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaG9va3MvdXNlQ2hhdGJvdC50cz9kNDZmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpbml0aWFsaXplQWdlbnQgfSBmcm9tICdAL3NlcnZpY2VzL2NoYXRib3QnO1xuaW1wb3J0IHsgU3RvcmFnZVNlcnZpY2UgfSBmcm9tICdAL2xpYi9zdG9yYWdlJztcbmltcG9ydCB7IFRheGlTZXJ2aWNlIH0gZnJvbSAnQC9zZXJ2aWNlcy90YXhpU2VydmljZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGF0Ym90KCkge1xuICBjb25zdCBbbWVzc2FnZXMsIHNldE1lc3NhZ2VzXSA9IHVzZVN0YXRlPGFueVtdPihbXSk7XG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgY29uc3QgaGFuZGxlU2NoZWR1bGVDb25mbGljdCA9IChuZXdFdmVudDogVGltZUJsb2NrLCBleGlzdGluZ0V2ZW50czogVGltZUJsb2NrW10pID0+IHtcbiAgICBjb25zb2xlLmxvZygnQ2hlY2tpbmcgY29uZmxpY3RzIGZvciBuZXcgZXZlbnQ6Jywge1xuICAgICAgdGl0bGU6IG5ld0V2ZW50LnRpdGxlLFxuICAgICAgc3RhcnQ6IG5ld0V2ZW50LnN0YXJ0VGltZSxcbiAgICAgIHByaW9yaXR5OiBuZXdFdmVudC5wcmlvcml0eVxuICAgIH0pO1xuICAgIGNvbnNvbGUubG9nKCdFeGlzdGluZyBldmVudHM6JywgZXhpc3RpbmdFdmVudHMpO1xuXG4gICAgLy8gU29ydCBleGlzdGluZyBldmVudHMgYnkgcHJpb3JpdHlcbiAgICBjb25zdCBwcmlvcml0eU9yZGVyID0ge1xuICAgICAgJ3VyZ2VudC1pbXBvcnRhbnQnOiAzLFxuICAgICAgJ2ltcG9ydGFudCc6IDIsXG4gICAgICAndXJnZW50JzogMSxcbiAgICAgICduZWl0aGVyJzogMFxuICAgIH07XG5cbiAgICAvLyBGaW5kIGNvbmZsaWN0aW5nIGV2ZW50c1xuICAgIGNvbnN0IGNvbmZsaWN0cyA9IGV4aXN0aW5nRXZlbnRzLmZpbHRlcihldmVudCA9PiB7XG4gICAgICBjb25zdCBuZXdTdGFydCA9IG5ldyBEYXRlKG5ld0V2ZW50LnN0YXJ0VGltZSk7XG4gICAgICBjb25zdCBuZXdFbmQgPSBuZXcgRGF0ZShuZXdFdmVudC5lbmRUaW1lKTtcbiAgICAgIGNvbnN0IGV2ZW50U3RhcnQgPSBuZXcgRGF0ZShldmVudC5zdGFydFRpbWUpO1xuICAgICAgY29uc3QgZXZlbnRFbmQgPSBuZXcgRGF0ZShldmVudC5lbmRUaW1lKTtcbiAgICAgIFxuICAgICAgY29uc3QgaGFzQ29uZmxpY3QgPSAoXG4gICAgICAgIChuZXdTdGFydCA+PSBldmVudFN0YXJ0ICYmIG5ld1N0YXJ0IDwgZXZlbnRFbmQpIHx8XG4gICAgICAgIChuZXdFbmQgPiBldmVudFN0YXJ0ICYmIG5ld0VuZCA8PSBldmVudEVuZCkgfHxcbiAgICAgICAgKG5ld1N0YXJ0IDw9IGV2ZW50U3RhcnQgJiYgbmV3RW5kID49IGV2ZW50RW5kKVxuICAgICAgKTtcblxuICAgICAgaWYgKGhhc0NvbmZsaWN0KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBjb25mbGljdDonLCB7XG4gICAgICAgICAgZXhpc3RpbmdFdmVudDogZXZlbnQudGl0bGUsXG4gICAgICAgICAgZXhpc3RpbmdQcmlvcml0eTogZXZlbnQucHJpb3JpdHksXG4gICAgICAgICAgbmV3RXZlbnQ6IG5ld0V2ZW50LnRpdGxlLFxuICAgICAgICAgIG5ld1ByaW9yaXR5OiBuZXdFdmVudC5wcmlvcml0eVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGhhc0NvbmZsaWN0O1xuICAgIH0pO1xuXG4gICAgaWYgKGNvbmZsaWN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCdObyBjb25mbGljdHMgZm91bmQnKTtcbiAgICAgIHJldHVybiBuZXdFdmVudDtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBuZXcgZXZlbnQgaGFzIGhpZ2hlciBwcmlvcml0eVxuICAgIGNvbnN0IG5ld1ByaW9yaXR5U2NvcmUgPSBwcmlvcml0eU9yZGVyW25ld0V2ZW50LnByaW9yaXR5XTtcbiAgICBjb25zdCBoaWdoZXN0Q29uZmxpY3RTY29yZSA9IE1hdGgubWF4KFxuICAgICAgLi4uY29uZmxpY3RzLm1hcChlID0+IHByaW9yaXR5T3JkZXJbZS5wcmlvcml0eV0pXG4gICAgKTtcblxuICAgIGNvbnNvbGUubG9nKCdQcmlvcml0eSBjb21wYXJpc29uOicsIHtcbiAgICAgIG5ld0V2ZW50U2NvcmU6IG5ld1ByaW9yaXR5U2NvcmUsXG4gICAgICBoaWdoZXN0Q29uZmxpY3RTY29yZSxcbiAgICAgIHdpbGxSZXNjaGVkdWxlQ29uZmxpY3RzOiBuZXdQcmlvcml0eVNjb3JlID4gaGlnaGVzdENvbmZsaWN0U2NvcmVcbiAgICB9KTtcblxuICAgIGlmIChuZXdQcmlvcml0eVNjb3JlID4gaGlnaGVzdENvbmZsaWN0U2NvcmUpIHtcbiAgICAgIC8vIE1vdmUgY29uZmxpY3RpbmcgZXZlbnRzXG4gICAgICBjb25zb2xlLmxvZygnTW92aW5nIGNvbmZsaWN0aW5nIGV2ZW50cy4uLicpO1xuICAgICAgY29uc3Qgc3RvcmFnZSA9IFN0b3JhZ2VTZXJ2aWNlLmdldEluc3RhbmNlKCk7XG4gICAgICBjb25mbGljdHMuZm9yRWFjaChjb25mbGljdCA9PiB7XG4gICAgICAgIC8vIE1vdmUgdG8gbmV4dCBhdmFpbGFibGUgdGltZVxuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IG5ldyBEYXRlKGNvbmZsaWN0LmVuZFRpbWUpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGNvbmZsaWN0LnN0YXJ0VGltZSkuZ2V0VGltZSgpO1xuICAgICAgICBjb25zdCBuZXdTdGFydFRpbWUgPSBuZXcgRGF0ZShuZXdFdmVudC5lbmRUaW1lKTtcbiAgICAgICAgY29uc3QgbmV3RW5kVGltZSA9IG5ldyBEYXRlKG5ld1N0YXJ0VGltZS5nZXRUaW1lKCkgKyBkdXJhdGlvbik7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB1cGRhdGVkRXZlbnQgPSB7XG4gICAgICAgICAgLi4uY29uZmxpY3QsXG4gICAgICAgICAgc3RhcnRUaW1lOiBuZXdTdGFydFRpbWUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBlbmRUaW1lOiBuZXdFbmRUaW1lLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKCdNb3ZpbmcgZXZlbnQ6Jywge1xuICAgICAgICAgIGV2ZW50OiBjb25mbGljdC50aXRsZSxcbiAgICAgICAgICBmcm9tOiBjb25mbGljdC5zdGFydFRpbWUsXG4gICAgICAgICAgdG86IHVwZGF0ZWRFdmVudC5zdGFydFRpbWVcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBzdG9yYWdlLnVwZGF0ZVRpbWVCbG9jayh1cGRhdGVkRXZlbnQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3RXZlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpbmQgbmV4dCBhdmFpbGFibGUgdGltZSBmb3IgbmV3IGV2ZW50XG4gICAgICBjb25zb2xlLmxvZygnRmluZGluZyBuZXh0IGF2YWlsYWJsZSB0aW1lIGZvciBuZXcgZXZlbnQuLi4nKTtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gbmV3IERhdGUobmV3RXZlbnQuZW5kVGltZSkuZ2V0VGltZSgpIC0gbmV3IERhdGUobmV3RXZlbnQuc3RhcnRUaW1lKS5nZXRUaW1lKCk7XG4gICAgICBjb25zdCBsYXN0Q29uZmxpY3QgPSBjb25mbGljdHMuc29ydCgoYSwgYikgPT4gXG4gICAgICAgIG5ldyBEYXRlKGIuZW5kVGltZSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYS5lbmRUaW1lKS5nZXRUaW1lKClcbiAgICAgIClbMF07XG4gICAgICBcbiAgICAgIGNvbnN0IG5ld1N0YXJ0VGltZSA9IG5ldyBEYXRlKGxhc3RDb25mbGljdC5lbmRUaW1lKTtcbiAgICAgIGNvbnN0IG5ld0VuZFRpbWUgPSBuZXcgRGF0ZShuZXdTdGFydFRpbWUuZ2V0VGltZSgpICsgZHVyYXRpb24pO1xuICAgICAgXG4gICAgICBjb25zdCByZXNjaGVkdWxlZEV2ZW50ID0ge1xuICAgICAgICAuLi5uZXdFdmVudCxcbiAgICAgICAgc3RhcnRUaW1lOiBuZXdTdGFydFRpbWUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgZW5kVGltZTogbmV3RW5kVGltZS50b0lTT1N0cmluZygpXG4gICAgICB9O1xuXG4gICAgICBjb25zb2xlLmxvZygnUmVzY2hlZHVsZWQgbmV3IGV2ZW50OicsIHtcbiAgICAgICAgZnJvbTogbmV3RXZlbnQuc3RhcnRUaW1lLFxuICAgICAgICB0bzogcmVzY2hlZHVsZWRFdmVudC5zdGFydFRpbWVcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4gcmVzY2hlZHVsZWRFdmVudDtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgc2VuZE1lc3NhZ2UgPSBhc3luYyAoY29udGVudDogc3RyaW5nKSA9PiB7XG4gICAgY29uc29sZS5sb2coJz09PSBTVEFSVCBzZW5kTWVzc2FnZSA9PT0nKTtcbiAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gSW5pdGlhbGl6ZSBhZ2VudFxuICAgICAgY29uc29sZS5sb2coJ0luaXRpYWxpemluZyBhZ2VudC4uLicpO1xuICAgICAgY29uc3QgeyBhZ2VudCwgcHJvbXB0LCBmdW5jdGlvbkhhbmRsZXJzIH0gPSBhd2FpdCBpbml0aWFsaXplQWdlbnQoKTtcbiAgICAgIGNvbnNvbGUubG9nKCdBZ2VudCBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHknKTtcblxuICAgICAgLy8gRm9ybWF0IHRoZSBwcm9tcHRcbiAgICAgIGNvbnN0IGZvcm1hdHRlZFByb21wdCA9IGF3YWl0IHByb21wdC5mb3JtYXRNZXNzYWdlcyh7XG4gICAgICAgIGlucHV0OiBjb250ZW50XG4gICAgICB9KTtcblxuICAgICAgLy8gQ2FsbCBhZ2VudFxuICAgICAgY29uc29sZS5sb2coJ0NhbGxpbmcgYWdlbnQuLi4nKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWdlbnQuaW52b2tlKGZvcm1hdHRlZFByb21wdCk7XG4gICAgICBjb25zb2xlLmxvZygnQWdlbnQgcmVzcG9uc2UgcmVjZWl2ZWQ6JywgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBFeHRyYWN0IGNvbnRlbnRcbiAgICAgIGxldCBtZXNzYWdlQ29udGVudCA9IHJlc3BvbnNlLmNvbnRlbnQ7XG5cbiAgICAgIC8vIExvb2sgZm9yIHNjaGVkdWxlIHRhc2tcbiAgICAgIGNvbnN0IGNvZGVCbG9ja01hdGNoID0gbWVzc2FnZUNvbnRlbnQubWF0Y2goL2BgYFtcXHNcXFNdKj9zY2hlZHVsZV90YXNrXFwoKFtcXHNcXFNdKj8pXFwpW1xcc1xcU10qP2BgYC8pO1xuICAgICAgaWYgKGNvZGVCbG9ja01hdGNoKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtc1RleHQgPSBjb2RlQmxvY2tNYXRjaFsxXTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgIHRpdGxlOiAocGFyYW1zVGV4dC5tYXRjaCgvdGl0bGU9XCIoW15cIl0rKVwiLykgfHwgW10pWzFdLFxuICAgICAgICAgIHN0YXJ0VGltZTogKHBhcmFtc1RleHQubWF0Y2goL3N0YXJ0VGltZT1cIihbXlwiXSspXCIvKSB8fCBbXSlbMV0sXG4gICAgICAgICAgZW5kVGltZTogKHBhcmFtc1RleHQubWF0Y2goL2VuZFRpbWU9XCIoW15cIl0rKVwiLykgfHwgW10pWzFdLFxuICAgICAgICAgIHByaW9yaXR5OiAocGFyYW1zVGV4dC5tYXRjaCgvcHJpb3JpdHk9XCIoW15cIl0rKVwiLykgfHwgW10pWzFdLFxuICAgICAgICAgIGxvY2F0aW9uOiAocGFyYW1zVGV4dC5tYXRjaCgvbG9jYXRpb249XCIoW15cIl0rKVwiLykgfHwgW10pWzFdLFxuICAgICAgICAgIG5lZWRzVHJhbnNwb3J0OiBwYXJhbXNUZXh0LmluY2x1ZGVzKCduZWVkc1RyYW5zcG9ydD1UcnVlJyksXG4gICAgICAgICAgZGVsZWdhdGFibGU6IHBhcmFtc1RleHQuaW5jbHVkZXMoJ2RlbGVnYXRhYmxlPVRydWUnKVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChwYXJhbXMudGl0bGUgJiYgcGFyYW1zLnN0YXJ0VGltZSkge1xuICAgICAgICAgIGNvbnN0IHN0b3JhZ2UgPSBTdG9yYWdlU2VydmljZS5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nRXZlbnRzID0gc3RvcmFnZS5nZXRUaW1lQmxvY2tzKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSGFuZGxlIHRyYW5zcG9ydGF0aW9uIGlmIG5lZWRlZFxuICAgICAgICAgIGxldCB0cmFuc3BvcnREZXRhaWxzID0gbnVsbDtcbiAgICAgICAgICBpZiAocGFyYW1zLm5lZWRzVHJhbnNwb3J0ICYmIHBhcmFtcy5sb2NhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgdGF4aVNlcnZpY2UgPSBUYXhpU2VydmljZS5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgY29uc3QgZXN0aW1hdGUgPSBhd2FpdCB0YXhpU2VydmljZS5lc3RpbWF0ZVRyaXAoJ2N1cnJlbnRfbG9jYXRpb24nLCBwYXJhbXMubG9jYXRpb24pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZXN0aW1hdGUuYXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgIC8vIEFkZCBidWZmZXIgdGltZSBmb3IgdHJhbnNwb3J0YXRpb25cbiAgICAgICAgICAgICAgY29uc3QgZXZlbnRTdGFydCA9IG5ldyBEYXRlKHBhcmFtcy5zdGFydFRpbWUpO1xuICAgICAgICAgICAgICBldmVudFN0YXJ0LnNldE1pbnV0ZXMoZXZlbnRTdGFydC5nZXRNaW51dGVzKCkgLSBlc3RpbWF0ZS5kdXJhdGlvbik7XG4gICAgICAgICAgICAgIHBhcmFtcy5zdGFydFRpbWUgPSBldmVudFN0YXJ0LnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBHZXQgcGF5bWVudCBkZXRhaWxzXG4gICAgICAgICAgICAgIGNvbnN0IHBheW1lbnREZXRhaWxzID0gYXdhaXQgdGF4aVNlcnZpY2UuZ2V0UGF5bWVudERldGFpbHMoJ2N1cnJlbnRfbG9jYXRpb24nLCBwYXJhbXMubG9jYXRpb24pO1xuICAgICAgICAgICAgICBtZXNzYWdlQ29udGVudCArPSBgXFxuXFxuVHJhbnNwb3J0YXRpb24gYXJyYW5nZWQ6XG4tIFRheGkgYm9va2VkIGZvciAke2VzdGltYXRlLmR1cmF0aW9ufSBtaW51dGVzIGJlZm9yZSBldmVudFxuLSBQbGVhc2Ugc2VuZCAke2VzdGltYXRlLmNvc3R9IEVUSCB0byAke3BheW1lbnREZXRhaWxzLmFkZHJlc3N9IG9uICR7cGF5bWVudERldGFpbHMubmV0d29ya31cbi0gQWZ0ZXIgcGF5bWVudCwgdGhlIHRheGkgd2lsbCBiZSBjb25maXJtZWRgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHNjaGVkdWxlZEV2ZW50ID0ge1xuICAgICAgICAgICAgX2lkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxuICAgICAgICAgICAgdGl0bGU6IHBhcmFtcy50aXRsZSxcbiAgICAgICAgICAgIHN0YXJ0VGltZTogbmV3IERhdGUocGFyYW1zLnN0YXJ0VGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGVuZFRpbWU6IHBhcmFtcy5lbmRUaW1lID8gbmV3IERhdGUocGFyYW1zLmVuZFRpbWUpLnRvSVNPU3RyaW5nKCkgOiBcbiAgICAgICAgICAgICAgbmV3IERhdGUobmV3IERhdGUocGFyYW1zLnN0YXJ0VGltZSkuZ2V0VGltZSgpICsgNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBwcmlvcml0eTogcGFyYW1zLnByaW9yaXR5IHx8IFwiaW1wb3J0YW50XCIsXG4gICAgICAgICAgICBsb2NhdGlvbjogcGFyYW1zLmxvY2F0aW9uLFxuICAgICAgICAgICAgdHJhbnNwb3J0RGV0YWlscyxcbiAgICAgICAgICAgIGRlbGVnYXRhYmxlOiBwYXJhbXMuZGVsZWdhdGFibGUgfHwgZmFsc2UsXG4gICAgICAgICAgICBzdGF0dXM6ICdzY2hlZHVsZWQnLFxuICAgICAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGNvbnN0IGZpbmFsRXZlbnQgPSBoYW5kbGVTY2hlZHVsZUNvbmZsaWN0KHNjaGVkdWxlZEV2ZW50LCBleGlzdGluZ0V2ZW50cyk7XG4gICAgICAgICAgc3RvcmFnZS5hZGRUaW1lQmxvY2soZmluYWxFdmVudCk7XG5cbiAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnY2FsZW5kYXJVcGRhdGUnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IGZpbmFsRXZlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cbiAgICAgICAgICAvLyBFeHRyYWN0IHRheGkgYm9va2luZyBmdW5jdGlvbiBjYWxsXG4gICAgICAgICAgY29uc3QgdGF4aU1hdGNoID0gbWVzc2FnZUNvbnRlbnQubWF0Y2goL2BgYFtcXHNcXFNdKj9ib29rX3RheGlcXCgoW1xcc1xcU10qPylcXClbXFxzXFxTXSo/YGBgLyk7XG4gICAgICAgICAgaWYgKHRheGlNYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgdGF4aVBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgcGlja3VwOiAodGF4aU1hdGNoWzFdLm1hdGNoKC9waWNrdXA9XCIoW15cIl0rKVwiLykgfHwgW10pWzFdLFxuICAgICAgICAgICAgICBkZXN0aW5hdGlvbjogKHRheGlNYXRjaFsxXS5tYXRjaCgvZGVzdGluYXRpb249XCIoW15cIl0rKVwiLykgfHwgW10pWzFdLFxuICAgICAgICAgICAgICBwaWNrdXBUaW1lOiAodGF4aU1hdGNoWzFdLm1hdGNoKC9waWNrdXBUaW1lPVwiKFteXCJdKylcIi8pIHx8IFtdKVsxXVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gRXhlY3V0ZSB0YXhpIGJvb2tpbmdcbiAgICAgICAgICAgIGNvbnN0IHBheW1lbnREZXRhaWxzID0gYXdhaXQgZnVuY3Rpb25IYW5kbGVycy5ib29rX3RheGkodGF4aVBhcmFtcyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChwYXltZW50RGV0YWlscy50eEhhc2gpIHtcbiAgICAgICAgICAgICAgLy8gVmVyaWZ5IHBheW1lbnRcbiAgICAgICAgICAgICAgY29uc3QgdmVyaWZpZWQgPSBhd2FpdCBmdW5jdGlvbkhhbmRsZXJzLnZlcmlmeV9wYXltZW50KHtcbiAgICAgICAgICAgICAgICB0eEhhc2g6IHBheW1lbnREZXRhaWxzLnR4SGFzaFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIG1lc3NhZ2VDb250ZW50ICs9IGBcXG5cXG5QYXltZW50IHN0YXR1czogJHt2ZXJpZmllZCA/ICdTdWNjZXNzZnVsJyA6ICdGYWlsZWQnfVxuVHJhbnNhY3Rpb24gaGFzaDogJHtwYXltZW50RGV0YWlscy50eEhhc2h9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWRkIG1lc3NhZ2UgdG8gY2hhdCBoaXN0b3J5XG4gICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IFsuLi5wcmV2LCB7XG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2VDb250ZW50LFxuICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH1dKTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBzZW5kTWVzc2FnZTonLCBlcnJvcik7XG4gICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IFsuLi5wcmV2LCB7XG4gICAgICAgIGNvbnRlbnQ6IGBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICAgIHJvbGU6ICdzeXN0ZW0nLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfV0pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG1lc3NhZ2VzLFxuICAgIGlzTG9hZGluZyxcbiAgICBzZW5kTWVzc2FnZVxuICB9O1xufSAiXSwibmFtZXMiOlsidXNlU3RhdGUiLCJpbml0aWFsaXplQWdlbnQiLCJTdG9yYWdlU2VydmljZSIsIlRheGlTZXJ2aWNlIiwidXNlQ2hhdGJvdCIsIm1lc3NhZ2VzIiwic2V0TWVzc2FnZXMiLCJpc0xvYWRpbmciLCJzZXRJc0xvYWRpbmciLCJoYW5kbGVTY2hlZHVsZUNvbmZsaWN0IiwibmV3RXZlbnQiLCJleGlzdGluZ0V2ZW50cyIsImNvbnNvbGUiLCJsb2ciLCJ0aXRsZSIsInN0YXJ0Iiwic3RhcnRUaW1lIiwicHJpb3JpdHkiLCJwcmlvcml0eU9yZGVyIiwiY29uZmxpY3RzIiwiZmlsdGVyIiwiZXZlbnQiLCJuZXdTdGFydCIsIkRhdGUiLCJuZXdFbmQiLCJlbmRUaW1lIiwiZXZlbnRTdGFydCIsImV2ZW50RW5kIiwiaGFzQ29uZmxpY3QiLCJleGlzdGluZ0V2ZW50IiwiZXhpc3RpbmdQcmlvcml0eSIsIm5ld1ByaW9yaXR5IiwibGVuZ3RoIiwibmV3UHJpb3JpdHlTY29yZSIsImhpZ2hlc3RDb25mbGljdFNjb3JlIiwiTWF0aCIsIm1heCIsIm1hcCIsImUiLCJuZXdFdmVudFNjb3JlIiwid2lsbFJlc2NoZWR1bGVDb25mbGljdHMiLCJzdG9yYWdlIiwiZ2V0SW5zdGFuY2UiLCJmb3JFYWNoIiwiY29uZmxpY3QiLCJkdXJhdGlvbiIsImdldFRpbWUiLCJuZXdTdGFydFRpbWUiLCJuZXdFbmRUaW1lIiwidXBkYXRlZEV2ZW50IiwidG9JU09TdHJpbmciLCJmcm9tIiwidG8iLCJ1cGRhdGVUaW1lQmxvY2siLCJsYXN0Q29uZmxpY3QiLCJzb3J0IiwiYSIsImIiLCJyZXNjaGVkdWxlZEV2ZW50Iiwic2VuZE1lc3NhZ2UiLCJjb250ZW50IiwiYWdlbnQiLCJwcm9tcHQiLCJmdW5jdGlvbkhhbmRsZXJzIiwiZm9ybWF0dGVkUHJvbXB0IiwiZm9ybWF0TWVzc2FnZXMiLCJpbnB1dCIsInJlc3BvbnNlIiwiaW52b2tlIiwibWVzc2FnZUNvbnRlbnQiLCJjb2RlQmxvY2tNYXRjaCIsIm1hdGNoIiwicGFyYW1zVGV4dCIsInBhcmFtcyIsImxvY2F0aW9uIiwibmVlZHNUcmFuc3BvcnQiLCJpbmNsdWRlcyIsImRlbGVnYXRhYmxlIiwiZ2V0VGltZUJsb2NrcyIsInRyYW5zcG9ydERldGFpbHMiLCJ0YXhpU2VydmljZSIsImVzdGltYXRlIiwiZXN0aW1hdGVUcmlwIiwiYXZhaWxhYmxlIiwic2V0TWludXRlcyIsImdldE1pbnV0ZXMiLCJwYXltZW50RGV0YWlscyIsImdldFBheW1lbnREZXRhaWxzIiwiY29zdCIsImFkZHJlc3MiLCJuZXR3b3JrIiwic2NoZWR1bGVkRXZlbnQiLCJfaWQiLCJjcnlwdG8iLCJyYW5kb21VVUlEIiwic3RhdHVzIiwiY3JlYXRlZF9hdCIsInVwZGF0ZWRfYXQiLCJmaW5hbEV2ZW50IiwiYWRkVGltZUJsb2NrIiwiQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJ3aW5kb3ciLCJkaXNwYXRjaEV2ZW50IiwidGF4aU1hdGNoIiwidGF4aVBhcmFtcyIsInBpY2t1cCIsImRlc3RpbmF0aW9uIiwicGlja3VwVGltZSIsImJvb2tfdGF4aSIsInR4SGFzaCIsInZlcmlmaWVkIiwidmVyaWZ5X3BheW1lbnQiLCJwcmV2Iiwicm9sZSIsInRpbWVzdGFtcCIsImVycm9yIiwibWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useChatbot.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/services/chatbot.ts":
/*!*********************************!*\
  !*** ./src/services/chatbot.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initializeAgent: function() { return /* binding */ initializeAgent; }\n/* harmony export */ });\n/* harmony import */ var _langchain_google_genai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/google-genai */ \"(app-pages-browser)/../../../node_modules/@langchain/google-genai/index.js\");\n/* harmony import */ var _langchain_core_prompts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @langchain/core/prompts */ \"(app-pages-browser)/../../../node_modules/@langchain/core/prompts.js\");\n/* harmony import */ var _taxiService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./taxiService */ \"(app-pages-browser)/./src/services/taxiService.ts\");\n\n\n\nasync function initializeAgent() {\n    try {\n        console.log(\"Initializing Google AI...\");\n        // Create the model\n        const model = new _langchain_google_genai__WEBPACK_IMPORTED_MODULE_0__.ChatGoogleGenerativeAI({\n            apiKey: \"AIzaSyDJcsRmDoYaG1na_gg7z9-WoSTe82sXwPA\",\n            modelName: \"gemini-pro\",\n            temperature: 0.7\n        });\n        // Create a prompt template with specific format instructions\n        const prompt = _langchain_core_prompts__WEBPACK_IMPORTED_MODULE_1__.ChatPromptTemplate.fromMessages([\n            [\n                \"system\",\n                'You are a helpful assistant that schedules events and handles transportation. When a user needs transportation:\\n\\n      1. First analyze the event:\\n         schedule_task(\\n           title=\"Event Title\",\\n           startTime=\"YYYY-MM-DDTHH:mm:ss\",\\n           endTime=\"YYYY-MM-DDTHH:mm:ss\",\\n           priority=\"[priority]\",\\n           location=\"Full Address\",\\n           needsTransport=True\\n         )\\n\\n      2. Then if transport is needed, execute:\\n         book_taxi(\\n           pickup=\"[pickup_location]\",\\n           destination=\"[event_location]\",\\n           pickupTime=\"[calculated_pickup_time]\"\\n         )\\n\\n      3. After booking, verify the payment went through using:\\n         verify_payment(txHash=\"[transaction_hash]\")\\n\\n      Always wrap function calls in triple backticks.\\n      Explain your choices and confirm when payment is successful.'\n            ],\n            [\n                \"human\",\n                \"{input}\"\n            ]\n        ]);\n        // Create function handlers\n        const functionHandlers = {\n            async book_taxi (params) {\n                const taxiService = _taxiService__WEBPACK_IMPORTED_MODULE_2__.TaxiService.getInstance();\n                const paymentDetails = await taxiService.getPaymentDetails(params.pickup, params.destination);\n                return paymentDetails;\n            },\n            async verify_payment (params) {\n                const taxiService = _taxiService__WEBPACK_IMPORTED_MODULE_2__.TaxiService.getInstance();\n                const verified = await taxiService.verifyPayment(params.txHash);\n                return verified;\n            }\n        };\n        console.log(\"Google AI initialized\");\n        return {\n            agent: model,\n            prompt,\n            functionHandlers,\n            config: {}\n        };\n    } catch (error) {\n        console.error(\"Error initializing agent:\", error);\n        throw error;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9jaGF0Ym90LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBaUU7QUFDSjtBQUNqQjtBQUVyQyxlQUFlRztJQUNwQixJQUFJO1FBQ0ZDLFFBQVFDLEdBQUcsQ0FBQztRQUVaLG1CQUFtQjtRQUNuQixNQUFNQyxRQUFRLElBQUlOLDJFQUFzQkEsQ0FBQztZQUN2Q08sUUFBUUMseUNBQXNDO1lBQzlDRyxXQUFXO1lBQ1hDLGFBQWE7UUFDZjtRQUVBLDZEQUE2RDtRQUM3RCxNQUFNQyxTQUFTWix1RUFBa0JBLENBQUNhLFlBQVksQ0FBQztZQUM3QztnQkFBQztnQkFBVzthQXVCa0Q7WUFDOUQ7Z0JBQUM7Z0JBQVM7YUFBVTtTQUNyQjtRQUVELDJCQUEyQjtRQUMzQixNQUFNQyxtQkFBbUI7WUFDdkIsTUFBTUMsV0FBVUMsTUFBVztnQkFDekIsTUFBTUMsY0FBY2hCLHFEQUFXQSxDQUFDaUIsV0FBVztnQkFDM0MsTUFBTUMsaUJBQWlCLE1BQU1GLFlBQVlHLGlCQUFpQixDQUN4REosT0FBT0ssTUFBTSxFQUNiTCxPQUFPTSxXQUFXO2dCQUVwQixPQUFPSDtZQUNUO1lBQ0EsTUFBTUksZ0JBQWVQLE1BQVc7Z0JBQzlCLE1BQU1DLGNBQWNoQixxREFBV0EsQ0FBQ2lCLFdBQVc7Z0JBQzNDLE1BQU1NLFdBQVcsTUFBTVAsWUFBWVEsYUFBYSxDQUFDVCxPQUFPVSxNQUFNO2dCQUM5RCxPQUFPRjtZQUNUO1FBQ0Y7UUFFQXJCLFFBQVFDLEdBQUcsQ0FBQztRQUVaLE9BQU87WUFDTHVCLE9BQU90QjtZQUNQTztZQUNBRTtZQUNBYyxRQUFRLENBQUM7UUFDWDtJQUNGLEVBQUUsT0FBT0MsT0FBTztRQUNkMUIsUUFBUTBCLEtBQUssQ0FBQyw2QkFBNkJBO1FBQzNDLE1BQU1BO0lBQ1I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc2VydmljZXMvY2hhdGJvdC50cz82NTliIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYXRHb29nbGVHZW5lcmF0aXZlQUkgfSBmcm9tIFwiQGxhbmdjaGFpbi9nb29nbGUtZ2VuYWlcIjtcbmltcG9ydCB7IENoYXRQcm9tcHRUZW1wbGF0ZSB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcHJvbXB0c1wiO1xuaW1wb3J0IHsgVGF4aVNlcnZpY2UgfSBmcm9tICcuL3RheGlTZXJ2aWNlJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXRpYWxpemVBZ2VudCgpIHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnSW5pdGlhbGl6aW5nIEdvb2dsZSBBSS4uLicpO1xuICAgIFxuICAgIC8vIENyZWF0ZSB0aGUgbW9kZWxcbiAgICBjb25zdCBtb2RlbCA9IG5ldyBDaGF0R29vZ2xlR2VuZXJhdGl2ZUFJKHtcbiAgICAgIGFwaUtleTogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfR09PR0xFX0FQSV9LRVksXG4gICAgICBtb2RlbE5hbWU6IFwiZ2VtaW5pLXByb1wiLFxuICAgICAgdGVtcGVyYXR1cmU6IDAuNyxcbiAgICB9KTtcblxuICAgIC8vIENyZWF0ZSBhIHByb21wdCB0ZW1wbGF0ZSB3aXRoIHNwZWNpZmljIGZvcm1hdCBpbnN0cnVjdGlvbnNcbiAgICBjb25zdCBwcm9tcHQgPSBDaGF0UHJvbXB0VGVtcGxhdGUuZnJvbU1lc3NhZ2VzKFtcbiAgICAgIFtcInN5c3RlbVwiLCBgWW91IGFyZSBhIGhlbHBmdWwgYXNzaXN0YW50IHRoYXQgc2NoZWR1bGVzIGV2ZW50cyBhbmQgaGFuZGxlcyB0cmFuc3BvcnRhdGlvbi4gV2hlbiBhIHVzZXIgbmVlZHMgdHJhbnNwb3J0YXRpb246XG5cbiAgICAgIDEuIEZpcnN0IGFuYWx5emUgdGhlIGV2ZW50OlxuICAgICAgICAgc2NoZWR1bGVfdGFzayhcbiAgICAgICAgICAgdGl0bGU9XCJFdmVudCBUaXRsZVwiLFxuICAgICAgICAgICBzdGFydFRpbWU9XCJZWVlZLU1NLUREVEhIOm1tOnNzXCIsXG4gICAgICAgICAgIGVuZFRpbWU9XCJZWVlZLU1NLUREVEhIOm1tOnNzXCIsXG4gICAgICAgICAgIHByaW9yaXR5PVwiW3ByaW9yaXR5XVwiLFxuICAgICAgICAgICBsb2NhdGlvbj1cIkZ1bGwgQWRkcmVzc1wiLFxuICAgICAgICAgICBuZWVkc1RyYW5zcG9ydD1UcnVlXG4gICAgICAgICApXG5cbiAgICAgIDIuIFRoZW4gaWYgdHJhbnNwb3J0IGlzIG5lZWRlZCwgZXhlY3V0ZTpcbiAgICAgICAgIGJvb2tfdGF4aShcbiAgICAgICAgICAgcGlja3VwPVwiW3BpY2t1cF9sb2NhdGlvbl1cIixcbiAgICAgICAgICAgZGVzdGluYXRpb249XCJbZXZlbnRfbG9jYXRpb25dXCIsXG4gICAgICAgICAgIHBpY2t1cFRpbWU9XCJbY2FsY3VsYXRlZF9waWNrdXBfdGltZV1cIlxuICAgICAgICAgKVxuXG4gICAgICAzLiBBZnRlciBib29raW5nLCB2ZXJpZnkgdGhlIHBheW1lbnQgd2VudCB0aHJvdWdoIHVzaW5nOlxuICAgICAgICAgdmVyaWZ5X3BheW1lbnQodHhIYXNoPVwiW3RyYW5zYWN0aW9uX2hhc2hdXCIpXG5cbiAgICAgIEFsd2F5cyB3cmFwIGZ1bmN0aW9uIGNhbGxzIGluIHRyaXBsZSBiYWNrdGlja3MuXG4gICAgICBFeHBsYWluIHlvdXIgY2hvaWNlcyBhbmQgY29uZmlybSB3aGVuIHBheW1lbnQgaXMgc3VjY2Vzc2Z1bC5gXSxcbiAgICAgIFtcImh1bWFuXCIsIFwie2lucHV0fVwiXVxuICAgIF0pO1xuXG4gICAgLy8gQ3JlYXRlIGZ1bmN0aW9uIGhhbmRsZXJzXG4gICAgY29uc3QgZnVuY3Rpb25IYW5kbGVycyA9IHtcbiAgICAgIGFzeW5jIGJvb2tfdGF4aShwYXJhbXM6IGFueSkge1xuICAgICAgICBjb25zdCB0YXhpU2VydmljZSA9IFRheGlTZXJ2aWNlLmdldEluc3RhbmNlKCk7XG4gICAgICAgIGNvbnN0IHBheW1lbnREZXRhaWxzID0gYXdhaXQgdGF4aVNlcnZpY2UuZ2V0UGF5bWVudERldGFpbHMoXG4gICAgICAgICAgcGFyYW1zLnBpY2t1cCxcbiAgICAgICAgICBwYXJhbXMuZGVzdGluYXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHBheW1lbnREZXRhaWxzO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIHZlcmlmeV9wYXltZW50KHBhcmFtczogYW55KSB7XG4gICAgICAgIGNvbnN0IHRheGlTZXJ2aWNlID0gVGF4aVNlcnZpY2UuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgY29uc3QgdmVyaWZpZWQgPSBhd2FpdCB0YXhpU2VydmljZS52ZXJpZnlQYXltZW50KHBhcmFtcy50eEhhc2gpO1xuICAgICAgICByZXR1cm4gdmVyaWZpZWQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnNvbGUubG9nKCdHb29nbGUgQUkgaW5pdGlhbGl6ZWQnKTtcblxuICAgIHJldHVybiB7XG4gICAgICBhZ2VudDogbW9kZWwsXG4gICAgICBwcm9tcHQsXG4gICAgICBmdW5jdGlvbkhhbmRsZXJzLFxuICAgICAgY29uZmlnOiB7fVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5pdGlhbGl6aW5nIGFnZW50OicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufSJdLCJuYW1lcyI6WyJDaGF0R29vZ2xlR2VuZXJhdGl2ZUFJIiwiQ2hhdFByb21wdFRlbXBsYXRlIiwiVGF4aVNlcnZpY2UiLCJpbml0aWFsaXplQWdlbnQiLCJjb25zb2xlIiwibG9nIiwibW9kZWwiLCJhcGlLZXkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfR09PR0xFX0FQSV9LRVkiLCJtb2RlbE5hbWUiLCJ0ZW1wZXJhdHVyZSIsInByb21wdCIsImZyb21NZXNzYWdlcyIsImZ1bmN0aW9uSGFuZGxlcnMiLCJib29rX3RheGkiLCJwYXJhbXMiLCJ0YXhpU2VydmljZSIsImdldEluc3RhbmNlIiwicGF5bWVudERldGFpbHMiLCJnZXRQYXltZW50RGV0YWlscyIsInBpY2t1cCIsImRlc3RpbmF0aW9uIiwidmVyaWZ5X3BheW1lbnQiLCJ2ZXJpZmllZCIsInZlcmlmeVBheW1lbnQiLCJ0eEhhc2giLCJhZ2VudCIsImNvbmZpZyIsImVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/chatbot.ts\n"));

/***/ })

});