"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useChatbot.ts":
/*!*********************************!*\
  !*** ./src/hooks/useChatbot.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChatbot: function() { return /* binding */ useChatbot; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _services_chatbot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/services/chatbot */ \"(app-pages-browser)/./src/services/chatbot.ts\");\n/* harmony import */ var _lib_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/storage */ \"(app-pages-browser)/./src/lib/storage.ts\");\n/* harmony import */ var _services_taxiService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/taxiService */ \"(app-pages-browser)/./src/services/taxiService.ts\");\n/* __next_internal_client_entry_do_not_use__ useChatbot auto */ \n\n\n\nfunction useChatbot() {\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Load chat history from localStorage on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const savedMessages = localStorage.getItem(\"chat_history\");\n        if (savedMessages) {\n            setMessages(JSON.parse(savedMessages));\n        }\n    }, []);\n    // Save messages to localStorage whenever they change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        localStorage.setItem(\"chat_history\", JSON.stringify(messages));\n    }, [\n        messages\n    ]);\n    const handleScheduleConflict = (newEvent, existingEvents)=>{\n        console.log(\"Checking conflicts for new event:\", {\n            title: newEvent.title,\n            start: newEvent.startTime,\n            priority: newEvent.priority\n        });\n        console.log(\"Existing events:\", existingEvents);\n        // Sort existing events by priority\n        const priorityOrder = {\n            \"urgent-important\": 3,\n            \"important\": 2,\n            \"urgent\": 1,\n            \"neither\": 0\n        };\n        // Find conflicting events\n        const conflicts = existingEvents.filter((event)=>{\n            const newStart = new Date(newEvent.startTime);\n            const newEnd = new Date(newEvent.endTime);\n            const eventStart = new Date(event.startTime);\n            const eventEnd = new Date(event.endTime);\n            const hasConflict = newStart >= eventStart && newStart < eventEnd || newEnd > eventStart && newEnd <= eventEnd || newStart <= eventStart && newEnd >= eventEnd;\n            if (hasConflict) {\n                console.log(\"Found conflict:\", {\n                    existingEvent: event.title,\n                    existingPriority: event.priority,\n                    newEvent: newEvent.title,\n                    newPriority: newEvent.priority\n                });\n            }\n            return hasConflict;\n        });\n        if (conflicts.length === 0) {\n            console.log(\"No conflicts found\");\n            return newEvent;\n        }\n        // Check if new event has higher priority\n        const newPriorityScore = priorityOrder[newEvent.priority];\n        const highestConflictScore = Math.max(...conflicts.map((e)=>priorityOrder[e.priority]));\n        console.log(\"Priority comparison:\", {\n            newEventScore: newPriorityScore,\n            highestConflictScore,\n            willRescheduleConflicts: newPriorityScore > highestConflictScore\n        });\n        if (newPriorityScore > highestConflictScore) {\n            // Move conflicting events\n            console.log(\"Moving conflicting events...\");\n            const storage = _lib_storage__WEBPACK_IMPORTED_MODULE_2__.StorageService.getInstance();\n            conflicts.forEach((conflict)=>{\n                // Move to next available time\n                const duration = new Date(conflict.endTime).getTime() - new Date(conflict.startTime).getTime();\n                const newStartTime = new Date(newEvent.endTime);\n                const newEndTime = new Date(newStartTime.getTime() + duration);\n                const updatedEvent = {\n                    ...conflict,\n                    startTime: newStartTime.toISOString(),\n                    endTime: newEndTime.toISOString()\n                };\n                console.log(\"Moving event:\", {\n                    event: conflict.title,\n                    from: conflict.startTime,\n                    to: updatedEvent.startTime\n                });\n                storage.updateTimeBlock(updatedEvent);\n            });\n            return newEvent;\n        } else {\n            // Find next available time for new event\n            console.log(\"Finding next available time for new event...\");\n            const duration = new Date(newEvent.endTime).getTime() - new Date(newEvent.startTime).getTime();\n            const lastConflict = conflicts.sort((a, b)=>new Date(b.endTime).getTime() - new Date(a.endTime).getTime())[0];\n            const newStartTime = new Date(lastConflict.endTime);\n            const newEndTime = new Date(newStartTime.getTime() + duration);\n            const rescheduledEvent = {\n                ...newEvent,\n                startTime: newStartTime.toISOString(),\n                endTime: newEndTime.toISOString()\n            };\n            console.log(\"Rescheduled new event:\", {\n                from: newEvent.startTime,\n                to: rescheduledEvent.startTime\n            });\n            return rescheduledEvent;\n        }\n    };\n    const parseTimeString = (timeStr)=>{\n        // Try ISO format first\n        let date = new Date(timeStr);\n        if (!isNaN(date.getTime())) {\n            return date;\n        }\n        // Try parsing human-readable time formats\n        const today = new Date();\n        const timeRegex = /(\\d{1,2}):(\\d{2})\\s*(AM|PM|am|pm)?/;\n        const match = timeStr.match(timeRegex);\n        if (match) {\n            let [_, hours, minutes, meridiem] = match;\n            let hour = parseInt(hours);\n            // Convert to 24-hour format if meridiem is provided\n            if (meridiem) {\n                if (meridiem.toUpperCase() === \"PM\" && hour < 12) hour += 12;\n                if (meridiem.toUpperCase() === \"AM\" && hour === 12) hour = 0;\n            }\n            date = new Date(today);\n            date.setHours(hour, parseInt(minutes), 0, 0);\n            return date;\n        }\n        throw new Error(\"Unable to parse time: \".concat(timeStr));\n    };\n    const parseDate = (dateStr)=>{\n        try {\n            // If it's just a time string, parse it as time\n            if (dateStr.match(/^\\d{1,2}:\\d{2}(\\s*[AaPp][Mm])?$/)) {\n                return parseTimeString(dateStr);\n            }\n            // Try parsing as full date\n            const date = new Date(dateStr);\n            if (!isNaN(date.getTime())) {\n                return date;\n            }\n            throw new Error(\"Invalid date: \".concat(dateStr));\n        } catch (error) {\n            console.error(\"Date parsing error:\", error);\n            throw new Error(\"Invalid date format: \".concat(dateStr));\n        }\n    };\n    const sendMessage = async (content)=>{\n        console.log(\"=== START sendMessage ===\");\n        setIsLoading(true);\n        try {\n            // Initialize agent\n            console.log(\"Initializing agent...\");\n            const { agent, prompt, functionHandlers } = await (0,_services_chatbot__WEBPACK_IMPORTED_MODULE_1__.initializeAgent)();\n            console.log(\"Agent initialized successfully\");\n            // Format the prompt\n            const formattedPrompt = await prompt.formatMessages({\n                input: content\n            });\n            // Call agent\n            console.log(\"Calling agent...\");\n            const response = await agent.invoke(formattedPrompt);\n            console.log(\"Agent response received:\", response);\n            // Extract content\n            let messageContent = response.content;\n            // Look for schedule task\n            const codeBlockMatch = messageContent.match(/```[\\s\\S]*?schedule_task\\(([\\s\\S]*?)\\)[\\s\\S]*?```/);\n            if (codeBlockMatch) {\n                const paramsText = codeBlockMatch[1];\n                const params = {\n                    title: (paramsText.match(/title=\"([^\"]+)\"/) || [])[1],\n                    startTime: (paramsText.match(/startTime=\"([^\"]+)\"/) || [])[1],\n                    endTime: (paramsText.match(/endTime=\"([^\"]+)\"/) || [])[1],\n                    priority: (paramsText.match(/priority=\"([^\"]+)\"/) || [])[1],\n                    location: (paramsText.match(/location=\"([^\"]+)\"/) || [])[1],\n                    needsTransport: paramsText.includes(\"needsTransport=True\"),\n                    delegatable: paramsText.includes(\"delegatable=True\")\n                };\n                if (params.title && params.startTime) {\n                    // Validate and parse dates\n                    const startTime = parseDate(params.startTime);\n                    const endTime = params.endTime ? parseDate(params.endTime) : new Date(startTime.getTime() + 60 * 60 * 1000);\n                    const storage = _lib_storage__WEBPACK_IMPORTED_MODULE_2__.StorageService.getInstance();\n                    const existingEvents = storage.getTimeBlocks();\n                    // Handle transportation if needed\n                    let transportDetails = null;\n                    if (params.needsTransport && params.location) {\n                        const taxiService = _services_taxiService__WEBPACK_IMPORTED_MODULE_3__.TaxiService.getInstance();\n                        const estimate = await taxiService.estimateTrip(\"current_location\", params.location);\n                        if (estimate.available) {\n                            // Add buffer time for transportation\n                            const pickupTime = new Date(startTime.getTime());\n                            pickupTime.setMinutes(pickupTime.getMinutes() - estimate.duration);\n                            const scheduledEvent = {\n                                _id: crypto.randomUUID(),\n                                title: params.title,\n                                startTime: pickupTime.toISOString(),\n                                endTime: endTime.toISOString(),\n                                priority: params.priority || \"important\",\n                                location: params.location,\n                                transportDetails,\n                                delegatable: params.delegatable || false,\n                                status: \"scheduled\",\n                                created_at: new Date().toISOString(),\n                                updated_at: new Date().toISOString()\n                            };\n                            // Get payment details\n                            const paymentDetails = await taxiService.getPaymentDetails(\"current_location\", params.location);\n                            messageContent = \"\\uD83D\\uDCC5 Event Scheduled: \".concat(params.title, \"\\n⏰ Time: \").concat(startTime.toLocaleString(), \" - \").concat(endTime.toLocaleString(), \"\\n\\uD83D\\uDCCD Location: \").concat(params.location, \"\\n\\uD83D\\uDE95 Transport: Taxi booked for \").concat(estimate.duration, \" minutes before event\\n\\uD83D\\uDCB0 Payment: \").concat(paymentDetails.txHash ? \"Processing...\" : \"Pending\", \"\\n\").concat(paymentDetails.txHash ? \"Transaction: \".concat(paymentDetails.txHash) : \"\");\n                            const finalEvent = handleScheduleConflict(scheduledEvent, existingEvents);\n                            storage.addTimeBlock(finalEvent);\n                            const event = new CustomEvent(\"calendarUpdate\", {\n                                detail: finalEvent\n                            });\n                            window.dispatchEvent(event);\n                        }\n                    }\n                }\n            }\n            // Add message to chat history\n            setMessages((prev)=>[\n                    ...prev,\n                    {\n                        content: messageContent,\n                        role: \"assistant\",\n                        timestamp: new Date().toISOString()\n                    }\n                ]);\n        } catch (error) {\n            console.error(\"Error in sendMessage:\", error);\n            setMessages((prev)=>[\n                    ...prev,\n                    {\n                        content: \"Error: \".concat(error.message),\n                        role: \"system\",\n                        timestamp: new Date().toISOString()\n                    }\n                ]);\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    return {\n        messages,\n        setMessages,\n        isLoading,\n        sendMessage\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VDaGF0Ym90LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztnRUFFNEM7QUFDUztBQUNOO0FBQ007QUFFOUMsU0FBU0s7SUFDZCxNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR1AsK0NBQVFBLENBQVEsRUFBRTtJQUNsRCxNQUFNLENBQUNRLFdBQVdDLGFBQWEsR0FBR1QsK0NBQVFBLENBQUM7SUFFM0MsK0NBQStDO0lBQy9DQyxnREFBU0EsQ0FBQztRQUNSLE1BQU1TLGdCQUFnQkMsYUFBYUMsT0FBTyxDQUFDO1FBQzNDLElBQUlGLGVBQWU7WUFDakJILFlBQVlNLEtBQUtDLEtBQUssQ0FBQ0o7UUFDekI7SUFDRixHQUFHLEVBQUU7SUFFTCxxREFBcUQ7SUFDckRULGdEQUFTQSxDQUFDO1FBQ1JVLGFBQWFJLE9BQU8sQ0FBQyxnQkFBZ0JGLEtBQUtHLFNBQVMsQ0FBQ1Y7SUFDdEQsR0FBRztRQUFDQTtLQUFTO0lBRWIsTUFBTVcseUJBQXlCLENBQUNDLFVBQXFCQztRQUNuREMsUUFBUUMsR0FBRyxDQUFDLHFDQUFxQztZQUMvQ0MsT0FBT0osU0FBU0ksS0FBSztZQUNyQkMsT0FBT0wsU0FBU00sU0FBUztZQUN6QkMsVUFBVVAsU0FBU08sUUFBUTtRQUM3QjtRQUNBTCxRQUFRQyxHQUFHLENBQUMsb0JBQW9CRjtRQUVoQyxtQ0FBbUM7UUFDbkMsTUFBTU8sZ0JBQWdCO1lBQ3BCLG9CQUFvQjtZQUNwQixhQUFhO1lBQ2IsVUFBVTtZQUNWLFdBQVc7UUFDYjtRQUVBLDBCQUEwQjtRQUMxQixNQUFNQyxZQUFZUixlQUFlUyxNQUFNLENBQUNDLENBQUFBO1lBQ3RDLE1BQU1DLFdBQVcsSUFBSUMsS0FBS2IsU0FBU00sU0FBUztZQUM1QyxNQUFNUSxTQUFTLElBQUlELEtBQUtiLFNBQVNlLE9BQU87WUFDeEMsTUFBTUMsYUFBYSxJQUFJSCxLQUFLRixNQUFNTCxTQUFTO1lBQzNDLE1BQU1XLFdBQVcsSUFBSUos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RUEsT0FBTztRQUNMSDtRQUNBQztRQUNBQztRQUNBOEU7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9ob29rcy91c2VDaGF0Ym90LnRzP2Q0NmYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaW5pdGlhbGl6ZUFnZW50IH0gZnJvbSAnQC9zZXJ2aWNlcy9jaGF0Ym90JztcbmltcG9ydCB7IFN0b3JhZ2VTZXJ2aWNlIH0gZnJvbSAnQC9saWIvc3RvcmFnZSc7XG5pbXBvcnQgeyBUYXhpU2VydmljZSB9IGZyb20gJ0Avc2VydmljZXMvdGF4aVNlcnZpY2UnO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hhdGJvdCgpIHtcbiAgY29uc3QgW21lc3NhZ2VzLCBzZXRNZXNzYWdlc10gPSB1c2VTdGF0ZTxhbnlbXT4oW10pO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIC8vIExvYWQgY2hhdCBoaXN0b3J5IGZyb20gbG9jYWxTdG9yYWdlIG9uIG1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgc2F2ZWRNZXNzYWdlcyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdjaGF0X2hpc3RvcnknKTtcbiAgICBpZiAoc2F2ZWRNZXNzYWdlcykge1xuICAgICAgc2V0TWVzc2FnZXMoSlNPTi5wYXJzZShzYXZlZE1lc3NhZ2VzKSk7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgLy8gU2F2ZSBtZXNzYWdlcyB0byBsb2NhbFN0b3JhZ2Ugd2hlbmV2ZXIgdGhleSBjaGFuZ2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnY2hhdF9oaXN0b3J5JywgSlNPTi5zdHJpbmdpZnkobWVzc2FnZXMpKTtcbiAgfSwgW21lc3NhZ2VzXSk7XG5cbiAgY29uc3QgaGFuZGxlU2NoZWR1bGVDb25mbGljdCA9IChuZXdFdmVudDogVGltZUJsb2NrLCBleGlzdGluZ0V2ZW50czogVGltZUJsb2NrW10pID0+IHtcbiAgICBjb25zb2xlLmxvZygnQ2hlY2tpbmcgY29uZmxpY3RzIGZvciBuZXcgZXZlbnQ6Jywge1xuICAgICAgdGl0bGU6IG5ld0V2ZW50LnRpdGxlLFxuICAgICAgc3RhcnQ6IG5ld0V2ZW50LnN0YXJ0VGltZSxcbiAgICAgIHByaW9yaXR5OiBuZXdFdmVudC5wcmlvcml0eVxuICAgIH0pO1xuICAgIGNvbnNvbGUubG9nKCdFeGlzdGluZyBldmVudHM6JywgZXhpc3RpbmdFdmVudHMpO1xuXG4gICAgLy8gU29ydCBleGlzdGluZyBldmVudHMgYnkgcHJpb3JpdHlcbiAgICBjb25zdCBwcmlvcml0eU9yZGVyID0ge1xuICAgICAgJ3VyZ2VudC1pbXBvcnRhbnQnOiAzLFxuICAgICAgJ2ltcG9ydGFudCc6IDIsXG4gICAgICAndXJnZW50JzogMSxcbiAgICAgICduZWl0aGVyJzogMFxuICAgIH07XG5cbiAgICAvLyBGaW5kIGNvbmZsaWN0aW5nIGV2ZW50c1xuICAgIGNvbnN0IGNvbmZsaWN0cyA9IGV4aXN0aW5nRXZlbnRzLmZpbHRlcihldmVudCA9PiB7XG4gICAgICBjb25zdCBuZXdTdGFydCA9IG5ldyBEYXRlKG5ld0V2ZW50LnN0YXJ0VGltZSk7XG4gICAgICBjb25zdCBuZXdFbmQgPSBuZXcgRGF0ZShuZXdFdmVudC5lbmRUaW1lKTtcbiAgICAgIGNvbnN0IGV2ZW50U3RhcnQgPSBuZXcgRGF0ZShldmVudC5zdGFydFRpbWUpO1xuICAgICAgY29uc3QgZXZlbnRFbmQgPSBuZXcgRGF0ZShldmVudC5lbmRUaW1lKTtcbiAgICAgIFxuICAgICAgY29uc3QgaGFzQ29uZmxpY3QgPSAoXG4gICAgICAgIChuZXdTdGFydCA+PSBldmVudFN0YXJ0ICYmIG5ld1N0YXJ0IDwgZXZlbnRFbmQpIHx8XG4gICAgICAgIChuZXdFbmQgPiBldmVudFN0YXJ0ICYmIG5ld0VuZCA8PSBldmVudEVuZCkgfHxcbiAgICAgICAgKG5ld1N0YXJ0IDw9IGV2ZW50U3RhcnQgJiYgbmV3RW5kID49IGV2ZW50RW5kKVxuICAgICAgKTtcblxuICAgICAgaWYgKGhhc0NvbmZsaWN0KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBjb25mbGljdDonLCB7XG4gICAgICAgICAgZXhpc3RpbmdFdmVudDogZXZlbnQudGl0bGUsXG4gICAgICAgICAgZXhpc3RpbmdQcmlvcml0eTogZXZlbnQucHJpb3JpdHksXG4gICAgICAgICAgbmV3RXZlbnQ6IG5ld0V2ZW50LnRpdGxlLFxuICAgICAgICAgIG5ld1ByaW9yaXR5OiBuZXdFdmVudC5wcmlvcml0eVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGhhc0NvbmZsaWN0O1xuICAgIH0pO1xuXG4gICAgaWYgKGNvbmZsaWN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCdObyBjb25mbGljdHMgZm91bmQnKTtcbiAgICAgIHJldHVybiBuZXdFdmVudDtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBuZXcgZXZlbnQgaGFzIGhpZ2hlciBwcmlvcml0eVxuICAgIGNvbnN0IG5ld1ByaW9yaXR5U2NvcmUgPSBwcmlvcml0eU9yZGVyW25ld0V2ZW50LnByaW9yaXR5XTtcbiAgICBjb25zdCBoaWdoZXN0Q29uZmxpY3RTY29yZSA9IE1hdGgubWF4KFxuICAgICAgLi4uY29uZmxpY3RzLm1hcChlID0+IHByaW9yaXR5T3JkZXJbZS5wcmlvcml0eV0pXG4gICAgKTtcblxuICAgIGNvbnNvbGUubG9nKCdQcmlvcml0eSBjb21wYXJpc29uOicsIHtcbiAgICAgIG5ld0V2ZW50U2NvcmU6IG5ld1ByaW9yaXR5U2NvcmUsXG4gICAgICBoaWdoZXN0Q29uZmxpY3RTY29yZSxcbiAgICAgIHdpbGxSZXNjaGVkdWxlQ29uZmxpY3RzOiBuZXdQcmlvcml0eVNjb3JlID4gaGlnaGVzdENvbmZsaWN0U2NvcmVcbiAgICB9KTtcblxuICAgIGlmIChuZXdQcmlvcml0eVNjb3JlID4gaGlnaGVzdENvbmZsaWN0U2NvcmUpIHtcbiAgICAgIC8vIE1vdmUgY29uZmxpY3RpbmcgZXZlbnRzXG4gICAgICBjb25zb2xlLmxvZygnTW92aW5nIGNvbmZsaWN0aW5nIGV2ZW50cy4uLicpO1xuICAgICAgY29uc3Qgc3RvcmFnZSA9IFN0b3JhZ2VTZXJ2aWNlLmdldEluc3RhbmNlKCk7XG4gICAgICBjb25mbGljdHMuZm9yRWFjaChjb25mbGljdCA9PiB7XG4gICAgICAgIC8vIE1vdmUgdG8gbmV4dCBhdmFpbGFibGUgdGltZVxuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IG5ldyBEYXRlKGNvbmZsaWN0LmVuZFRpbWUpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGNvbmZsaWN0LnN0YXJ0VGltZSkuZ2V0VGltZSgpO1xuICAgICAgICBjb25zdCBuZXdTdGFydFRpbWUgPSBuZXcgRGF0ZShuZXdFdmVudC5lbmRUaW1lKTtcbiAgICAgICAgY29uc3QgbmV3RW5kVGltZSA9IG5ldyBEYXRlKG5ld1N0YXJ0VGltZS5nZXRUaW1lKCkgKyBkdXJhdGlvbik7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB1cGRhdGVkRXZlbnQgPSB7XG4gICAgICAgICAgLi4uY29uZmxpY3QsXG4gICAgICAgICAgc3RhcnRUaW1lOiBuZXdTdGFydFRpbWUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBlbmRUaW1lOiBuZXdFbmRUaW1lLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKCdNb3ZpbmcgZXZlbnQ6Jywge1xuICAgICAgICAgIGV2ZW50OiBjb25mbGljdC50aXRsZSxcbiAgICAgICAgICBmcm9tOiBjb25mbGljdC5zdGFydFRpbWUsXG4gICAgICAgICAgdG86IHVwZGF0ZWRFdmVudC5zdGFydFRpbWVcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBzdG9yYWdlLnVwZGF0ZVRpbWVCbG9jayh1cGRhdGVkRXZlbnQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3RXZlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpbmQgbmV4dCBhdmFpbGFibGUgdGltZSBmb3IgbmV3IGV2ZW50XG4gICAgICBjb25zb2xlLmxvZygnRmluZGluZyBuZXh0IGF2YWlsYWJsZSB0aW1lIGZvciBuZXcgZXZlbnQuLi4nKTtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gbmV3IERhdGUobmV3RXZlbnQuZW5kVGltZSkuZ2V0VGltZSgpIC0gbmV3IERhdGUobmV3RXZlbnQuc3RhcnRUaW1lKS5nZXRUaW1lKCk7XG4gICAgICBjb25zdCBsYXN0Q29uZmxpY3QgPSBjb25mbGljdHMuc29ydCgoYSwgYikgPT4gXG4gICAgICAgIG5ldyBEYXRlKGIuZW5kVGltZSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYS5lbmRUaW1lKS5nZXRUaW1lKClcbiAgICAgIClbMF07XG4gICAgICBcbiAgICAgIGNvbnN0IG5ld1N0YXJ0VGltZSA9IG5ldyBEYXRlKGxhc3RDb25mbGljdC5lbmRUaW1lKTtcbiAgICAgIGNvbnN0IG5ld0VuZFRpbWUgPSBuZXcgRGF0ZShuZXdTdGFydFRpbWUuZ2V0VGltZSgpICsgZHVyYXRpb24pO1xuICAgICAgXG4gICAgICBjb25zdCByZXNjaGVkdWxlZEV2ZW50ID0ge1xuICAgICAgICAuLi5uZXdFdmVudCxcbiAgICAgICAgc3RhcnRUaW1lOiBuZXdTdGFydFRpbWUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgZW5kVGltZTogbmV3RW5kVGltZS50b0lTT1N0cmluZygpXG4gICAgICB9O1xuXG4gICAgICBjb25zb2xlLmxvZygnUmVzY2hlZHVsZWQgbmV3IGV2ZW50OicsIHtcbiAgICAgICAgZnJvbTogbmV3RXZlbnQuc3RhcnRUaW1lLFxuICAgICAgICB0bzogcmVzY2hlZHVsZWRFdmVudC5zdGFydFRpbWVcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4gcmVzY2hlZHVsZWRFdmVudDtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcGFyc2VUaW1lU3RyaW5nID0gKHRpbWVTdHI6IHN0cmluZyk6IERhdGUgPT4ge1xuICAgIC8vIFRyeSBJU08gZm9ybWF0IGZpcnN0XG4gICAgbGV0IGRhdGUgPSBuZXcgRGF0ZSh0aW1lU3RyKTtcbiAgICBpZiAoIWlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgLy8gVHJ5IHBhcnNpbmcgaHVtYW4tcmVhZGFibGUgdGltZSBmb3JtYXRzXG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IHRpbWVSZWdleCA9IC8oXFxkezEsMn0pOihcXGR7Mn0pXFxzKihBTXxQTXxhbXxwbSk/LztcbiAgICBjb25zdCBtYXRjaCA9IHRpbWVTdHIubWF0Y2godGltZVJlZ2V4KTtcbiAgICBcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGxldCBbXywgaG91cnMsIG1pbnV0ZXMsIG1lcmlkaWVtXSA9IG1hdGNoO1xuICAgICAgbGV0IGhvdXIgPSBwYXJzZUludChob3Vycyk7XG4gICAgICBcbiAgICAgIC8vIENvbnZlcnQgdG8gMjQtaG91ciBmb3JtYXQgaWYgbWVyaWRpZW0gaXMgcHJvdmlkZWRcbiAgICAgIGlmIChtZXJpZGllbSkge1xuICAgICAgICBpZiAobWVyaWRpZW0udG9VcHBlckNhc2UoKSA9PT0gJ1BNJyAmJiBob3VyIDwgMTIpIGhvdXIgKz0gMTI7XG4gICAgICAgIGlmIChtZXJpZGllbS50b1VwcGVyQ2FzZSgpID09PSAnQU0nICYmIGhvdXIgPT09IDEyKSBob3VyID0gMDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZGF0ZSA9IG5ldyBEYXRlKHRvZGF5KTtcbiAgICAgIGRhdGUuc2V0SG91cnMoaG91ciwgcGFyc2VJbnQobWludXRlcyksIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcGFyc2UgdGltZTogJHt0aW1lU3RyfWApO1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlRGF0ZSA9IChkYXRlU3RyOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gSWYgaXQncyBqdXN0IGEgdGltZSBzdHJpbmcsIHBhcnNlIGl0IGFzIHRpbWVcbiAgICAgIGlmIChkYXRlU3RyLm1hdGNoKC9eXFxkezEsMn06XFxkezJ9KFxccypbQWFQcF1bTW1dKT8kLykpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlVGltZVN0cmluZyhkYXRlU3RyKTtcbiAgICAgIH1cblxuICAgICAgLy8gVHJ5IHBhcnNpbmcgYXMgZnVsbCBkYXRlXG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoZGF0ZVN0cik7XG4gICAgICBpZiAoIWlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGU6ICR7ZGF0ZVN0cn1gKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRGF0ZSBwYXJzaW5nIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRlIGZvcm1hdDogJHtkYXRlU3RyfWApO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBzZW5kTWVzc2FnZSA9IGFzeW5jIChjb250ZW50OiBzdHJpbmcpID0+IHtcbiAgICBjb25zb2xlLmxvZygnPT09IFNUQVJUIHNlbmRNZXNzYWdlID09PScpO1xuICAgIHNldElzTG9hZGluZyh0cnVlKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBJbml0aWFsaXplIGFnZW50XG4gICAgICBjb25zb2xlLmxvZygnSW5pdGlhbGl6aW5nIGFnZW50Li4uJyk7XG4gICAgICBjb25zdCB7IGFnZW50LCBwcm9tcHQsIGZ1bmN0aW9uSGFuZGxlcnMgfSA9IGF3YWl0IGluaXRpYWxpemVBZ2VudCgpO1xuICAgICAgY29uc29sZS5sb2coJ0FnZW50IGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseScpO1xuXG4gICAgICAvLyBGb3JtYXQgdGhlIHByb21wdFxuICAgICAgY29uc3QgZm9ybWF0dGVkUHJvbXB0ID0gYXdhaXQgcHJvbXB0LmZvcm1hdE1lc3NhZ2VzKHtcbiAgICAgICAgaW5wdXQ6IGNvbnRlbnRcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDYWxsIGFnZW50XG4gICAgICBjb25zb2xlLmxvZygnQ2FsbGluZyBhZ2VudC4uLicpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhZ2VudC5pbnZva2UoZm9ybWF0dGVkUHJvbXB0KTtcbiAgICAgIGNvbnNvbGUubG9nKCdBZ2VudCByZXNwb25zZSByZWNlaXZlZDonLCByZXNwb25zZSk7XG5cbiAgICAgIC8vIEV4dHJhY3QgY29udGVudFxuICAgICAgbGV0IG1lc3NhZ2VDb250ZW50ID0gcmVzcG9uc2UuY29udGVudDtcblxuICAgICAgLy8gTG9vayBmb3Igc2NoZWR1bGUgdGFza1xuICAgICAgY29uc3QgY29kZUJsb2NrTWF0Y2ggPSBtZXNzYWdlQ29udGVudC5tYXRjaCgvYGBgW1xcc1xcU10qP3NjaGVkdWxlX3Rhc2tcXCgoW1xcc1xcU10qPylcXClbXFxzXFxTXSo/YGBgLyk7XG4gICAgICBpZiAoY29kZUJsb2NrTWF0Y2gpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zVGV4dCA9IGNvZGVCbG9ja01hdGNoWzFdO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgdGl0bGU6IChwYXJhbXNUZXh0Lm1hdGNoKC90aXRsZT1cIihbXlwiXSspXCIvKSB8fCBbXSlbMV0sXG4gICAgICAgICAgc3RhcnRUaW1lOiAocGFyYW1zVGV4dC5tYXRjaCgvc3RhcnRUaW1lPVwiKFteXCJdKylcIi8pIHx8IFtdKVsxXSxcbiAgICAgICAgICBlbmRUaW1lOiAocGFyYW1zVGV4dC5tYXRjaCgvZW5kVGltZT1cIihbXlwiXSspXCIvKSB8fCBbXSlbMV0sXG4gICAgICAgICAgcHJpb3JpdHk6IChwYXJhbXNUZXh0Lm1hdGNoKC9wcmlvcml0eT1cIihbXlwiXSspXCIvKSB8fCBbXSlbMV0sXG4gICAgICAgICAgbG9jYXRpb246IChwYXJhbXNUZXh0Lm1hdGNoKC9sb2NhdGlvbj1cIihbXlwiXSspXCIvKSB8fCBbXSlbMV0sXG4gICAgICAgICAgbmVlZHNUcmFuc3BvcnQ6IHBhcmFtc1RleHQuaW5jbHVkZXMoJ25lZWRzVHJhbnNwb3J0PVRydWUnKSxcbiAgICAgICAgICBkZWxlZ2F0YWJsZTogcGFyYW1zVGV4dC5pbmNsdWRlcygnZGVsZWdhdGFibGU9VHJ1ZScpXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHBhcmFtcy50aXRsZSAmJiBwYXJhbXMuc3RhcnRUaW1lKSB7XG4gICAgICAgICAgLy8gVmFsaWRhdGUgYW5kIHBhcnNlIGRhdGVzXG4gICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGFyc2VEYXRlKHBhcmFtcy5zdGFydFRpbWUpO1xuICAgICAgICAgIGNvbnN0IGVuZFRpbWUgPSBwYXJhbXMuZW5kVGltZSA/IHBhcnNlRGF0ZShwYXJhbXMuZW5kVGltZSkgOiBcbiAgICAgICAgICAgIG5ldyBEYXRlKHN0YXJ0VGltZS5nZXRUaW1lKCkgKyA2MCAqIDYwICogMTAwMCk7XG5cbiAgICAgICAgICBjb25zdCBzdG9yYWdlID0gU3RvcmFnZVNlcnZpY2UuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICBjb25zdCBleGlzdGluZ0V2ZW50cyA9IHN0b3JhZ2UuZ2V0VGltZUJsb2NrcygpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEhhbmRsZSB0cmFuc3BvcnRhdGlvbiBpZiBuZWVkZWRcbiAgICAgICAgICBsZXQgdHJhbnNwb3J0RGV0YWlscyA9IG51bGw7XG4gICAgICAgICAgaWYgKHBhcmFtcy5uZWVkc1RyYW5zcG9ydCAmJiBwYXJhbXMubG9jYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHRheGlTZXJ2aWNlID0gVGF4aVNlcnZpY2UuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlID0gYXdhaXQgdGF4aVNlcnZpY2UuZXN0aW1hdGVUcmlwKCdjdXJyZW50X2xvY2F0aW9uJywgcGFyYW1zLmxvY2F0aW9uKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGVzdGltYXRlLmF2YWlsYWJsZSkge1xuICAgICAgICAgICAgICAvLyBBZGQgYnVmZmVyIHRpbWUgZm9yIHRyYW5zcG9ydGF0aW9uXG4gICAgICAgICAgICAgIGNvbnN0IHBpY2t1cFRpbWUgPSBuZXcgRGF0ZShzdGFydFRpbWUuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgICAgcGlja3VwVGltZS5zZXRNaW51dGVzKHBpY2t1cFRpbWUuZ2V0TWludXRlcygpIC0gZXN0aW1hdGUuZHVyYXRpb24pO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgY29uc3Qgc2NoZWR1bGVkRXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgX2lkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBwYXJhbXMudGl0bGUsXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lOiBwaWNrdXBUaW1lLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZW5kVGltZTogZW5kVGltZS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIHByaW9yaXR5OiBwYXJhbXMucHJpb3JpdHkgfHwgXCJpbXBvcnRhbnRcIixcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogcGFyYW1zLmxvY2F0aW9uLFxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydERldGFpbHMsXG4gICAgICAgICAgICAgICAgZGVsZWdhdGFibGU6IHBhcmFtcy5kZWxlZ2F0YWJsZSB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdzY2hlZHVsZWQnLFxuICAgICAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAvLyBHZXQgcGF5bWVudCBkZXRhaWxzXG4gICAgICAgICAgICAgIGNvbnN0IHBheW1lbnREZXRhaWxzID0gYXdhaXQgdGF4aVNlcnZpY2UuZ2V0UGF5bWVudERldGFpbHMoJ2N1cnJlbnRfbG9jYXRpb24nLCBwYXJhbXMubG9jYXRpb24pO1xuICAgICAgICAgICAgICBtZXNzYWdlQ29udGVudCA9IGDwn5OFIEV2ZW50IFNjaGVkdWxlZDogJHtwYXJhbXMudGl0bGV9XG7ij7AgVGltZTogJHtzdGFydFRpbWUudG9Mb2NhbGVTdHJpbmcoKX0gLSAke2VuZFRpbWUudG9Mb2NhbGVTdHJpbmcoKX1cbvCfk40gTG9jYXRpb246ICR7cGFyYW1zLmxvY2F0aW9ufVxu8J+alSBUcmFuc3BvcnQ6IFRheGkgYm9va2VkIGZvciAke2VzdGltYXRlLmR1cmF0aW9ufSBtaW51dGVzIGJlZm9yZSBldmVudFxu8J+SsCBQYXltZW50OiAke3BheW1lbnREZXRhaWxzLnR4SGFzaCA/ICdQcm9jZXNzaW5nLi4uJyA6ICdQZW5kaW5nJ31cbiR7cGF5bWVudERldGFpbHMudHhIYXNoID8gYFRyYW5zYWN0aW9uOiAke3BheW1lbnREZXRhaWxzLnR4SGFzaH1gIDogJyd9YDtcblxuICAgICAgICAgICAgICBjb25zdCBmaW5hbEV2ZW50ID0gaGFuZGxlU2NoZWR1bGVDb25mbGljdChzY2hlZHVsZWRFdmVudCwgZXhpc3RpbmdFdmVudHMpO1xuICAgICAgICAgICAgICBzdG9yYWdlLmFkZFRpbWVCbG9jayhmaW5hbEV2ZW50KTtcblxuICAgICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnY2FsZW5kYXJVcGRhdGUnLCB7XG4gICAgICAgICAgICAgICAgZGV0YWlsOiBmaW5hbEV2ZW50XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBtZXNzYWdlIHRvIGNoYXQgaGlzdG9yeVxuICAgICAgc2V0TWVzc2FnZXMocHJldiA9PiBbLi4ucHJldiwge1xuICAgICAgICBjb250ZW50OiBtZXNzYWdlQ29udGVudCxcbiAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9XSk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gc2VuZE1lc3NhZ2U6JywgZXJyb3IpO1xuICAgICAgc2V0TWVzc2FnZXMocHJldiA9PiBbLi4ucHJldiwge1xuICAgICAgICBjb250ZW50OiBgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgICByb2xlOiAnc3lzdGVtJyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH1dKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlcyxcbiAgICBzZXRNZXNzYWdlcyxcbiAgICBpc0xvYWRpbmcsXG4gICAgc2VuZE1lc3NhZ2VcbiAgfTtcbn0gIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiaW5pdGlhbGl6ZUFnZW50IiwiU3RvcmFnZVNlcnZpY2UiLCJUYXhpU2VydmljZSIsInVzZUNoYXRib3QiLCJtZXNzYWdlcyIsInNldE1lc3NhZ2VzIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwic2F2ZWRNZXNzYWdlcyIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJKU09OIiwicGFyc2UiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiaGFuZGxlU2NoZWR1bGVDb25mbGljdCIsIm5ld0V2ZW50IiwiZXhpc3RpbmdFdmVudHMiLCJjb25zb2xlIiwibG9nIiwidGl0bGUiLCJzdGFydCIsInN0YXJ0VGltZSIsInByaW9yaXR5IiwicHJpb3JpdHlPcmRlciIsImNvbmZsaWN0cyIsImZpbHRlciIsImV2ZW50IiwibmV3U3RhcnQiLCJEYXRlIiwibmV3RW5kIiwiZW5kVGltZSIsImV2ZW50U3RhcnQiLCJldmVudEVuZCIsImhhc0NvbmZsaWN0IiwiZXhpc3RpbmdFdmVudCIsImV4aXN0aW5nUHJpb3JpdHkiLCJuZXdQcmlvcml0eSIsImxlbmd0aCIsIm5ld1ByaW9yaXR5U2NvcmUiLCJoaWdoZXN0Q29uZmxpY3RTY29yZSIsIk1hdGgiLCJtYXgiLCJtYXAiLCJlIiwibmV3RXZlbnRTY29yZSIsIndpbGxSZXNjaGVkdWxlQ29uZmxpY3RzIiwic3RvcmFnZSIsImdldEluc3RhbmNlIiwiZm9yRWFjaCIsImNvbmZsaWN0IiwiZHVyYXRpb24iLCJnZXRUaW1lIiwibmV3U3RhcnRUaW1lIiwibmV3RW5kVGltZSIsInVwZGF0ZWRFdmVudCIsInRvSVNPU3RyaW5nIiwiZnJvbSIsInRvIiwidXBkYXRlVGltZUJsb2NrIiwibGFzdENvbmZsaWN0Iiwic29ydCIsImEiLCJiIiwicmVzY2hlZHVsZWRFdmVudCIsInBhcnNlVGltZVN0cmluZyIsInRpbWVTdHIiLCJkYXRlIiwiaXNOYU4iLCJ0b2RheSIsInRpbWVSZWdleCIsIm1hdGNoIiwiXyIsImhvdXJzIiwibWludXRlcyIsIm1lcmlkaWVtIiwiaG91ciIsInBhcnNlSW50IiwidG9VcHBlckNhc2UiLCJzZXRIb3VycyIsIkVycm9yIiwicGFyc2VEYXRlIiwiZGF0ZVN0ciIsImVycm9yIiwic2VuZE1lc3NhZ2UiLCJjb250ZW50IiwiYWdlbnQiLCJwcm9tcHQiLCJmdW5jdGlvbkhhbmRsZXJzIiwiZm9ybWF0dGVkUHJvbXB0IiwiZm9ybWF0TWVzc2FnZXMiLCJpbnB1dCIsInJlc3BvbnNlIiwiaW52b2tlIiwibWVzc2FnZUNvbnRlbnQiLCJjb2RlQmxvY2tNYXRjaCIsInBhcmFtc1RleHQiLCJwYXJhbXMiLCJsb2NhdGlvbiIsIm5lZWRzVHJhbnNwb3J0IiwiaW5jbHVkZXMiLCJkZWxlZ2F0YWJsZSIsImdldFRpbWVCbG9ja3MiLCJ0cmFuc3BvcnREZXRhaWxzIiwidGF4aVNlcnZpY2UiLCJlc3RpbWF0ZSIsImVzdGltYXRlVHJpcCIsImF2YWlsYWJsZSIsInBpY2t1cFRpbWUiLCJzZXRNaW51dGVzIiwiZ2V0TWludXRlcyIsInNjaGVkdWxlZEV2ZW50IiwiX2lkIiwiY3J5cHRvIiwicmFuZG9tVVVJRCIsInN0YXR1cyIsImNyZWF0ZWRfYXQiLCJ1cGRhdGVkX2F0IiwicGF5bWVudERldGFpbHMiLCJnZXRQYXltZW50RGV0YWlscyIsInRvTG9jYWxlU3RyaW5nIiwidHhIYXNoIiwiZmluYWxFdmVudCIsImFkZFRpbWVCbG9jayIsIkN1c3RvbUV2ZW50IiwiZGV0YWlsIiwid2luZG93IiwiZGlzcGF0Y2hFdmVudCIsInByZXYiLCJyb2xlIiwidGltZXN0YW1wIiwibWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useChatbot.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/services/chatbot.ts":
/*!*********************************!*\
  !*** ./src/services/chatbot.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initializeAgent: function() { return /* binding */ initializeAgent; }\n/* harmony export */ });\n/* harmony import */ var _langchain_google_genai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/google-genai */ \"(app-pages-browser)/../../../node_modules/@langchain/google-genai/index.js\");\n/* harmony import */ var _langchain_core_prompts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @langchain/core/prompts */ \"(app-pages-browser)/../../../node_modules/@langchain/core/prompts.js\");\n/* harmony import */ var _taxiService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./taxiService */ \"(app-pages-browser)/./src/services/taxiService.ts\");\n\n\n\nasync function initializeAgent() {\n    try {\n        console.log(\"Initializing Google AI...\");\n        // Create the model\n        const model = new _langchain_google_genai__WEBPACK_IMPORTED_MODULE_0__.ChatGoogleGenerativeAI({\n            apiKey: \"AIzaSyDJcsRmDoYaG1na_gg7z9-WoSTe82sXwPA\",\n            modelName: \"gemini-pro\",\n            temperature: 0.7\n        });\n        // Create a prompt template with specific format instructions\n        const prompt = _langchain_core_prompts__WEBPACK_IMPORTED_MODULE_1__.ChatPromptTemplate.fromMessages([\n            [\n                \"system\",\n                'You are a helpful assistant that schedules events and handles transportation. Format your responses clearly:\\n\\n      1. First confirm the event details:\\n         ```\\n         schedule_task(\\n           title=\"[title]\",\\n           startTime=\"YYYY-MM-DDTHH:mm:ss\",\\n           endTime=\"YYYY-MM-DDTHH:mm:ss\",\\n           priority=\"[priority]\",\\n           location=\"[location]\",\\n           needsTransport=[true/false]\\n         )\\n         ```\\n\\n      2. If transport is needed:\\n         ```\\n         book_taxi(\\n           pickup=\"[location]\",\\n           destination=\"[location]\",\\n           pickupTime=\"HH:mm\"\\n         )\\n         ```\\n\\n      3. After booking, verify payment:\\n         ```\\n         verify_payment(txHash=\"[hash]\")\\n         ```\\n\\n      Respond in this format:\\n      \\uD83D\\uDCC5 Event Scheduled: [title]\\n      ⏰ Time: [start] - [end]\\n      \\uD83D\\uDCCD Location: [location]\\n      \\uD83D\\uDE95 Transport: [details if needed]\\n      \\uD83D\\uDCB0 Payment: [status]\\n      \\n      Keep responses concise and well-formatted.\\n      For times, you can use either ISO format (YYYY-MM-DDTHH:mm:ss) or 12-hour format (HH:mm AM/PM).'\n            ],\n            [\n                \"human\",\n                \"{input}\"\n            ]\n        ]);\n        // Create function handlers\n        const functionHandlers = {\n            async book_taxi (params) {\n                const taxiService = _taxiService__WEBPACK_IMPORTED_MODULE_2__.TaxiService.getInstance();\n                const paymentDetails = await taxiService.getPaymentDetails(params.pickup, params.destination);\n                return paymentDetails;\n            },\n            async verify_payment (params) {\n                const taxiService = _taxiService__WEBPACK_IMPORTED_MODULE_2__.TaxiService.getInstance();\n                const verified = await taxiService.verifyPayment(params.txHash);\n                return verified;\n            }\n        };\n        console.log(\"Google AI initialized\");\n        return {\n            agent: model,\n            prompt,\n            functionHandlers,\n            config: {}\n        };\n    } catch (error) {\n        console.error(\"Error initializing agent:\", error);\n        throw error;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy9jaGF0Ym90LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBaUU7QUFDSjtBQUNqQjtBQUVyQyxlQUFlRztJQUNwQixJQUFJO1FBQ0ZDLFFBQVFDLEdBQUcsQ0FBQztRQUVaLG1CQUFtQjtRQUNuQixNQUFNQyxRQUFRLElBQUlOLDJFQUFzQkEsQ0FBQztZQUN2Q08sUUFBUUMseUNBQXNDO1lBQzlDRyxXQUFXO1lBQ1hDLGFBQWE7UUFDZjtRQUVBLDZEQUE2RDtRQUM3RCxNQUFNQyxTQUFTWix1RUFBa0JBLENBQUNhLFlBQVksQ0FBQztZQUM3QztnQkFBQztnQkFBVzthQW9DcUY7WUFDakc7Z0JBQUM7Z0JBQVM7YUFBVTtTQUNyQjtRQUVELDJCQUEyQjtRQUMzQixNQUFNQyxtQkFBbUI7WUFDdkIsTUFBTUMsV0FBVUMsTUFBVztnQkFDekIsTUFBTUMsY0FBY2hCLHFEQUFXQSxDQUFDaUIsV0FBVztnQkFDM0MsTUFBTUMsaUJBQWlCLE1BQU1GLFlBQVlHLGlCQUFpQixDQUN4REosT0FBT0ssTUFBTSxFQUNiTCxPQUFPTSxXQUFXO2dCQUVwQixPQUFPSDtZQUNUO1lBQ0EsTUFBTUksZ0JBQWVQLE1BQVc7Z0JBQzlCLE1BQU1DLGNBQWNoQixxREFBV0EsQ0FBQ2lCLFdBQVc7Z0JBQzNDLE1BQU1NLFdBQVcsTUFBTVAsWUFBWVEsYUFBYSxDQUFDVCxPQUFPVSxNQUFNO2dCQUM5RCxPQUFPRjtZQUNUO1FBQ0Y7UUFFQXJCLFFBQVFDLEdBQUcsQ0FBQztRQUVaLE9BQU87WUFDTHVCLE9BQU90QjtZQUNQTztZQUNBRTtZQUNBYyxRQUFRLENBQUM7UUFDWDtJQUNGLEVBQUUsT0FBT0MsT0FBTztRQUNkMUIsUUFBUTBCLEtBQUssQ0FBQyw2QkFBNkJBO1FBQzNDLE1BQU1BO0lBQ1I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvc2VydmljZXMvY2hhdGJvdC50cz82NTliIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYXRHb29nbGVHZW5lcmF0aXZlQUkgfSBmcm9tIFwiQGxhbmdjaGFpbi9nb29nbGUtZ2VuYWlcIjtcbmltcG9ydCB7IENoYXRQcm9tcHRUZW1wbGF0ZSB9IGZyb20gXCJAbGFuZ2NoYWluL2NvcmUvcHJvbXB0c1wiO1xuaW1wb3J0IHsgVGF4aVNlcnZpY2UgfSBmcm9tICcuL3RheGlTZXJ2aWNlJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXRpYWxpemVBZ2VudCgpIHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnSW5pdGlhbGl6aW5nIEdvb2dsZSBBSS4uLicpO1xuICAgIFxuICAgIC8vIENyZWF0ZSB0aGUgbW9kZWxcbiAgICBjb25zdCBtb2RlbCA9IG5ldyBDaGF0R29vZ2xlR2VuZXJhdGl2ZUFJKHtcbiAgICAgIGFwaUtleTogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfR09PR0xFX0FQSV9LRVksXG4gICAgICBtb2RlbE5hbWU6IFwiZ2VtaW5pLXByb1wiLFxuICAgICAgdGVtcGVyYXR1cmU6IDAuNyxcbiAgICB9KTtcblxuICAgIC8vIENyZWF0ZSBhIHByb21wdCB0ZW1wbGF0ZSB3aXRoIHNwZWNpZmljIGZvcm1hdCBpbnN0cnVjdGlvbnNcbiAgICBjb25zdCBwcm9tcHQgPSBDaGF0UHJvbXB0VGVtcGxhdGUuZnJvbU1lc3NhZ2VzKFtcbiAgICAgIFtcInN5c3RlbVwiLCBgWW91IGFyZSBhIGhlbHBmdWwgYXNzaXN0YW50IHRoYXQgc2NoZWR1bGVzIGV2ZW50cyBhbmQgaGFuZGxlcyB0cmFuc3BvcnRhdGlvbi4gRm9ybWF0IHlvdXIgcmVzcG9uc2VzIGNsZWFybHk6XG5cbiAgICAgIDEuIEZpcnN0IGNvbmZpcm0gdGhlIGV2ZW50IGRldGFpbHM6XG4gICAgICAgICBcXGBcXGBcXGBcbiAgICAgICAgIHNjaGVkdWxlX3Rhc2soXG4gICAgICAgICAgIHRpdGxlPVwiW3RpdGxlXVwiLFxuICAgICAgICAgICBzdGFydFRpbWU9XCJZWVlZLU1NLUREVEhIOm1tOnNzXCIsXG4gICAgICAgICAgIGVuZFRpbWU9XCJZWVlZLU1NLUREVEhIOm1tOnNzXCIsXG4gICAgICAgICAgIHByaW9yaXR5PVwiW3ByaW9yaXR5XVwiLFxuICAgICAgICAgICBsb2NhdGlvbj1cIltsb2NhdGlvbl1cIixcbiAgICAgICAgICAgbmVlZHNUcmFuc3BvcnQ9W3RydWUvZmFsc2VdXG4gICAgICAgICApXG4gICAgICAgICBcXGBcXGBcXGBcblxuICAgICAgMi4gSWYgdHJhbnNwb3J0IGlzIG5lZWRlZDpcbiAgICAgICAgIFxcYFxcYFxcYFxuICAgICAgICAgYm9va190YXhpKFxuICAgICAgICAgICBwaWNrdXA9XCJbbG9jYXRpb25dXCIsXG4gICAgICAgICAgIGRlc3RpbmF0aW9uPVwiW2xvY2F0aW9uXVwiLFxuICAgICAgICAgICBwaWNrdXBUaW1lPVwiSEg6bW1cIlxuICAgICAgICAgKVxuICAgICAgICAgXFxgXFxgXFxgXG5cbiAgICAgIDMuIEFmdGVyIGJvb2tpbmcsIHZlcmlmeSBwYXltZW50OlxuICAgICAgICAgXFxgXFxgXFxgXG4gICAgICAgICB2ZXJpZnlfcGF5bWVudCh0eEhhc2g9XCJbaGFzaF1cIilcbiAgICAgICAgIFxcYFxcYFxcYFxuXG4gICAgICBSZXNwb25kIGluIHRoaXMgZm9ybWF0OlxuICAgICAg8J+ThSBFdmVudCBTY2hlZHVsZWQ6IFt0aXRsZV1cbiAgICAgIOKPsCBUaW1lOiBbc3RhcnRdIC0gW2VuZF1cbiAgICAgIPCfk40gTG9jYXRpb246IFtsb2NhdGlvbl1cbiAgICAgIPCfmpUgVHJhbnNwb3J0OiBbZGV0YWlscyBpZiBuZWVkZWRdXG4gICAgICDwn5KwIFBheW1lbnQ6IFtzdGF0dXNdXG4gICAgICBcbiAgICAgIEtlZXAgcmVzcG9uc2VzIGNvbmNpc2UgYW5kIHdlbGwtZm9ybWF0dGVkLlxuICAgICAgRm9yIHRpbWVzLCB5b3UgY2FuIHVzZSBlaXRoZXIgSVNPIGZvcm1hdCAoWVlZWS1NTS1ERFRISDptbTpzcykgb3IgMTItaG91ciBmb3JtYXQgKEhIOm1tIEFNL1BNKS5gXSxcbiAgICAgIFtcImh1bWFuXCIsIFwie2lucHV0fVwiXVxuICAgIF0pO1xuXG4gICAgLy8gQ3JlYXRlIGZ1bmN0aW9uIGhhbmRsZXJzXG4gICAgY29uc3QgZnVuY3Rpb25IYW5kbGVycyA9IHtcbiAgICAgIGFzeW5jIGJvb2tfdGF4aShwYXJhbXM6IGFueSkge1xuICAgICAgICBjb25zdCB0YXhpU2VydmljZSA9IFRheGlTZXJ2aWNlLmdldEluc3RhbmNlKCk7XG4gICAgICAgIGNvbnN0IHBheW1lbnREZXRhaWxzID0gYXdhaXQgdGF4aVNlcnZpY2UuZ2V0UGF5bWVudERldGFpbHMoXG4gICAgICAgICAgcGFyYW1zLnBpY2t1cCxcbiAgICAgICAgICBwYXJhbXMuZGVzdGluYXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHBheW1lbnREZXRhaWxzO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIHZlcmlmeV9wYXltZW50KHBhcmFtczogYW55KSB7XG4gICAgICAgIGNvbnN0IHRheGlTZXJ2aWNlID0gVGF4aVNlcnZpY2UuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgY29uc3QgdmVyaWZpZWQgPSBhd2FpdCB0YXhpU2VydmljZS52ZXJpZnlQYXltZW50KHBhcmFtcy50eEhhc2gpO1xuICAgICAgICByZXR1cm4gdmVyaWZpZWQ7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnNvbGUubG9nKCdHb29nbGUgQUkgaW5pdGlhbGl6ZWQnKTtcblxuICAgIHJldHVybiB7XG4gICAgICBhZ2VudDogbW9kZWwsXG4gICAgICBwcm9tcHQsXG4gICAgICBmdW5jdGlvbkhhbmRsZXJzLFxuICAgICAgY29uZmlnOiB7fVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5pdGlhbGl6aW5nIGFnZW50OicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufSJdLCJuYW1lcyI6WyJDaGF0R29vZ2xlR2VuZXJhdGl2ZUFJIiwiQ2hhdFByb21wdFRlbXBsYXRlIiwiVGF4aVNlcnZpY2UiLCJpbml0aWFsaXplQWdlbnQiLCJjb25zb2xlIiwibG9nIiwibW9kZWwiLCJhcGlLZXkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfR09PR0xFX0FQSV9LRVkiLCJtb2RlbE5hbWUiLCJ0ZW1wZXJhdHVyZSIsInByb21wdCIsImZyb21NZXNzYWdlcyIsImZ1bmN0aW9uSGFuZGxlcnMiLCJib29rX3RheGkiLCJwYXJhbXMiLCJ0YXhpU2VydmljZSIsImdldEluc3RhbmNlIiwicGF5bWVudERldGFpbHMiLCJnZXRQYXltZW50RGV0YWlscyIsInBpY2t1cCIsImRlc3RpbmF0aW9uIiwidmVyaWZ5X3BheW1lbnQiLCJ2ZXJpZmllZCIsInZlcmlmeVBheW1lbnQiLCJ0eEhhc2giLCJhZ2VudCIsImNvbmZpZyIsImVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/chatbot.ts\n"));

/***/ })

});