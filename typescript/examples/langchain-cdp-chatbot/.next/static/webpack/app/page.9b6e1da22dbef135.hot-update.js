"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useChatbot.ts":
/*!*********************************!*\
  !*** ./src/hooks/useChatbot.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChatbot: function() { return /* binding */ useChatbot; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _services_chatbot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/services/chatbot */ \"(app-pages-browser)/./src/services/chatbot.ts\");\n/* harmony import */ var _lib_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/storage */ \"(app-pages-browser)/./src/lib/storage.ts\");\n/* harmony import */ var _services_taxiService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/taxiService */ \"(app-pages-browser)/./src/services/taxiService.ts\");\n/* __next_internal_client_entry_do_not_use__ useChatbot auto */ \n\n\n\nfunction useChatbot() {\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Load chat history from localStorage on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const savedMessages = localStorage.getItem(\"chat_history\");\n        if (savedMessages) {\n            setMessages(JSON.parse(savedMessages));\n        }\n    }, []);\n    // Save messages to localStorage whenever they change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        localStorage.setItem(\"chat_history\", JSON.stringify(messages));\n    }, [\n        messages\n    ]);\n    const handleScheduleConflict = (newEvent, existingEvents)=>{\n        console.log(\"Checking conflicts for new event:\", {\n            title: newEvent.title,\n            start: newEvent.startTime,\n            priority: newEvent.priority\n        });\n        console.log(\"Existing events:\", existingEvents);\n        // Sort existing events by priority\n        const priorityOrder = {\n            \"urgent-important\": 3,\n            \"important\": 2,\n            \"urgent\": 1,\n            \"neither\": 0\n        };\n        // Find conflicting events\n        const conflicts = existingEvents.filter((event)=>{\n            const newStart = new Date(newEvent.startTime);\n            const newEnd = new Date(newEvent.endTime);\n            const eventStart = new Date(event.startTime);\n            const eventEnd = new Date(event.endTime);\n            const hasConflict = newStart >= eventStart && newStart < eventEnd || newEnd > eventStart && newEnd <= eventEnd || newStart <= eventStart && newEnd >= eventEnd;\n            if (hasConflict) {\n                console.log(\"Found conflict:\", {\n                    existingEvent: event.title,\n                    existingPriority: event.priority,\n                    newEvent: newEvent.title,\n                    newPriority: newEvent.priority\n                });\n            }\n            return hasConflict;\n        });\n        if (conflicts.length === 0) {\n            console.log(\"No conflicts found\");\n            return newEvent;\n        }\n        // Check if new event has higher priority\n        const newPriorityScore = priorityOrder[newEvent.priority];\n        const highestConflictScore = Math.max(...conflicts.map((e)=>priorityOrder[e.priority]));\n        console.log(\"Priority comparison:\", {\n            newEventScore: newPriorityScore,\n            highestConflictScore,\n            willRescheduleConflicts: newPriorityScore > highestConflictScore\n        });\n        if (newPriorityScore > highestConflictScore) {\n            // Move conflicting events\n            console.log(\"Moving conflicting events...\");\n            const storage = _lib_storage__WEBPACK_IMPORTED_MODULE_2__.StorageService.getInstance();\n            conflicts.forEach((conflict)=>{\n                // Move to next available time\n                const duration = new Date(conflict.endTime).getTime() - new Date(conflict.startTime).getTime();\n                const newStartTime = new Date(newEvent.endTime);\n                const newEndTime = new Date(newStartTime.getTime() + duration);\n                const updatedEvent = {\n                    ...conflict,\n                    startTime: newStartTime.toISOString(),\n                    endTime: newEndTime.toISOString()\n                };\n                console.log(\"Moving event:\", {\n                    event: conflict.title,\n                    from: conflict.startTime,\n                    to: updatedEvent.startTime\n                });\n                storage.updateTimeBlock(updatedEvent);\n            });\n            return newEvent;\n        } else {\n            // Find next available time for new event\n            console.log(\"Finding next available time for new event...\");\n            const duration = new Date(newEvent.endTime).getTime() - new Date(newEvent.startTime).getTime();\n            const lastConflict = conflicts.sort((a, b)=>new Date(b.endTime).getTime() - new Date(a.endTime).getTime())[0];\n            const newStartTime = new Date(lastConflict.endTime);\n            const newEndTime = new Date(newStartTime.getTime() + duration);\n            const rescheduledEvent = {\n                ...newEvent,\n                startTime: newStartTime.toISOString(),\n                endTime: newEndTime.toISOString()\n            };\n            console.log(\"Rescheduled new event:\", {\n                from: newEvent.startTime,\n                to: rescheduledEvent.startTime\n            });\n            return rescheduledEvent;\n        }\n    };\n    const sendMessage = async (content)=>{\n        console.log(\"=== START sendMessage ===\");\n        setIsLoading(true);\n        try {\n            // Initialize agent\n            console.log(\"Initializing agent...\");\n            const { agent, prompt, functionHandlers } = await (0,_services_chatbot__WEBPACK_IMPORTED_MODULE_1__.initializeAgent)();\n            console.log(\"Agent initialized successfully\");\n            // Format the prompt\n            const formattedPrompt = await prompt.formatMessages({\n                input: content\n            });\n            // Call agent\n            console.log(\"Calling agent...\");\n            const response = await agent.invoke(formattedPrompt);\n            console.log(\"Agent response received:\", response);\n            // Extract content\n            let messageContent = response.content;\n            // Look for schedule task\n            const codeBlockMatch = messageContent.match(/```[\\s\\S]*?schedule_task\\(([\\s\\S]*?)\\)[\\s\\S]*?```/);\n            if (codeBlockMatch) {\n                const paramsText = codeBlockMatch[1];\n                const params = {\n                    title: (paramsText.match(/title=\"([^\"]+)\"/) || [])[1],\n                    startTime: (paramsText.match(/startTime=\"([^\"]+)\"/) || [])[1],\n                    endTime: (paramsText.match(/endTime=\"([^\"]+)\"/) || [])[1],\n                    priority: (paramsText.match(/priority=\"([^\"]+)\"/) || [])[1],\n                    location: (paramsText.match(/location=\"([^\"]+)\"/) || [])[1],\n                    needsTransport: paramsText.includes(\"needsTransport=True\"),\n                    delegatable: paramsText.includes(\"delegatable=True\")\n                };\n                if (params.title && params.startTime) {\n                    // Validate and parse dates\n                    const parseDate = (dateStr)=>{\n                        try {\n                            const date = new Date(dateStr);\n                            if (isNaN(date.getTime())) {\n                                throw new Error(\"Invalid date: \".concat(dateStr));\n                            }\n                            return date;\n                        } catch (error) {\n                            console.error(\"Date parsing error:\", error);\n                            throw new Error(\"Invalid date format: \".concat(dateStr));\n                        }\n                    };\n                    const startTime = parseDate(params.startTime);\n                    const endTime = params.endTime ? parseDate(params.endTime) : new Date(startTime.getTime() + 60 * 60 * 1000);\n                    const storage = _lib_storage__WEBPACK_IMPORTED_MODULE_2__.StorageService.getInstance();\n                    const existingEvents = storage.getTimeBlocks();\n                    // Handle transportation if needed\n                    let transportDetails = null;\n                    if (params.needsTransport && params.location) {\n                        const taxiService = _services_taxiService__WEBPACK_IMPORTED_MODULE_3__.TaxiService.getInstance();\n                        const estimate = await taxiService.estimateTrip(\"current_location\", params.location);\n                        if (estimate.available) {\n                            // Add buffer time for transportation\n                            const pickupTime = new Date(startTime.getTime());\n                            pickupTime.setMinutes(pickupTime.getMinutes() - estimate.duration);\n                            const scheduledEvent = {\n                                _id: crypto.randomUUID(),\n                                title: params.title,\n                                startTime: pickupTime.toISOString(),\n                                endTime: endTime.toISOString(),\n                                priority: params.priority || \"important\",\n                                location: params.location,\n                                transportDetails,\n                                delegatable: params.delegatable || false,\n                                status: \"scheduled\",\n                                created_at: new Date().toISOString(),\n                                updated_at: new Date().toISOString()\n                            };\n                            // Get payment details\n                            const paymentDetails = await taxiService.getPaymentDetails(\"current_location\", params.location);\n                            messageContent = \"\\uD83D\\uDCC5 Event Scheduled: \".concat(params.title, \"\\n⏰ Time: \").concat(startTime.toLocaleString(), \" - \").concat(endTime.toLocaleString(), \"\\n\\uD83D\\uDCCD Location: \").concat(params.location, \"\\n\\uD83D\\uDE95 Transport: Taxi booked for \").concat(estimate.duration, \" minutes before event\\n\\uD83D\\uDCB0 Payment: \").concat(paymentDetails.txHash ? \"Processing...\" : \"Pending\", \"\\n\").concat(paymentDetails.txHash ? \"Transaction: \".concat(paymentDetails.txHash) : \"\");\n                            const finalEvent = handleScheduleConflict(scheduledEvent, existingEvents);\n                            storage.addTimeBlock(finalEvent);\n                            const event = new CustomEvent(\"calendarUpdate\", {\n                                detail: finalEvent\n                            });\n                            window.dispatchEvent(event);\n                        }\n                    }\n                }\n            }\n            // Add message to chat history\n            setMessages((prev)=>[\n                    ...prev,\n                    {\n                        content: messageContent,\n                        role: \"assistant\",\n                        timestamp: new Date().toISOString()\n                    }\n                ]);\n        } catch (error) {\n            console.error(\"Error in sendMessage:\", error);\n            setMessages((prev)=>[\n                    ...prev,\n                    {\n                        content: \"Error: \".concat(error.message),\n                        role: \"system\",\n                        timestamp: new Date().toISOString()\n                    }\n                ]);\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    return {\n        messages,\n        setMessages,\n        isLoading,\n        sendMessage\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VDaGF0Ym90LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztnRUFFNEM7QUFDUztBQUNOO0FBQ007QUFFOUMsU0FBU0s7SUFDZCxNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR1AsK0NBQVFBLENBQVEsRUFBRTtJQUNsRCxNQUFNLENBQUNRLFdBQVdDLGFBQWEsR0FBR1QsK0NBQVFBLENBQUM7SUFFM0MsK0NBQStDO0lBQy9DQyxnREFBU0EsQ0FBQztRQUNSLE1BQU1TLGdCQUFnQkMsYUFBYUMsT0FBTyxDQUFDO1FBQzNDLElBQUlGLGVBQWU7WUFDakJILFlBQVlNLEtBQUtDLEtBQUssQ0FBQ0o7UUFDekI7SUFDRixHQUFHLEVBQUU7SUFFTCxxREFBcUQ7SUFDckRULGdEQUFTQSxDQUFDO1FBQ1JVLGFBQWFJLE9BQU8sQ0FBQyxnQkFBZ0JGLEtBQUtHLFNBQVMsQ0FBQ1Y7SUFDdEQsR0FBRztRQUFDQTtLQUFTO0lBRWIsTUFBTVcseUJBQXlCLENBQUNDLFVBQXFCQztRQUNuREMsUUFBUUMsR0FBRyxDQUFDLHFDQUFxQztZQUMvQ0MsT0FBT0osU0FBU0ksS0FBSztZQUNyQkMsT0FBT0wsU0FBU00sU0FBUztZQUN6QkMsVUFBVVAsU0FBU08sUUFBUTtRQUM3QjtRQUNBTCxRQUFRQyxHQUFHLENBQUMsb0JBQW9CRjtRQUVoQyxtQ0FBbUM7UUFDbkMsTUFBTU8sZ0JBQWdCO1lBQ3BCLG9CQUFvQjtZQUNwQixhQUFhO1lBQ2IsVUFBVTtZQUNWLFdBQVc7UUFDYjtRQUVBLDBCQUEwQjtRQUMxQixNQUFNQyxZQUFZUixlQUFlUyxNQUFNLENBQUNDLENBQUFBO1lBQ3RDLE1BQU1DLFdBQVcsSUFBSUMsS0FBS2IsU0FBU00sU0FBUztZQUM1QyxNQUFNUSxTQUFTLElBQUlELEtBQUtiLFNBQVNlLE9BQU87WUFDeEMsTUFBTUMsYUFBYSxJQUFJSCxLQUFLRixNQUFNTCxTQUFTO1lBQzNDLE1BQU1XLFdBQVcsSUFBSUos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LE9BQU8yQixXQUFXO29CQUNuQztpQkFBRTtRQUVKLEVBQUUsT0FBT2lDLE9BQU87WUFDZHZFLFFBQVF1RSxLQUFLLENBQUMseUJBQXlCQTtZQUN2Q3BGLFlBQVkrRyxDQUFBQSxPQUFRO3VCQUFJQTtvQkFBTTt3QkFDNUJsRCxTQUFTLFVBQXdCLE9BQWR1QixNQUFNOEIsT0FBTzt3QkFDaENGLE1BQU07d0JBQ05DLFdBQVcsSUFBSXpGLE9BQU8yQixXQUFXO29CQUNuQztpQkFBRTtRQUNKLFNBQVU7WUFDUmpELGFBQWE7UUFDZjtJQUNGO0lBRUEsT0FBTztRQUNMSDtRQUNBQztRQUNBQztRQUNBMkQ7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9ob29rcy91c2VDaGF0Ym90LnRzP2Q0NmYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaW5pdGlhbGl6ZUFnZW50IH0gZnJvbSAnQC9zZXJ2aWNlcy9jaGF0Ym90JztcbmltcG9ydCB7IFN0b3JhZ2VTZXJ2aWNlIH0gZnJvbSAnQC9saWIvc3RvcmFnZSc7XG5pbXBvcnQgeyBUYXhpU2VydmljZSB9IGZyb20gJ0Avc2VydmljZXMvdGF4aVNlcnZpY2UnO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hhdGJvdCgpIHtcbiAgY29uc3QgW21lc3NhZ2VzLCBzZXRNZXNzYWdlc10gPSB1c2VTdGF0ZTxhbnlbXT4oW10pO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIC8vIExvYWQgY2hhdCBoaXN0b3J5IGZyb20gbG9jYWxTdG9yYWdlIG9uIG1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgc2F2ZWRNZXNzYWdlcyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdjaGF0X2hpc3RvcnknKTtcbiAgICBpZiAoc2F2ZWRNZXNzYWdlcykge1xuICAgICAgc2V0TWVzc2FnZXMoSlNPTi5wYXJzZShzYXZlZE1lc3NhZ2VzKSk7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgLy8gU2F2ZSBtZXNzYWdlcyB0byBsb2NhbFN0b3JhZ2Ugd2hlbmV2ZXIgdGhleSBjaGFuZ2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnY2hhdF9oaXN0b3J5JywgSlNPTi5zdHJpbmdpZnkobWVzc2FnZXMpKTtcbiAgfSwgW21lc3NhZ2VzXSk7XG5cbiAgY29uc3QgaGFuZGxlU2NoZWR1bGVDb25mbGljdCA9IChuZXdFdmVudDogVGltZUJsb2NrLCBleGlzdGluZ0V2ZW50czogVGltZUJsb2NrW10pID0+IHtcbiAgICBjb25zb2xlLmxvZygnQ2hlY2tpbmcgY29uZmxpY3RzIGZvciBuZXcgZXZlbnQ6Jywge1xuICAgICAgdGl0bGU6IG5ld0V2ZW50LnRpdGxlLFxuICAgICAgc3RhcnQ6IG5ld0V2ZW50LnN0YXJ0VGltZSxcbiAgICAgIHByaW9yaXR5OiBuZXdFdmVudC5wcmlvcml0eVxuICAgIH0pO1xuICAgIGNvbnNvbGUubG9nKCdFeGlzdGluZyBldmVudHM6JywgZXhpc3RpbmdFdmVudHMpO1xuXG4gICAgLy8gU29ydCBleGlzdGluZyBldmVudHMgYnkgcHJpb3JpdHlcbiAgICBjb25zdCBwcmlvcml0eU9yZGVyID0ge1xuICAgICAgJ3VyZ2VudC1pbXBvcnRhbnQnOiAzLFxuICAgICAgJ2ltcG9ydGFudCc6IDIsXG4gICAgICAndXJnZW50JzogMSxcbiAgICAgICduZWl0aGVyJzogMFxuICAgIH07XG5cbiAgICAvLyBGaW5kIGNvbmZsaWN0aW5nIGV2ZW50c1xuICAgIGNvbnN0IGNvbmZsaWN0cyA9IGV4aXN0aW5nRXZlbnRzLmZpbHRlcihldmVudCA9PiB7XG4gICAgICBjb25zdCBuZXdTdGFydCA9IG5ldyBEYXRlKG5ld0V2ZW50LnN0YXJ0VGltZSk7XG4gICAgICBjb25zdCBuZXdFbmQgPSBuZXcgRGF0ZShuZXdFdmVudC5lbmRUaW1lKTtcbiAgICAgIGNvbnN0IGV2ZW50U3RhcnQgPSBuZXcgRGF0ZShldmVudC5zdGFydFRpbWUpO1xuICAgICAgY29uc3QgZXZlbnRFbmQgPSBuZXcgRGF0ZShldmVudC5lbmRUaW1lKTtcbiAgICAgIFxuICAgICAgY29uc3QgaGFzQ29uZmxpY3QgPSAoXG4gICAgICAgIChuZXdTdGFydCA+PSBldmVudFN0YXJ0ICYmIG5ld1N0YXJ0IDwgZXZlbnRFbmQpIHx8XG4gICAgICAgIChuZXdFbmQgPiBldmVudFN0YXJ0ICYmIG5ld0VuZCA8PSBldmVudEVuZCkgfHxcbiAgICAgICAgKG5ld1N0YXJ0IDw9IGV2ZW50U3RhcnQgJiYgbmV3RW5kID49IGV2ZW50RW5kKVxuICAgICAgKTtcblxuICAgICAgaWYgKGhhc0NvbmZsaWN0KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBjb25mbGljdDonLCB7XG4gICAgICAgICAgZXhpc3RpbmdFdmVudDogZXZlbnQudGl0bGUsXG4gICAgICAgICAgZXhpc3RpbmdQcmlvcml0eTogZXZlbnQucHJpb3JpdHksXG4gICAgICAgICAgbmV3RXZlbnQ6IG5ld0V2ZW50LnRpdGxlLFxuICAgICAgICAgIG5ld1ByaW9yaXR5OiBuZXdFdmVudC5wcmlvcml0eVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGhhc0NvbmZsaWN0O1xuICAgIH0pO1xuXG4gICAgaWYgKGNvbmZsaWN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCdObyBjb25mbGljdHMgZm91bmQnKTtcbiAgICAgIHJldHVybiBuZXdFdmVudDtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBuZXcgZXZlbnQgaGFzIGhpZ2hlciBwcmlvcml0eVxuICAgIGNvbnN0IG5ld1ByaW9yaXR5U2NvcmUgPSBwcmlvcml0eU9yZGVyW25ld0V2ZW50LnByaW9yaXR5XTtcbiAgICBjb25zdCBoaWdoZXN0Q29uZmxpY3RTY29yZSA9IE1hdGgubWF4KFxuICAgICAgLi4uY29uZmxpY3RzLm1hcChlID0+IHByaW9yaXR5T3JkZXJbZS5wcmlvcml0eV0pXG4gICAgKTtcblxuICAgIGNvbnNvbGUubG9nKCdQcmlvcml0eSBjb21wYXJpc29uOicsIHtcbiAgICAgIG5ld0V2ZW50U2NvcmU6IG5ld1ByaW9yaXR5U2NvcmUsXG4gICAgICBoaWdoZXN0Q29uZmxpY3RTY29yZSxcbiAgICAgIHdpbGxSZXNjaGVkdWxlQ29uZmxpY3RzOiBuZXdQcmlvcml0eVNjb3JlID4gaGlnaGVzdENvbmZsaWN0U2NvcmVcbiAgICB9KTtcblxuICAgIGlmIChuZXdQcmlvcml0eVNjb3JlID4gaGlnaGVzdENvbmZsaWN0U2NvcmUpIHtcbiAgICAgIC8vIE1vdmUgY29uZmxpY3RpbmcgZXZlbnRzXG4gICAgICBjb25zb2xlLmxvZygnTW92aW5nIGNvbmZsaWN0aW5nIGV2ZW50cy4uLicpO1xuICAgICAgY29uc3Qgc3RvcmFnZSA9IFN0b3JhZ2VTZXJ2aWNlLmdldEluc3RhbmNlKCk7XG4gICAgICBjb25mbGljdHMuZm9yRWFjaChjb25mbGljdCA9PiB7XG4gICAgICAgIC8vIE1vdmUgdG8gbmV4dCBhdmFpbGFibGUgdGltZVxuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IG5ldyBEYXRlKGNvbmZsaWN0LmVuZFRpbWUpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGNvbmZsaWN0LnN0YXJ0VGltZSkuZ2V0VGltZSgpO1xuICAgICAgICBjb25zdCBuZXdTdGFydFRpbWUgPSBuZXcgRGF0ZShuZXdFdmVudC5lbmRUaW1lKTtcbiAgICAgICAgY29uc3QgbmV3RW5kVGltZSA9IG5ldyBEYXRlKG5ld1N0YXJ0VGltZS5nZXRUaW1lKCkgKyBkdXJhdGlvbik7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB1cGRhdGVkRXZlbnQgPSB7XG4gICAgICAgICAgLi4uY29uZmxpY3QsXG4gICAgICAgICAgc3RhcnRUaW1lOiBuZXdTdGFydFRpbWUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBlbmRUaW1lOiBuZXdFbmRUaW1lLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKCdNb3ZpbmcgZXZlbnQ6Jywge1xuICAgICAgICAgIGV2ZW50OiBjb25mbGljdC50aXRsZSxcbiAgICAgICAgICBmcm9tOiBjb25mbGljdC5zdGFydFRpbWUsXG4gICAgICAgICAgdG86IHVwZGF0ZWRFdmVudC5zdGFydFRpbWVcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBzdG9yYWdlLnVwZGF0ZVRpbWVCbG9jayh1cGRhdGVkRXZlbnQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3RXZlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpbmQgbmV4dCBhdmFpbGFibGUgdGltZSBmb3IgbmV3IGV2ZW50XG4gICAgICBjb25zb2xlLmxvZygnRmluZGluZyBuZXh0IGF2YWlsYWJsZSB0aW1lIGZvciBuZXcgZXZlbnQuLi4nKTtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gbmV3IERhdGUobmV3RXZlbnQuZW5kVGltZSkuZ2V0VGltZSgpIC0gbmV3IERhdGUobmV3RXZlbnQuc3RhcnRUaW1lKS5nZXRUaW1lKCk7XG4gICAgICBjb25zdCBsYXN0Q29uZmxpY3QgPSBjb25mbGljdHMuc29ydCgoYSwgYikgPT4gXG4gICAgICAgIG5ldyBEYXRlKGIuZW5kVGltZSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYS5lbmRUaW1lKS5nZXRUaW1lKClcbiAgICAgIClbMF07XG4gICAgICBcbiAgICAgIGNvbnN0IG5ld1N0YXJ0VGltZSA9IG5ldyBEYXRlKGxhc3RDb25mbGljdC5lbmRUaW1lKTtcbiAgICAgIGNvbnN0IG5ld0VuZFRpbWUgPSBuZXcgRGF0ZShuZXdTdGFydFRpbWUuZ2V0VGltZSgpICsgZHVyYXRpb24pO1xuICAgICAgXG4gICAgICBjb25zdCByZXNjaGVkdWxlZEV2ZW50ID0ge1xuICAgICAgICAuLi5uZXdFdmVudCxcbiAgICAgICAgc3RhcnRUaW1lOiBuZXdTdGFydFRpbWUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgZW5kVGltZTogbmV3RW5kVGltZS50b0lTT1N0cmluZygpXG4gICAgICB9O1xuXG4gICAgICBjb25zb2xlLmxvZygnUmVzY2hlZHVsZWQgbmV3IGV2ZW50OicsIHtcbiAgICAgICAgZnJvbTogbmV3RXZlbnQuc3RhcnRUaW1lLFxuICAgICAgICB0bzogcmVzY2hlZHVsZWRFdmVudC5zdGFydFRpbWVcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4gcmVzY2hlZHVsZWRFdmVudDtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgc2VuZE1lc3NhZ2UgPSBhc3luYyAoY29udGVudDogc3RyaW5nKSA9PiB7XG4gICAgY29uc29sZS5sb2coJz09PSBTVEFSVCBzZW5kTWVzc2FnZSA9PT0nKTtcbiAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gSW5pdGlhbGl6ZSBhZ2VudFxuICAgICAgY29uc29sZS5sb2coJ0luaXRpYWxpemluZyBhZ2VudC4uLicpO1xuICAgICAgY29uc3QgeyBhZ2VudCwgcHJvbXB0LCBmdW5jdGlvbkhhbmRsZXJzIH0gPSBhd2FpdCBpbml0aWFsaXplQWdlbnQoKTtcbiAgICAgIGNvbnNvbGUubG9nKCdBZ2VudCBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHknKTtcblxuICAgICAgLy8gRm9ybWF0IHRoZSBwcm9tcHRcbiAgICAgIGNvbnN0IGZvcm1hdHRlZFByb21wdCA9IGF3YWl0IHByb21wdC5mb3JtYXRNZXNzYWdlcyh7XG4gICAgICAgIGlucHV0OiBjb250ZW50XG4gICAgICB9KTtcblxuICAgICAgLy8gQ2FsbCBhZ2VudFxuICAgICAgY29uc29sZS5sb2coJ0NhbGxpbmcgYWdlbnQuLi4nKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWdlbnQuaW52b2tlKGZvcm1hdHRlZFByb21wdCk7XG4gICAgICBjb25zb2xlLmxvZygnQWdlbnQgcmVzcG9uc2UgcmVjZWl2ZWQ6JywgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBFeHRyYWN0IGNvbnRlbnRcbiAgICAgIGxldCBtZXNzYWdlQ29udGVudCA9IHJlc3BvbnNlLmNvbnRlbnQ7XG5cbiAgICAgIC8vIExvb2sgZm9yIHNjaGVkdWxlIHRhc2tcbiAgICAgIGNvbnN0IGNvZGVCbG9ja01hdGNoID0gbWVzc2FnZUNvbnRlbnQubWF0Y2goL2BgYFtcXHNcXFNdKj9zY2hlZHVsZV90YXNrXFwoKFtcXHNcXFNdKj8pXFwpW1xcc1xcU10qP2BgYC8pO1xuICAgICAgaWYgKGNvZGVCbG9ja01hdGNoKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtc1RleHQgPSBjb2RlQmxvY2tNYXRjaFsxXTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgIHRpdGxlOiAocGFyYW1zVGV4dC5tYXRjaCgvdGl0bGU9XCIoW15cIl0rKVwiLykgfHwgW10pWzFdLFxuICAgICAgICAgIHN0YXJ0VGltZTogKHBhcmFtc1RleHQubWF0Y2goL3N0YXJ0VGltZT1cIihbXlwiXSspXCIvKSB8fCBbXSlbMV0sXG4gICAgICAgICAgZW5kVGltZTogKHBhcmFtc1RleHQubWF0Y2goL2VuZFRpbWU9XCIoW15cIl0rKVwiLykgfHwgW10pWzFdLFxuICAgICAgICAgIHByaW9yaXR5OiAocGFyYW1zVGV4dC5tYXRjaCgvcHJpb3JpdHk9XCIoW15cIl0rKVwiLykgfHwgW10pWzFdLFxuICAgICAgICAgIGxvY2F0aW9uOiAocGFyYW1zVGV4dC5tYXRjaCgvbG9jYXRpb249XCIoW15cIl0rKVwiLykgfHwgW10pWzFdLFxuICAgICAgICAgIG5lZWRzVHJhbnNwb3J0OiBwYXJhbXNUZXh0LmluY2x1ZGVzKCduZWVkc1RyYW5zcG9ydD1UcnVlJyksXG4gICAgICAgICAgZGVsZWdhdGFibGU6IHBhcmFtc1RleHQuaW5jbHVkZXMoJ2RlbGVnYXRhYmxlPVRydWUnKVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChwYXJhbXMudGl0bGUgJiYgcGFyYW1zLnN0YXJ0VGltZSkge1xuICAgICAgICAgIC8vIFZhbGlkYXRlIGFuZCBwYXJzZSBkYXRlc1xuICAgICAgICAgIGNvbnN0IHBhcnNlRGF0ZSA9IChkYXRlU3RyOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShkYXRlU3RyKTtcbiAgICAgICAgICAgICAgaWYgKGlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRlOiAke2RhdGVTdHJ9YCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdEYXRlIHBhcnNpbmcgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGF0ZSBmb3JtYXQ6ICR7ZGF0ZVN0cn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGFyc2VEYXRlKHBhcmFtcy5zdGFydFRpbWUpO1xuICAgICAgICAgIGNvbnN0IGVuZFRpbWUgPSBwYXJhbXMuZW5kVGltZSA/IHBhcnNlRGF0ZShwYXJhbXMuZW5kVGltZSkgOiBcbiAgICAgICAgICAgIG5ldyBEYXRlKHN0YXJ0VGltZS5nZXRUaW1lKCkgKyA2MCAqIDYwICogMTAwMCk7XG5cbiAgICAgICAgICBjb25zdCBzdG9yYWdlID0gU3RvcmFnZVNlcnZpY2UuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICBjb25zdCBleGlzdGluZ0V2ZW50cyA9IHN0b3JhZ2UuZ2V0VGltZUJsb2NrcygpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEhhbmRsZSB0cmFuc3BvcnRhdGlvbiBpZiBuZWVkZWRcbiAgICAgICAgICBsZXQgdHJhbnNwb3J0RGV0YWlscyA9IG51bGw7XG4gICAgICAgICAgaWYgKHBhcmFtcy5uZWVkc1RyYW5zcG9ydCAmJiBwYXJhbXMubG9jYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHRheGlTZXJ2aWNlID0gVGF4aVNlcnZpY2UuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlID0gYXdhaXQgdGF4aVNlcnZpY2UuZXN0aW1hdGVUcmlwKCdjdXJyZW50X2xvY2F0aW9uJywgcGFyYW1zLmxvY2F0aW9uKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGVzdGltYXRlLmF2YWlsYWJsZSkge1xuICAgICAgICAgICAgICAvLyBBZGQgYnVmZmVyIHRpbWUgZm9yIHRyYW5zcG9ydGF0aW9uXG4gICAgICAgICAgICAgIGNvbnN0IHBpY2t1cFRpbWUgPSBuZXcgRGF0ZShzdGFydFRpbWUuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgICAgcGlja3VwVGltZS5zZXRNaW51dGVzKHBpY2t1cFRpbWUuZ2V0TWludXRlcygpIC0gZXN0aW1hdGUuZHVyYXRpb24pO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgY29uc3Qgc2NoZWR1bGVkRXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgX2lkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBwYXJhbXMudGl0bGUsXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lOiBwaWNrdXBUaW1lLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZW5kVGltZTogZW5kVGltZS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgIHByaW9yaXR5OiBwYXJhbXMucHJpb3JpdHkgfHwgXCJpbXBvcnRhbnRcIixcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogcGFyYW1zLmxvY2F0aW9uLFxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydERldGFpbHMsXG4gICAgICAgICAgICAgICAgZGVsZWdhdGFibGU6IHBhcmFtcy5kZWxlZ2F0YWJsZSB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdzY2hlZHVsZWQnLFxuICAgICAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAvLyBHZXQgcGF5bWVudCBkZXRhaWxzXG4gICAgICAgICAgICAgIGNvbnN0IHBheW1lbnREZXRhaWxzID0gYXdhaXQgdGF4aVNlcnZpY2UuZ2V0UGF5bWVudERldGFpbHMoJ2N1cnJlbnRfbG9jYXRpb24nLCBwYXJhbXMubG9jYXRpb24pO1xuICAgICAgICAgICAgICBtZXNzYWdlQ29udGVudCA9IGDwn5OFIEV2ZW50IFNjaGVkdWxlZDogJHtwYXJhbXMudGl0bGV9XG7ij7AgVGltZTogJHtzdGFydFRpbWUudG9Mb2NhbGVTdHJpbmcoKX0gLSAke2VuZFRpbWUudG9Mb2NhbGVTdHJpbmcoKX1cbvCfk40gTG9jYXRpb246ICR7cGFyYW1zLmxvY2F0aW9ufVxu8J+alSBUcmFuc3BvcnQ6IFRheGkgYm9va2VkIGZvciAke2VzdGltYXRlLmR1cmF0aW9ufSBtaW51dGVzIGJlZm9yZSBldmVudFxu8J+SsCBQYXltZW50OiAke3BheW1lbnREZXRhaWxzLnR4SGFzaCA/ICdQcm9jZXNzaW5nLi4uJyA6ICdQZW5kaW5nJ31cbiR7cGF5bWVudERldGFpbHMudHhIYXNoID8gYFRyYW5zYWN0aW9uOiAke3BheW1lbnREZXRhaWxzLnR4SGFzaH1gIDogJyd9YDtcblxuICAgICAgICAgICAgICBjb25zdCBmaW5hbEV2ZW50ID0gaGFuZGxlU2NoZWR1bGVDb25mbGljdChzY2hlZHVsZWRFdmVudCwgZXhpc3RpbmdFdmVudHMpO1xuICAgICAgICAgICAgICBzdG9yYWdlLmFkZFRpbWVCbG9jayhmaW5hbEV2ZW50KTtcblxuICAgICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnY2FsZW5kYXJVcGRhdGUnLCB7XG4gICAgICAgICAgICAgICAgZGV0YWlsOiBmaW5hbEV2ZW50XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBtZXNzYWdlIHRvIGNoYXQgaGlzdG9yeVxuICAgICAgc2V0TWVzc2FnZXMocHJldiA9PiBbLi4ucHJldiwge1xuICAgICAgICBjb250ZW50OiBtZXNzYWdlQ29udGVudCxcbiAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9XSk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gc2VuZE1lc3NhZ2U6JywgZXJyb3IpO1xuICAgICAgc2V0TWVzc2FnZXMocHJldiA9PiBbLi4ucHJldiwge1xuICAgICAgICBjb250ZW50OiBgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgICByb2xlOiAnc3lzdGVtJyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH1dKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlcyxcbiAgICBzZXRNZXNzYWdlcyxcbiAgICBpc0xvYWRpbmcsXG4gICAgc2VuZE1lc3NhZ2VcbiAgfTtcbn0gIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiaW5pdGlhbGl6ZUFnZW50IiwiU3RvcmFnZVNlcnZpY2UiLCJUYXhpU2VydmljZSIsInVzZUNoYXRib3QiLCJtZXNzYWdlcyIsInNldE1lc3NhZ2VzIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwic2F2ZWRNZXNzYWdlcyIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJKU09OIiwicGFyc2UiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiaGFuZGxlU2NoZWR1bGVDb25mbGljdCIsIm5ld0V2ZW50IiwiZXhpc3RpbmdFdmVudHMiLCJjb25zb2xlIiwibG9nIiwidGl0bGUiLCJzdGFydCIsInN0YXJ0VGltZSIsInByaW9yaXR5IiwicHJpb3JpdHlPcmRlciIsImNvbmZsaWN0cyIsImZpbHRlciIsImV2ZW50IiwibmV3U3RhcnQiLCJEYXRlIiwibmV3RW5kIiwiZW5kVGltZSIsImV2ZW50U3RhcnQiLCJldmVudEVuZCIsImhhc0NvbmZsaWN0IiwiZXhpc3RpbmdFdmVudCIsImV4aXN0aW5nUHJpb3JpdHkiLCJuZXdQcmlvcml0eSIsImxlbmd0aCIsIm5ld1ByaW9yaXR5U2NvcmUiLCJoaWdoZXN0Q29uZmxpY3RTY29yZSIsIk1hdGgiLCJtYXgiLCJtYXAiLCJlIiwibmV3RXZlbnRTY29yZSIsIndpbGxSZXNjaGVkdWxlQ29uZmxpY3RzIiwic3RvcmFnZSIsImdldEluc3RhbmNlIiwiZm9yRWFjaCIsImNvbmZsaWN0IiwiZHVyYXRpb24iLCJnZXRUaW1lIiwibmV3U3RhcnRUaW1lIiwibmV3RW5kVGltZSIsInVwZGF0ZWRFdmVudCIsInRvSVNPU3RyaW5nIiwiZnJvbSIsInRvIiwidXBkYXRlVGltZUJsb2NrIiwibGFzdENvbmZsaWN0Iiwic29ydCIsImEiLCJiIiwicmVzY2hlZHVsZWRFdmVudCIsInNlbmRNZXNzYWdlIiwiY29udGVudCIsImFnZW50IiwicHJvbXB0IiwiZnVuY3Rpb25IYW5kbGVycyIsImZvcm1hdHRlZFByb21wdCIsImZvcm1hdE1lc3NhZ2VzIiwiaW5wdXQiLCJyZXNwb25zZSIsImludm9rZSIsIm1lc3NhZ2VDb250ZW50IiwiY29kZUJsb2NrTWF0Y2giLCJtYXRjaCIsInBhcmFtc1RleHQiLCJwYXJhbXMiLCJsb2NhdGlvbiIsIm5lZWRzVHJhbnNwb3J0IiwiaW5jbHVkZXMiLCJkZWxlZ2F0YWJsZSIsInBhcnNlRGF0ZSIsImRhdGVTdHIiLCJkYXRlIiwiaXNOYU4iLCJFcnJvciIsImVycm9yIiwiZ2V0VGltZUJsb2NrcyIsInRyYW5zcG9ydERldGFpbHMiLCJ0YXhpU2VydmljZSIsImVzdGltYXRlIiwiZXN0aW1hdGVUcmlwIiwiYXZhaWxhYmxlIiwicGlja3VwVGltZSIsInNldE1pbnV0ZXMiLCJnZXRNaW51dGVzIiwic2NoZWR1bGVkRXZlbnQiLCJfaWQiLCJjcnlwdG8iLCJyYW5kb21VVUlEIiwic3RhdHVzIiwiY3JlYXRlZF9hdCIsInVwZGF0ZWRfYXQiLCJwYXltZW50RGV0YWlscyIsImdldFBheW1lbnREZXRhaWxzIiwidG9Mb2NhbGVTdHJpbmciLCJ0eEhhc2giLCJmaW5hbEV2ZW50IiwiYWRkVGltZUJsb2NrIiwiQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJ3aW5kb3ciLCJkaXNwYXRjaEV2ZW50IiwicHJldiIsInJvbGUiLCJ0aW1lc3RhbXAiLCJtZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useChatbot.ts\n"));

/***/ })

});