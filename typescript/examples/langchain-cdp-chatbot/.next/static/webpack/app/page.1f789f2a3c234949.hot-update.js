"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useChatbot.ts":
/*!*********************************!*\
  !*** ./src/hooks/useChatbot.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChatbot: function() { return /* binding */ useChatbot; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _services_chatbot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/services/chatbot */ \"(app-pages-browser)/./src/services/chatbot.ts\");\n/* harmony import */ var _lib_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/storage */ \"(app-pages-browser)/./src/lib/storage.ts\");\n/* harmony import */ var _services_taxiService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/taxiService */ \"(app-pages-browser)/./src/services/taxiService.ts\");\n/* __next_internal_client_entry_do_not_use__ useChatbot auto */ \n\n\n\nfunction useChatbot() {\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Load chat history from localStorage on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const savedMessages = localStorage.getItem(\"chat_history\");\n        if (savedMessages) {\n            setMessages(JSON.parse(savedMessages));\n        }\n    }, []);\n    // Save messages to localStorage whenever they change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        localStorage.setItem(\"chat_history\", JSON.stringify(messages));\n    }, [\n        messages\n    ]);\n    const handleScheduleConflict = (newEvent, existingEvents)=>{\n        console.log(\"Checking conflicts for new event:\", {\n            title: newEvent.title,\n            start: newEvent.startTime,\n            priority: newEvent.priority\n        });\n        console.log(\"Existing events:\", existingEvents);\n        // Sort existing events by priority\n        const priorityOrder = {\n            \"urgent-important\": 3,\n            \"important\": 2,\n            \"urgent\": 1,\n            \"neither\": 0\n        };\n        // Find conflicting events\n        const conflicts = existingEvents.filter((event)=>{\n            const newStart = new Date(newEvent.startTime);\n            const newEnd = new Date(newEvent.endTime);\n            const eventStart = new Date(event.startTime);\n            const eventEnd = new Date(event.endTime);\n            const hasConflict = newStart >= eventStart && newStart < eventEnd || newEnd > eventStart && newEnd <= eventEnd || newStart <= eventStart && newEnd >= eventEnd;\n            if (hasConflict) {\n                console.log(\"Found conflict:\", {\n                    existingEvent: event.title,\n                    existingPriority: event.priority,\n                    newEvent: newEvent.title,\n                    newPriority: newEvent.priority\n                });\n            }\n            return hasConflict;\n        });\n        if (conflicts.length === 0) {\n            console.log(\"No conflicts found\");\n            return newEvent;\n        }\n        // Check if new event has higher priority\n        const newPriorityScore = priorityOrder[newEvent.priority];\n        const highestConflictScore = Math.max(...conflicts.map((e)=>priorityOrder[e.priority]));\n        console.log(\"Priority comparison:\", {\n            newEventScore: newPriorityScore,\n            highestConflictScore,\n            willRescheduleConflicts: newPriorityScore > highestConflictScore\n        });\n        if (newPriorityScore > highestConflictScore) {\n            // Move conflicting events\n            console.log(\"Moving conflicting events...\");\n            const storage = _lib_storage__WEBPACK_IMPORTED_MODULE_2__.StorageService.getInstance();\n            conflicts.forEach((conflict)=>{\n                // Move to next available time\n                const duration = new Date(conflict.endTime).getTime() - new Date(conflict.startTime).getTime();\n                const newStartTime = new Date(newEvent.endTime);\n                const newEndTime = new Date(newStartTime.getTime() + duration);\n                const updatedEvent = {\n                    ...conflict,\n                    startTime: newStartTime.toISOString(),\n                    endTime: newEndTime.toISOString()\n                };\n                console.log(\"Moving event:\", {\n                    event: conflict.title,\n                    from: conflict.startTime,\n                    to: updatedEvent.startTime\n                });\n                storage.updateTimeBlock(updatedEvent);\n            });\n            return newEvent;\n        } else {\n            // Find next available time for new event\n            console.log(\"Finding next available time for new event...\");\n            const duration = new Date(newEvent.endTime).getTime() - new Date(newEvent.startTime).getTime();\n            const lastConflict = conflicts.sort((a, b)=>new Date(b.endTime).getTime() - new Date(a.endTime).getTime())[0];\n            const newStartTime = new Date(lastConflict.endTime);\n            const newEndTime = new Date(newStartTime.getTime() + duration);\n            const rescheduledEvent = {\n                ...newEvent,\n                startTime: newStartTime.toISOString(),\n                endTime: newEndTime.toISOString()\n            };\n            console.log(\"Rescheduled new event:\", {\n                from: newEvent.startTime,\n                to: rescheduledEvent.startTime\n            });\n            return rescheduledEvent;\n        }\n    };\n    const parseTimeString = (timeStr)=>{\n        // Try ISO format first\n        let date = new Date(timeStr);\n        if (!isNaN(date.getTime())) {\n            return date;\n        }\n        // Try parsing human-readable time formats\n        const today = new Date();\n        const timeRegex = /(\\d{1,2}):(\\d{2})\\s*(AM|PM|am|pm)?/;\n        const match = timeStr.match(timeRegex);\n        if (match) {\n            let [_, hours, minutes, meridiem] = match;\n            let hour = parseInt(hours);\n            // Convert to 24-hour format if meridiem is provided\n            if (meridiem) {\n                if (meridiem.toUpperCase() === \"PM\" && hour < 12) hour += 12;\n                if (meridiem.toUpperCase() === \"AM\" && hour === 12) hour = 0;\n            }\n            date = new Date(today);\n            date.setHours(hour, parseInt(minutes), 0, 0);\n            return date;\n        }\n        throw new Error(\"Unable to parse time: \".concat(timeStr));\n    };\n    const parseDate = (dateStr)=>{\n        try {\n            // If it's just a time string, parse it as time\n            if (dateStr.match(/^\\d{1,2}:\\d{2}(\\s*[AaPp][Mm])?$/)) {\n                return parseTimeString(dateStr);\n            }\n            // Try parsing as full date\n            const date = new Date(dateStr);\n            if (!isNaN(date.getTime())) {\n                return date;\n            }\n            throw new Error(\"Invalid date: \".concat(dateStr));\n        } catch (error) {\n            console.error(\"Date parsing error:\", error);\n            throw new Error(\"Invalid date format: \".concat(dateStr));\n        }\n    };\n    const sendMessage = async (content)=>{\n        console.log(\"=== START sendMessage ===\");\n        setIsLoading(true);\n        try {\n            // Initialize agent\n            console.log(\"Initializing agent...\");\n            const { agent, prompt, functionHandlers } = await (0,_services_chatbot__WEBPACK_IMPORTED_MODULE_1__.initializeAgent)();\n            console.log(\"Agent initialized successfully\");\n            // Format the prompt\n            const formattedPrompt = await prompt.formatMessages({\n                input: content\n            });\n            // Call agent\n            console.log(\"Calling agent...\");\n            const response = await agent.invoke(formattedPrompt);\n            console.log(\"Agent response received:\", response);\n            // Extract content\n            let messageContent = response.content;\n            // Look for schedule task\n            const codeBlockMatch = messageContent.match(/```[\\s\\S]*?schedule_task\\(([\\s\\S]*?)\\)[\\s\\S]*?```/);\n            if (codeBlockMatch) {\n                const paramsText = codeBlockMatch[1];\n                const params = {\n                    title: (paramsText.match(/title=\"([^\"]+)\"/) || [])[1],\n                    startTime: (paramsText.match(/startTime=\"([^\"]+)\"/) || [])[1],\n                    endTime: (paramsText.match(/endTime=\"([^\"]+)\"/) || [])[1],\n                    priority: (paramsText.match(/priority=\"([^\"]+)\"/) || [])[1],\n                    location: (paramsText.match(/location=\"([^\"]+)\"/) || [])[1],\n                    needsTransport: paramsText.includes(\"needsTransport=True\"),\n                    delegatable: paramsText.includes(\"delegatable=True\")\n                };\n                if (params.title && params.startTime) {\n                    // Validate and parse dates\n                    const startTime = parseDate(params.startTime);\n                    const endTime = params.endTime ? parseDate(params.endTime) : new Date(startTime.getTime() + 60 * 60 * 1000);\n                    const storage = _lib_storage__WEBPACK_IMPORTED_MODULE_2__.StorageService.getInstance();\n                    const existingEvents = storage.getTimeBlocks();\n                    // Handle transportation if needed\n                    let transportDetails = null;\n                    if (params.needsTransport && params.location) {\n                        const taxiService = _services_taxiService__WEBPACK_IMPORTED_MODULE_3__.TaxiService.getInstance();\n                        const estimate = await taxiService.estimateTrip(\"current_location\", params.location);\n                        if (estimate.available) {\n                            // Add buffer time for transportation\n                            const pickupTime = new Date(startTime.getTime());\n                            pickupTime.setMinutes(pickupTime.getMinutes() - estimate.duration);\n                            // Process payment first\n                            const paymentDetails = await taxiService.getPaymentDetails(\"current_location\", params.location);\n                            let paymentStatus = \"Pending\";\n                            let transactionHash = \"\";\n                            if (paymentDetails.txHash) {\n                                // Wait for transaction confirmation\n                                const isConfirmed = await taxiService.verifyPayment(paymentDetails.txHash);\n                                paymentStatus = isConfirmed ? \"Confirmed\" : \"Failed\";\n                                transactionHash = paymentDetails.txHash;\n                                if (!isConfirmed) {\n                                    throw new Error(\"Payment failed to confirm\");\n                                }\n                            }\n                            const scheduledEvent = {\n                                _id: crypto.randomUUID(),\n                                title: params.title,\n                                startTime: pickupTime.toISOString(),\n                                endTime: endTime.toISOString(),\n                                priority: params.priority || \"important\",\n                                location: params.location,\n                                transportDetails: {\n                                    pickupTime: pickupTime.toISOString(),\n                                    paymentHash: transactionHash,\n                                    paymentStatus\n                                },\n                                delegatable: params.delegatable || false,\n                                status: \"scheduled\",\n                                created_at: new Date().toISOString(),\n                                updated_at: new Date().toISOString()\n                            };\n                            messageContent = \"\\uD83D\\uDCC5 Event Scheduled: \".concat(params.title, \"\\n⏰ Time: \").concat(startTime.toLocaleString(), \" - \").concat(endTime.toLocaleString(), \"\\n\\uD83D\\uDCCD Location: \").concat(params.location, \"\\n\\uD83D\\uDE95 Transport: Taxi booked for \").concat(pickupTime.toLocaleTimeString(), \"\\n\\uD83D\\uDCB0 Payment: \").concat(paymentStatus).concat(transactionHash ? \"\\n\\uD83D\\uDCB3 Transaction: \".concat(transactionHash) : \"\");\n                            const finalEvent = handleScheduleConflict(scheduledEvent, existingEvents);\n                            storage.addTimeBlock(finalEvent);\n                            const event = new CustomEvent(\"calendarUpdate\", {\n                                detail: finalEvent\n                            });\n                            window.dispatchEvent(event);\n                        }\n                    }\n                }\n            }\n            // Add message to chat history\n            setMessages((prev)=>[\n                    ...prev,\n                    {\n                        content: messageContent,\n                        role: \"assistant\",\n                        timestamp: new Date().toISOString()\n                    }\n                ]);\n        } catch (error) {\n            console.error(\"Error in sendMessage:\", error);\n            setMessages((prev)=>[\n                    ...prev,\n                    {\n                        content: \"Error: \".concat(error.message),\n                        role: \"system\",\n                        timestamp: new Date().toISOString()\n                    }\n                ]);\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    return {\n        messages,\n        setMessages,\n        isLoading,\n        sendMessage\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VDaGF0Ym90LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztnRUFFNEM7QUFDUztBQUNOO0FBQ007QUFFOUMsU0FBU0s7SUFDZCxNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR1AsK0NBQVFBLENBQVEsRUFBRTtJQUNsRCxNQUFNLENBQUNRLFdBQVdDLGFBQWEsR0FBR1QsK0NBQVFBLENBQUM7SUFFM0MsK0NBQStDO0lBQy9DQyxnREFBU0EsQ0FBQztRQUNSLE1BQU1TLGdCQUFnQkMsYUFBYUMsT0FBTyxDQUFDO1FBQzNDLElBQUlGLGVBQWU7WUFDakJILFlBQVlNLEtBQUtDLEtBQUssQ0FBQ0o7UUFDekI7SUFDRixHQUFHLEVBQUU7SUFFTCxxREFBcUQ7SUFDckRULGdEQUFTQSxDQUFDO1FBQ1JVLGFBQWFJLE9BQU8sQ0FBQyxnQkFBZ0JGLEtBQUtHLFNBQVMsQ0FBQ1Y7SUFDdEQsR0FBRztRQUFDQTtLQUFTO0lBRWIsTUFBTVcseUJBQXlCLENBQUNDLFVBQXFCQztRQUNuREMsUUFBUUMsR0FBRyxDQUFDLHFDQUFxQztZQUMvQ0MsT0FBT0osU0FBU0ksS0FBSztZQUNyQkMsT0FBT0wsU0FBU00sU0FBUztZQUN6QkMsVUFBVVAsU0FBU08sUUFBUTtRQUM3QjtRQUNBTCxRQUFRQyxHQUFHLENBQUMsb0JBQW9CRjtRQUVoQyxtQ0FBbUM7UUFDbkMsTUFBTU8sZ0JBQWdCO1lBQ3BCLG9CQUFvQjtZQUNwQixhQUFhO1lBQ2IsVUFBVTtZQUNWLFdBQVc7UUFDYjtRQUVBLDBCQUEwQjtRQUMxQixNQUFNQyxZQUFZUixlQUFlUyxNQUFNLENBQUNDLENBQUFBO1lBQ3RDLE1BQU1DLFdBQVcsSUFBSUMsS0FBS2IsU0FBU00sU0FBUztZQUM1QyxNQUFNUSxTQUFTLElBQUlELEtBQUtiLFNBQVNlLE9BQU87WUFDeEMsTUFBTUMsYUFBYSxJQUFJSCxLQUFLRixNQUFNTCxTQUFTO1lBQzNDLE1BQU1XLFdBQVcsSUFBSUos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d0JBQ05DLFdBQVcsSUFBSTNHLE9BQU8yQixXQUFXO29CQUNuQztpQkFBRTtRQUVKLEVBQUUsT0FBTzJCLE9BQU87WUFDZGpFLFFBQVFpRSxLQUFLLENBQUMseUJBQXlCQTtZQUN2QzlFLFlBQVlpSSxDQUFBQSxPQUFRO3VCQUFJQTtvQkFBTTt3QkFDNUJqRCxTQUFTLFVBQXdCLE9BQWRGLE1BQU1zRCxPQUFPO3dCQUNoQ0YsTUFBTTt3QkFDTkMsV0FBVyxJQUFJM0csT0FBTzJCLFdBQVc7b0JBQ25DO2lCQUFFO1FBQ0osU0FBVTtZQUNSakQsYUFBYTtRQUNmO0lBQ0Y7SUFFQSxPQUFPO1FBQ0xIO1FBQ0FDO1FBQ0FDO1FBQ0E4RTtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2hvb2tzL3VzZUNoYXRib3QudHM/ZDQ2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpbml0aWFsaXplQWdlbnQgfSBmcm9tICdAL3NlcnZpY2VzL2NoYXRib3QnO1xuaW1wb3J0IHsgU3RvcmFnZVNlcnZpY2UgfSBmcm9tICdAL2xpYi9zdG9yYWdlJztcbmltcG9ydCB7IFRheGlTZXJ2aWNlIH0gZnJvbSAnQC9zZXJ2aWNlcy90YXhpU2VydmljZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGF0Ym90KCkge1xuICBjb25zdCBbbWVzc2FnZXMsIHNldE1lc3NhZ2VzXSA9IHVzZVN0YXRlPGFueVtdPihbXSk7XG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gTG9hZCBjaGF0IGhpc3RvcnkgZnJvbSBsb2NhbFN0b3JhZ2Ugb24gbW91bnRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzYXZlZE1lc3NhZ2VzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2NoYXRfaGlzdG9yeScpO1xuICAgIGlmIChzYXZlZE1lc3NhZ2VzKSB7XG4gICAgICBzZXRNZXNzYWdlcyhKU09OLnBhcnNlKHNhdmVkTWVzc2FnZXMpKTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICAvLyBTYXZlIG1lc3NhZ2VzIHRvIGxvY2FsU3RvcmFnZSB3aGVuZXZlciB0aGV5IGNoYW5nZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdjaGF0X2hpc3RvcnknLCBKU09OLnN0cmluZ2lmeShtZXNzYWdlcykpO1xuICB9LCBbbWVzc2FnZXNdKTtcblxuICBjb25zdCBoYW5kbGVTY2hlZHVsZUNvbmZsaWN0ID0gKG5ld0V2ZW50OiBUaW1lQmxvY2ssIGV4aXN0aW5nRXZlbnRzOiBUaW1lQmxvY2tbXSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdDaGVja2luZyBjb25mbGljdHMgZm9yIG5ldyBldmVudDonLCB7XG4gICAgICB0aXRsZTogbmV3RXZlbnQudGl0bGUsXG4gICAgICBzdGFydDogbmV3RXZlbnQuc3RhcnRUaW1lLFxuICAgICAgcHJpb3JpdHk6IG5ld0V2ZW50LnByaW9yaXR5XG4gICAgfSk7XG4gICAgY29uc29sZS5sb2coJ0V4aXN0aW5nIGV2ZW50czonLCBleGlzdGluZ0V2ZW50cyk7XG5cbiAgICAvLyBTb3J0IGV4aXN0aW5nIGV2ZW50cyBieSBwcmlvcml0eVxuICAgIGNvbnN0IHByaW9yaXR5T3JkZXIgPSB7XG4gICAgICAndXJnZW50LWltcG9ydGFudCc6IDMsXG4gICAgICAnaW1wb3J0YW50JzogMixcbiAgICAgICd1cmdlbnQnOiAxLFxuICAgICAgJ25laXRoZXInOiAwXG4gICAgfTtcblxuICAgIC8vIEZpbmQgY29uZmxpY3RpbmcgZXZlbnRzXG4gICAgY29uc3QgY29uZmxpY3RzID0gZXhpc3RpbmdFdmVudHMuZmlsdGVyKGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IG5ld1N0YXJ0ID0gbmV3IERhdGUobmV3RXZlbnQuc3RhcnRUaW1lKTtcbiAgICAgIGNvbnN0IG5ld0VuZCA9IG5ldyBEYXRlKG5ld0V2ZW50LmVuZFRpbWUpO1xuICAgICAgY29uc3QgZXZlbnRTdGFydCA9IG5ldyBEYXRlKGV2ZW50LnN0YXJ0VGltZSk7XG4gICAgICBjb25zdCBldmVudEVuZCA9IG5ldyBEYXRlKGV2ZW50LmVuZFRpbWUpO1xuICAgICAgXG4gICAgICBjb25zdCBoYXNDb25mbGljdCA9IChcbiAgICAgICAgKG5ld1N0YXJ0ID49IGV2ZW50U3RhcnQgJiYgbmV3U3RhcnQgPCBldmVudEVuZCkgfHxcbiAgICAgICAgKG5ld0VuZCA+IGV2ZW50U3RhcnQgJiYgbmV3RW5kIDw9IGV2ZW50RW5kKSB8fFxuICAgICAgICAobmV3U3RhcnQgPD0gZXZlbnRTdGFydCAmJiBuZXdFbmQgPj0gZXZlbnRFbmQpXG4gICAgICApO1xuXG4gICAgICBpZiAoaGFzQ29uZmxpY3QpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0ZvdW5kIGNvbmZsaWN0OicsIHtcbiAgICAgICAgICBleGlzdGluZ0V2ZW50OiBldmVudC50aXRsZSxcbiAgICAgICAgICBleGlzdGluZ1ByaW9yaXR5OiBldmVudC5wcmlvcml0eSxcbiAgICAgICAgICBuZXdFdmVudDogbmV3RXZlbnQudGl0bGUsXG4gICAgICAgICAgbmV3UHJpb3JpdHk6IG5ld0V2ZW50LnByaW9yaXR5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gaGFzQ29uZmxpY3Q7XG4gICAgfSk7XG5cbiAgICBpZiAoY29uZmxpY3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS5sb2coJ05vIGNvbmZsaWN0cyBmb3VuZCcpO1xuICAgICAgcmV0dXJuIG5ld0V2ZW50O1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIG5ldyBldmVudCBoYXMgaGlnaGVyIHByaW9yaXR5XG4gICAgY29uc3QgbmV3UHJpb3JpdHlTY29yZSA9IHByaW9yaXR5T3JkZXJbbmV3RXZlbnQucHJpb3JpdHldO1xuICAgIGNvbnN0IGhpZ2hlc3RDb25mbGljdFNjb3JlID0gTWF0aC5tYXgoXG4gICAgICAuLi5jb25mbGljdHMubWFwKGUgPT4gcHJpb3JpdHlPcmRlcltlLnByaW9yaXR5XSlcbiAgICApO1xuXG4gICAgY29uc29sZS5sb2coJ1ByaW9yaXR5IGNvbXBhcmlzb246Jywge1xuICAgICAgbmV3RXZlbnRTY29yZTogbmV3UHJpb3JpdHlTY29yZSxcbiAgICAgIGhpZ2hlc3RDb25mbGljdFNjb3JlLFxuICAgICAgd2lsbFJlc2NoZWR1bGVDb25mbGljdHM6IG5ld1ByaW9yaXR5U2NvcmUgPiBoaWdoZXN0Q29uZmxpY3RTY29yZVxuICAgIH0pO1xuXG4gICAgaWYgKG5ld1ByaW9yaXR5U2NvcmUgPiBoaWdoZXN0Q29uZmxpY3RTY29yZSkge1xuICAgICAgLy8gTW92ZSBjb25mbGljdGluZyBldmVudHNcbiAgICAgIGNvbnNvbGUubG9nKCdNb3ZpbmcgY29uZmxpY3RpbmcgZXZlbnRzLi4uJyk7XG4gICAgICBjb25zdCBzdG9yYWdlID0gU3RvcmFnZVNlcnZpY2UuZ2V0SW5zdGFuY2UoKTtcbiAgICAgIGNvbmZsaWN0cy5mb3JFYWNoKGNvbmZsaWN0ID0+IHtcbiAgICAgICAgLy8gTW92ZSB0byBuZXh0IGF2YWlsYWJsZSB0aW1lXG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gbmV3IERhdGUoY29uZmxpY3QuZW5kVGltZSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoY29uZmxpY3Quc3RhcnRUaW1lKS5nZXRUaW1lKCk7XG4gICAgICAgIGNvbnN0IG5ld1N0YXJ0VGltZSA9IG5ldyBEYXRlKG5ld0V2ZW50LmVuZFRpbWUpO1xuICAgICAgICBjb25zdCBuZXdFbmRUaW1lID0gbmV3IERhdGUobmV3U3RhcnRUaW1lLmdldFRpbWUoKSArIGR1cmF0aW9uKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRFdmVudCA9IHtcbiAgICAgICAgICAuLi5jb25mbGljdCxcbiAgICAgICAgICBzdGFydFRpbWU6IG5ld1N0YXJ0VGltZS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIGVuZFRpbWU6IG5ld0VuZFRpbWUudG9JU09TdHJpbmcoKVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coJ01vdmluZyBldmVudDonLCB7XG4gICAgICAgICAgZXZlbnQ6IGNvbmZsaWN0LnRpdGxlLFxuICAgICAgICAgIGZyb206IGNvbmZsaWN0LnN0YXJ0VGltZSxcbiAgICAgICAgICB0bzogdXBkYXRlZEV2ZW50LnN0YXJ0VGltZVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHN0b3JhZ2UudXBkYXRlVGltZUJsb2NrKHVwZGF0ZWRFdmVudCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXdFdmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmluZCBuZXh0IGF2YWlsYWJsZSB0aW1lIGZvciBuZXcgZXZlbnRcbiAgICAgIGNvbnNvbGUubG9nKCdGaW5kaW5nIG5leHQgYXZhaWxhYmxlIHRpbWUgZm9yIG5ldyBldmVudC4uLicpO1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBuZXcgRGF0ZShuZXdFdmVudC5lbmRUaW1lKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShuZXdFdmVudC5zdGFydFRpbWUpLmdldFRpbWUoKTtcbiAgICAgIGNvbnN0IGxhc3RDb25mbGljdCA9IGNvbmZsaWN0cy5zb3J0KChhLCBiKSA9PiBcbiAgICAgICAgbmV3IERhdGUoYi5lbmRUaW1lKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShhLmVuZFRpbWUpLmdldFRpbWUoKVxuICAgICAgKVswXTtcbiAgICAgIFxuICAgICAgY29uc3QgbmV3U3RhcnRUaW1lID0gbmV3IERhdGUobGFzdENvbmZsaWN0LmVuZFRpbWUpO1xuICAgICAgY29uc3QgbmV3RW5kVGltZSA9IG5ldyBEYXRlKG5ld1N0YXJ0VGltZS5nZXRUaW1lKCkgKyBkdXJhdGlvbik7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc2NoZWR1bGVkRXZlbnQgPSB7XG4gICAgICAgIC4uLm5ld0V2ZW50LFxuICAgICAgICBzdGFydFRpbWU6IG5ld1N0YXJ0VGltZS50b0lTT1N0cmluZygpLFxuICAgICAgICBlbmRUaW1lOiBuZXdFbmRUaW1lLnRvSVNPU3RyaW5nKClcbiAgICAgIH07XG5cbiAgICAgIGNvbnNvbGUubG9nKCdSZXNjaGVkdWxlZCBuZXcgZXZlbnQ6Jywge1xuICAgICAgICBmcm9tOiBuZXdFdmVudC5zdGFydFRpbWUsXG4gICAgICAgIHRvOiByZXNjaGVkdWxlZEV2ZW50LnN0YXJ0VGltZVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiByZXNjaGVkdWxlZEV2ZW50O1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBwYXJzZVRpbWVTdHJpbmcgPSAodGltZVN0cjogc3RyaW5nKTogRGF0ZSA9PiB7XG4gICAgLy8gVHJ5IElTTyBmb3JtYXQgZmlyc3RcbiAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKHRpbWVTdHIpO1xuICAgIGlmICghaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICAvLyBUcnkgcGFyc2luZyBodW1hbi1yZWFkYWJsZSB0aW1lIGZvcm1hdHNcbiAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XG4gICAgY29uc3QgdGltZVJlZ2V4ID0gLyhcXGR7MSwyfSk6KFxcZHsyfSlcXHMqKEFNfFBNfGFtfHBtKT8vO1xuICAgIGNvbnN0IG1hdGNoID0gdGltZVN0ci5tYXRjaCh0aW1lUmVnZXgpO1xuICAgIFxuICAgIGlmIChtYXRjaCkge1xuICAgICAgbGV0IFtfLCBob3VycywgbWludXRlcywgbWVyaWRpZW1dID0gbWF0Y2g7XG4gICAgICBsZXQgaG91ciA9IHBhcnNlSW50KGhvdXJzKTtcbiAgICAgIFxuICAgICAgLy8gQ29udmVydCB0byAyNC1ob3VyIGZvcm1hdCBpZiBtZXJpZGllbSBpcyBwcm92aWRlZFxuICAgICAgaWYgKG1lcmlkaWVtKSB7XG4gICAgICAgIGlmIChtZXJpZGllbS50b1VwcGVyQ2FzZSgpID09PSAnUE0nICYmIGhvdXIgPCAxMikgaG91ciArPSAxMjtcbiAgICAgICAgaWYgKG1lcmlkaWVtLnRvVXBwZXJDYXNlKCkgPT09ICdBTScgJiYgaG91ciA9PT0gMTIpIGhvdXIgPSAwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBkYXRlID0gbmV3IERhdGUodG9kYXkpO1xuICAgICAgZGF0ZS5zZXRIb3Vycyhob3VyLCBwYXJzZUludChtaW51dGVzKSwgMCwgMCk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBwYXJzZSB0aW1lOiAke3RpbWVTdHJ9YCk7XG4gIH07XG5cbiAgY29uc3QgcGFyc2VEYXRlID0gKGRhdGVTdHI6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBJZiBpdCdzIGp1c3QgYSB0aW1lIHN0cmluZywgcGFyc2UgaXQgYXMgdGltZVxuICAgICAgaWYgKGRhdGVTdHIubWF0Y2goL15cXGR7MSwyfTpcXGR7Mn0oXFxzKltBYVBwXVtNbV0pPyQvKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VUaW1lU3RyaW5nKGRhdGVTdHIpO1xuICAgICAgfVxuXG4gICAgICAvLyBUcnkgcGFyc2luZyBhcyBmdWxsIGRhdGVcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShkYXRlU3RyKTtcbiAgICAgIGlmICghaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGF0ZTogJHtkYXRlU3RyfWApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdEYXRlIHBhcnNpbmcgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGUgZm9ybWF0OiAke2RhdGVTdHJ9YCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHNlbmRNZXNzYWdlID0gYXN5bmMgKGNvbnRlbnQ6IHN0cmluZykgPT4ge1xuICAgIGNvbnNvbGUubG9nKCc9PT0gU1RBUlQgc2VuZE1lc3NhZ2UgPT09Jyk7XG4gICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEluaXRpYWxpemUgYWdlbnRcbiAgICAgIGNvbnNvbGUubG9nKCdJbml0aWFsaXppbmcgYWdlbnQuLi4nKTtcbiAgICAgIGNvbnN0IHsgYWdlbnQsIHByb21wdCwgZnVuY3Rpb25IYW5kbGVycyB9ID0gYXdhaXQgaW5pdGlhbGl6ZUFnZW50KCk7XG4gICAgICBjb25zb2xlLmxvZygnQWdlbnQgaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG5cbiAgICAgIC8vIEZvcm1hdCB0aGUgcHJvbXB0XG4gICAgICBjb25zdCBmb3JtYXR0ZWRQcm9tcHQgPSBhd2FpdCBwcm9tcHQuZm9ybWF0TWVzc2FnZXMoe1xuICAgICAgICBpbnB1dDogY29udGVudFxuICAgICAgfSk7XG5cbiAgICAgIC8vIENhbGwgYWdlbnRcbiAgICAgIGNvbnNvbGUubG9nKCdDYWxsaW5nIGFnZW50Li4uJyk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFnZW50Lmludm9rZShmb3JtYXR0ZWRQcm9tcHQpO1xuICAgICAgY29uc29sZS5sb2coJ0FnZW50IHJlc3BvbnNlIHJlY2VpdmVkOicsIHJlc3BvbnNlKTtcblxuICAgICAgLy8gRXh0cmFjdCBjb250ZW50XG4gICAgICBsZXQgbWVzc2FnZUNvbnRlbnQgPSByZXNwb25zZS5jb250ZW50O1xuXG4gICAgICAvLyBMb29rIGZvciBzY2hlZHVsZSB0YXNrXG4gICAgICBjb25zdCBjb2RlQmxvY2tNYXRjaCA9IG1lc3NhZ2VDb250ZW50Lm1hdGNoKC9gYGBbXFxzXFxTXSo/c2NoZWR1bGVfdGFza1xcKChbXFxzXFxTXSo/KVxcKVtcXHNcXFNdKj9gYGAvKTtcbiAgICAgIGlmIChjb2RlQmxvY2tNYXRjaCkge1xuICAgICAgICBjb25zdCBwYXJhbXNUZXh0ID0gY29kZUJsb2NrTWF0Y2hbMV07XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICB0aXRsZTogKHBhcmFtc1RleHQubWF0Y2goL3RpdGxlPVwiKFteXCJdKylcIi8pIHx8IFtdKVsxXSxcbiAgICAgICAgICBzdGFydFRpbWU6IChwYXJhbXNUZXh0Lm1hdGNoKC9zdGFydFRpbWU9XCIoW15cIl0rKVwiLykgfHwgW10pWzFdLFxuICAgICAgICAgIGVuZFRpbWU6IChwYXJhbXNUZXh0Lm1hdGNoKC9lbmRUaW1lPVwiKFteXCJdKylcIi8pIHx8IFtdKVsxXSxcbiAgICAgICAgICBwcmlvcml0eTogKHBhcmFtc1RleHQubWF0Y2goL3ByaW9yaXR5PVwiKFteXCJdKylcIi8pIHx8IFtdKVsxXSxcbiAgICAgICAgICBsb2NhdGlvbjogKHBhcmFtc1RleHQubWF0Y2goL2xvY2F0aW9uPVwiKFteXCJdKylcIi8pIHx8IFtdKVsxXSxcbiAgICAgICAgICBuZWVkc1RyYW5zcG9ydDogcGFyYW1zVGV4dC5pbmNsdWRlcygnbmVlZHNUcmFuc3BvcnQ9VHJ1ZScpLFxuICAgICAgICAgIGRlbGVnYXRhYmxlOiBwYXJhbXNUZXh0LmluY2x1ZGVzKCdkZWxlZ2F0YWJsZT1UcnVlJylcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocGFyYW1zLnRpdGxlICYmIHBhcmFtcy5zdGFydFRpbWUpIHtcbiAgICAgICAgICAvLyBWYWxpZGF0ZSBhbmQgcGFyc2UgZGF0ZXNcbiAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBwYXJzZURhdGUocGFyYW1zLnN0YXJ0VGltZSk7XG4gICAgICAgICAgY29uc3QgZW5kVGltZSA9IHBhcmFtcy5lbmRUaW1lID8gcGFyc2VEYXRlKHBhcmFtcy5lbmRUaW1lKSA6IFxuICAgICAgICAgICAgbmV3IERhdGUoc3RhcnRUaW1lLmdldFRpbWUoKSArIDYwICogNjAgKiAxMDAwKTtcblxuICAgICAgICAgIGNvbnN0IHN0b3JhZ2UgPSBTdG9yYWdlU2VydmljZS5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nRXZlbnRzID0gc3RvcmFnZS5nZXRUaW1lQmxvY2tzKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSGFuZGxlIHRyYW5zcG9ydGF0aW9uIGlmIG5lZWRlZFxuICAgICAgICAgIGxldCB0cmFuc3BvcnREZXRhaWxzID0gbnVsbDtcbiAgICAgICAgICBpZiAocGFyYW1zLm5lZWRzVHJhbnNwb3J0ICYmIHBhcmFtcy5sb2NhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgdGF4aVNlcnZpY2UgPSBUYXhpU2VydmljZS5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgY29uc3QgZXN0aW1hdGUgPSBhd2FpdCB0YXhpU2VydmljZS5lc3RpbWF0ZVRyaXAoJ2N1cnJlbnRfbG9jYXRpb24nLCBwYXJhbXMubG9jYXRpb24pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZXN0aW1hdGUuYXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgIC8vIEFkZCBidWZmZXIgdGltZSBmb3IgdHJhbnNwb3J0YXRpb25cbiAgICAgICAgICAgICAgY29uc3QgcGlja3VwVGltZSA9IG5ldyBEYXRlKHN0YXJ0VGltZS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgICBwaWNrdXBUaW1lLnNldE1pbnV0ZXMocGlja3VwVGltZS5nZXRNaW51dGVzKCkgLSBlc3RpbWF0ZS5kdXJhdGlvbik7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBQcm9jZXNzIHBheW1lbnQgZmlyc3RcbiAgICAgICAgICAgICAgY29uc3QgcGF5bWVudERldGFpbHMgPSBhd2FpdCB0YXhpU2VydmljZS5nZXRQYXltZW50RGV0YWlscygnY3VycmVudF9sb2NhdGlvbicsIHBhcmFtcy5sb2NhdGlvbik7XG4gICAgICAgICAgICAgIGxldCBwYXltZW50U3RhdHVzID0gJ1BlbmRpbmcnO1xuICAgICAgICAgICAgICBsZXQgdHJhbnNhY3Rpb25IYXNoID0gJyc7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAocGF5bWVudERldGFpbHMudHhIYXNoKSB7XG4gICAgICAgICAgICAgICAgLy8gV2FpdCBmb3IgdHJhbnNhY3Rpb24gY29uZmlybWF0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgaXNDb25maXJtZWQgPSBhd2FpdCB0YXhpU2VydmljZS52ZXJpZnlQYXltZW50KHBheW1lbnREZXRhaWxzLnR4SGFzaCk7XG4gICAgICAgICAgICAgICAgcGF5bWVudFN0YXR1cyA9IGlzQ29uZmlybWVkID8gJ0NvbmZpcm1lZCcgOiAnRmFpbGVkJztcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2ggPSBwYXltZW50RGV0YWlscy50eEhhc2g7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKCFpc0NvbmZpcm1lZCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXltZW50IGZhaWxlZCB0byBjb25maXJtJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBjb25zdCBzY2hlZHVsZWRFdmVudCA9IHtcbiAgICAgICAgICAgICAgICBfaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksXG4gICAgICAgICAgICAgICAgdGl0bGU6IHBhcmFtcy50aXRsZSxcbiAgICAgICAgICAgICAgICBzdGFydFRpbWU6IHBpY2t1cFRpbWUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBlbmRUaW1lOiBlbmRUaW1lLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgcHJpb3JpdHk6IHBhcmFtcy5wcmlvcml0eSB8fCBcImltcG9ydGFudFwiLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBwYXJhbXMubG9jYXRpb24sXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0RGV0YWlsczoge1xuICAgICAgICAgICAgICAgICAgcGlja3VwVGltZTogcGlja3VwVGltZS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgcGF5bWVudEhhc2g6IHRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICAgICAgICAgIHBheW1lbnRTdGF0dXNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRlbGVnYXRhYmxlOiBwYXJhbXMuZGVsZWdhdGFibGUgfHwgZmFsc2UsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAnc2NoZWR1bGVkJyxcbiAgICAgICAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgbWVzc2FnZUNvbnRlbnQgPSBg8J+ThSBFdmVudCBTY2hlZHVsZWQ6ICR7cGFyYW1zLnRpdGxlfVxu4o+wIFRpbWU6ICR7c3RhcnRUaW1lLnRvTG9jYWxlU3RyaW5nKCl9IC0gJHtlbmRUaW1lLnRvTG9jYWxlU3RyaW5nKCl9XG7wn5ONIExvY2F0aW9uOiAke3BhcmFtcy5sb2NhdGlvbn1cbvCfmpUgVHJhbnNwb3J0OiBUYXhpIGJvb2tlZCBmb3IgJHtwaWNrdXBUaW1lLnRvTG9jYWxlVGltZVN0cmluZygpfVxu8J+SsCBQYXltZW50OiAke3BheW1lbnRTdGF0dXN9JHt0cmFuc2FjdGlvbkhhc2ggPyBgXFxu8J+SsyBUcmFuc2FjdGlvbjogJHt0cmFuc2FjdGlvbkhhc2h9YCA6ICcnfWA7XG5cbiAgICAgICAgICAgICAgY29uc3QgZmluYWxFdmVudCA9IGhhbmRsZVNjaGVkdWxlQ29uZmxpY3Qoc2NoZWR1bGVkRXZlbnQsIGV4aXN0aW5nRXZlbnRzKTtcbiAgICAgICAgICAgICAgc3RvcmFnZS5hZGRUaW1lQmxvY2soZmluYWxFdmVudCk7XG5cbiAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2NhbGVuZGFyVXBkYXRlJywge1xuICAgICAgICAgICAgICAgIGRldGFpbDogZmluYWxFdmVudFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgbWVzc2FnZSB0byBjaGF0IGhpc3RvcnlcbiAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gWy4uLnByZXYsIHtcbiAgICAgICAgY29udGVudDogbWVzc2FnZUNvbnRlbnQsXG4gICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfV0pO1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHNlbmRNZXNzYWdlOicsIGVycm9yKTtcbiAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gWy4uLnByZXYsIHtcbiAgICAgICAgY29udGVudDogYEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgcm9sZTogJ3N5c3RlbScsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9XSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXMsXG4gICAgc2V0TWVzc2FnZXMsXG4gICAgaXNMb2FkaW5nLFxuICAgIHNlbmRNZXNzYWdlXG4gIH07XG59ICJdLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsImluaXRpYWxpemVBZ2VudCIsIlN0b3JhZ2VTZXJ2aWNlIiwiVGF4aVNlcnZpY2UiLCJ1c2VDaGF0Ym90IiwibWVzc2FnZXMiLCJzZXRNZXNzYWdlcyIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsInNhdmVkTWVzc2FnZXMiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiSlNPTiIsInBhcnNlIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsImhhbmRsZVNjaGVkdWxlQ29uZmxpY3QiLCJuZXdFdmVudCIsImV4aXN0aW5nRXZlbnRzIiwiY29uc29sZSIsImxvZyIsInRpdGxlIiwic3RhcnQiLCJzdGFydFRpbWUiLCJwcmlvcml0eSIsInByaW9yaXR5T3JkZXIiLCJjb25mbGljdHMiLCJmaWx0ZXIiLCJldmVudCIsIm5ld1N0YXJ0IiwiRGF0ZSIsIm5ld0VuZCIsImVuZFRpbWUiLCJldmVudFN0YXJ0IiwiZXZlbnRFbmQiLCJoYXNDb25mbGljdCIsImV4aXN0aW5nRXZlbnQiLCJleGlzdGluZ1ByaW9yaXR5IiwibmV3UHJpb3JpdHkiLCJsZW5ndGgiLCJuZXdQcmlvcml0eVNjb3JlIiwiaGlnaGVzdENvbmZsaWN0U2NvcmUiLCJNYXRoIiwibWF4IiwibWFwIiwiZSIsIm5ld0V2ZW50U2NvcmUiLCJ3aWxsUmVzY2hlZHVsZUNvbmZsaWN0cyIsInN0b3JhZ2UiLCJnZXRJbnN0YW5jZSIsImZvckVhY2giLCJjb25mbGljdCIsImR1cmF0aW9uIiwiZ2V0VGltZSIsIm5ld1N0YXJ0VGltZSIsIm5ld0VuZFRpbWUiLCJ1cGRhdGVkRXZlbnQiLCJ0b0lTT1N0cmluZyIsImZyb20iLCJ0byIsInVwZGF0ZVRpbWVCbG9jayIsImxhc3RDb25mbGljdCIsInNvcnQiLCJhIiwiYiIsInJlc2NoZWR1bGVkRXZlbnQiLCJwYXJzZVRpbWVTdHJpbmciLCJ0aW1lU3RyIiwiZGF0ZSIsImlzTmFOIiwidG9kYXkiLCJ0aW1lUmVnZXgiLCJtYXRjaCIsIl8iLCJob3VycyIsIm1pbnV0ZXMiLCJtZXJpZGllbSIsImhvdXIiLCJwYXJzZUludCIsInRvVXBwZXJDYXNlIiwic2V0SG91cnMiLCJFcnJvciIsInBhcnNlRGF0ZSIsImRhdGVTdHIiLCJlcnJvciIsInNlbmRNZXNzYWdlIiwiY29udGVudCIsImFnZW50IiwicHJvbXB0IiwiZnVuY3Rpb25IYW5kbGVycyIsImZvcm1hdHRlZFByb21wdCIsImZvcm1hdE1lc3NhZ2VzIiwiaW5wdXQiLCJyZXNwb25zZSIsImludm9rZSIsIm1lc3NhZ2VDb250ZW50IiwiY29kZUJsb2NrTWF0Y2giLCJwYXJhbXNUZXh0IiwicGFyYW1zIiwibG9jYXRpb24iLCJuZWVkc1RyYW5zcG9ydCIsImluY2x1ZGVzIiwiZGVsZWdhdGFibGUiLCJnZXRUaW1lQmxvY2tzIiwidHJhbnNwb3J0RGV0YWlscyIsInRheGlTZXJ2aWNlIiwiZXN0aW1hdGUiLCJlc3RpbWF0ZVRyaXAiLCJhdmFpbGFibGUiLCJwaWNrdXBUaW1lIiwic2V0TWludXRlcyIsImdldE1pbnV0ZXMiLCJwYXltZW50RGV0YWlscyIsImdldFBheW1lbnREZXRhaWxzIiwicGF5bWVudFN0YXR1cyIsInRyYW5zYWN0aW9uSGFzaCIsInR4SGFzaCIsImlzQ29uZmlybWVkIiwidmVyaWZ5UGF5bWVudCIsInNjaGVkdWxlZEV2ZW50IiwiX2lkIiwiY3J5cHRvIiwicmFuZG9tVVVJRCIsInBheW1lbnRIYXNoIiwic3RhdHVzIiwiY3JlYXRlZF9hdCIsInVwZGF0ZWRfYXQiLCJ0b0xvY2FsZVN0cmluZyIsInRvTG9jYWxlVGltZVN0cmluZyIsImZpbmFsRXZlbnQiLCJhZGRUaW1lQmxvY2siLCJDdXN0b21FdmVudCIsImRldGFpbCIsIndpbmRvdyIsImRpc3BhdGNoRXZlbnQiLCJwcmV2Iiwicm9sZSIsInRpbWVzdGFtcCIsIm1lc3NhZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useChatbot.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/services/taxiService.ts":
/*!*************************************!*\
  !*** ./src/services/taxiService.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TaxiService: function() { return /* binding */ TaxiService; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/../../../node_modules/ethers/lib.esm/utils/units.js\");\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/../../../node_modules/ethers/lib.esm/providers/provider-jsonrpc.js\");\n/* harmony import */ var _faucetService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./faucetService */ \"(app-pages-browser)/./src/services/faucetService.ts\");\n\n\nclass TaxiService {\n    static getInstance() {\n        if (!TaxiService.instance) {\n            TaxiService.instance = new TaxiService();\n        }\n        return TaxiService.instance;\n    }\n    async estimateTrip(from, to) {\n        // Mock estimation based on addresses\n        const mockDuration = Math.floor(Math.random() * 30) + 15; // 15-45 minutes\n        const cost = 0.000001; // Fixed cost in ETH for demo\n        return {\n            duration: mockDuration,\n            cost,\n            available: true\n        };\n    }\n    async getPaymentDetails(from, to) {\n        const estimate = await this.estimateTrip(from, to);\n        try {\n            // Process payment using FaucetService\n            const faucetService = _faucetService__WEBPACK_IMPORTED_MODULE_0__.FaucetService.getInstance();\n            const txHash = await faucetService.requestAndSendETH(this.TAXI_ADDRESS, estimate.cost);\n            console.log(\"Payment processed:\", {\n                to: this.TAXI_ADDRESS,\n                amount: estimate.cost,\n                txHash\n            });\n            return {\n                address: this.TAXI_ADDRESS,\n                amount: ethers__WEBPACK_IMPORTED_MODULE_1__.parseEther(estimate.cost.toString()).toString(),\n                network: \"base-sepolia\",\n                txHash\n            };\n        } catch (error) {\n            console.error(\"Failed to process payment:\", error);\n            return {\n                address: this.TAXI_ADDRESS,\n                amount: ethers__WEBPACK_IMPORTED_MODULE_1__.parseEther(estimate.cost.toString()).toString(),\n                network: \"base-sepolia\"\n            };\n        }\n    }\n    async verifyPayment(txHash) {\n        try {\n            const receipt = await this.provider.getTransactionReceipt(txHash);\n            return receipt !== null && receipt.status === 1;\n        } catch (error) {\n            console.error(\"Error verifying payment:\", error);\n            return false;\n        }\n    }\n    constructor(){\n        this.TAXI_ADDRESS = \"0x0680Fb58A8CF5c2f0090D9DC487003a8Ff49Abb6\";\n        this.provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider(\"https://sepolia.base.org\");\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9zZXJ2aWNlcy90YXhpU2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdDO0FBQ2dCO0FBUXpDLE1BQU1FO0lBU1gsT0FBT0MsY0FBMkI7UUFDaEMsSUFBSSxDQUFDRCxZQUFZRSxRQUFRLEVBQUU7WUFDekJGLFlBQVlFLFFBQVEsR0FBRyxJQUFJRjtRQUM3QjtRQUNBLE9BQU9BLFlBQVlFLFFBQVE7SUFDN0I7SUFFQSxNQUFNQyxhQUFhQyxJQUFZLEVBQUVDLEVBQVUsRUFBeUI7UUFDbEUscUNBQXFDO1FBQ3JDLE1BQU1DLGVBQWVDLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFLLE1BQU0sSUFBSSxnQkFBZ0I7UUFDMUUsTUFBTUMsT0FBTyxVQUFVLDZCQUE2QjtRQUVwRCxPQUFPO1lBQ0xDLFVBQVVMO1lBQ1ZJO1lBQ0FFLFdBQVc7UUFDYjtJQUNGO0lBRUEsTUFBTUMsa0JBQWtCVCxJQUFZLEVBQUVDLEVBQVUsRUFLN0M7UUFDRCxNQUFNUyxXQUFXLE1BQU0sSUFBSSxDQUFDWCxZQUFZLENBQUNDLE1BQU1DO1FBRS9DLElBQUk7WUFDRixzQ0FBc0M7WUFDdEMsTUFBTVUsZ0JBQWdCaEIseURBQWFBLENBQUNFLFdBQVc7WUFDL0MsTUFBTWUsU0FBUyxNQUFNRCxjQUFjRSxpQkFBaUIsQ0FDbEQsSUFBSSxDQUFDQyxZQUFZLEVBQ2pCSixTQUFTSixJQUFJO1lBR2ZTLFFBQVFDLEdBQUcsQ0FBQyxzQkFBc0I7Z0JBQ2hDZixJQUFJLElBQUksQ0FBQ2EsWUFBWTtnQkFDckJHLFFBQVFQLFNBQVNKLElBQUk7Z0JBQ3JCTTtZQUNGO1lBRUEsT0FBTztnQkFDTE0sU0FBUyxJQUFJLENBQUNKLFlBQVk7Z0JBQzFCRyxRQUFRdkIsOENBQWlCLENBQUNnQixTQUFTSixJQUFJLENBQUNjLFFBQVEsSUFBSUEsUUFBUTtnQkFDNURDLFNBQVM7Z0JBQ1RUO1lBQ0Y7UUFDRixFQUFFLE9BQU9VLE9BQU87WUFDZFAsUUFBUU8sS0FBSyxDQUFDLDhCQUE4QkE7WUFDNUMsT0FBTztnQkFDTEosU0FBUyxJQUFJLENBQUNKLFlBQVk7Z0JBQzFCRyxRQUFRdkIsOENBQWlCLENBQUNnQixTQUFTSixJQUFJLENBQUNjLFFBQVEsSUFBSUEsUUFBUTtnQkFDNURDLFNBQVM7WUFDWDtRQUNGO0lBQ0Y7SUFFQSxNQUFNRSxjQUFjWCxNQUFjLEVBQW9CO1FBQ3BELElBQUk7WUFDRixNQUFNWSxVQUFVLE1BQU0sSUFBSSxDQUFDQyxRQUFRLENBQUNDLHFCQUFxQixDQUFDZDtZQUMxRCxPQUFPWSxZQUFZLFFBQVFBLFFBQVFHLE1BQU0sS0FBSztRQUNoRCxFQUFFLE9BQU9MLE9BQU87WUFDZFAsUUFBUU8sS0FBSyxDQUFDLDRCQUE0QkE7WUFDMUMsT0FBTztRQUNUO0lBQ0Y7SUFyRUEsYUFBc0I7YUFGTFIsZUFBZTtRQUc5QixJQUFJLENBQUNXLFFBQVEsR0FBRyxJQUFJL0IsbURBQXNCLENBQUM7SUFDN0M7QUFvRUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3NlcnZpY2VzL3RheGlTZXJ2aWNlLnRzP2FjOTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXRoZXJzIH0gZnJvbSAnZXRoZXJzJztcbmltcG9ydCB7IEZhdWNldFNlcnZpY2UgfSBmcm9tICcuL2ZhdWNldFNlcnZpY2UnO1xuXG5pbnRlcmZhY2UgVGF4aUVzdGltYXRlIHtcbiAgZHVyYXRpb246IG51bWJlcjsgIC8vIGluIG1pbnV0ZXNcbiAgY29zdDogbnVtYmVyOyAgICAgLy8gaW4gRVRIXG4gIGF2YWlsYWJsZTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNsYXNzIFRheGlTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IFRheGlTZXJ2aWNlO1xuICBwcml2YXRlIHByb3ZpZGVyOiBldGhlcnMuSnNvblJwY1Byb3ZpZGVyO1xuICBwcml2YXRlIHJlYWRvbmx5IFRBWElfQUREUkVTUyA9ICcweDA2ODBGYjU4QThDRjVjMmYwMDkwRDlEQzQ4NzAwM2E4RmY0OUFiYjYnO1xuICBcbiAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoJ2h0dHBzOi8vc2Vwb2xpYS5iYXNlLm9yZycpO1xuICB9XG5cbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IFRheGlTZXJ2aWNlIHtcbiAgICBpZiAoIVRheGlTZXJ2aWNlLmluc3RhbmNlKSB7XG4gICAgICBUYXhpU2VydmljZS5pbnN0YW5jZSA9IG5ldyBUYXhpU2VydmljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gVGF4aVNlcnZpY2UuaW5zdGFuY2U7XG4gIH1cblxuICBhc3luYyBlc3RpbWF0ZVRyaXAoZnJvbTogc3RyaW5nLCB0bzogc3RyaW5nKTogUHJvbWlzZTxUYXhpRXN0aW1hdGU+IHtcbiAgICAvLyBNb2NrIGVzdGltYXRpb24gYmFzZWQgb24gYWRkcmVzc2VzXG4gICAgY29uc3QgbW9ja0R1cmF0aW9uID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMzApICsgMTU7IC8vIDE1LTQ1IG1pbnV0ZXNcbiAgICBjb25zdCBjb3N0ID0gMC4wMDAwMDE7IC8vIEZpeGVkIGNvc3QgaW4gRVRIIGZvciBkZW1vXG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIGR1cmF0aW9uOiBtb2NrRHVyYXRpb24sXG4gICAgICBjb3N0LFxuICAgICAgYXZhaWxhYmxlOiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGdldFBheW1lbnREZXRhaWxzKGZyb206IHN0cmluZywgdG86IHN0cmluZyk6IFByb21pc2U8e1xuICAgIGFkZHJlc3M6IHN0cmluZyxcbiAgICBhbW91bnQ6IHN0cmluZyxcbiAgICBuZXR3b3JrOiBzdHJpbmcsXG4gICAgdHhIYXNoPzogc3RyaW5nXG4gIH0+IHtcbiAgICBjb25zdCBlc3RpbWF0ZSA9IGF3YWl0IHRoaXMuZXN0aW1hdGVUcmlwKGZyb20sIHRvKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gUHJvY2VzcyBwYXltZW50IHVzaW5nIEZhdWNldFNlcnZpY2VcbiAgICAgIGNvbnN0IGZhdWNldFNlcnZpY2UgPSBGYXVjZXRTZXJ2aWNlLmdldEluc3RhbmNlKCk7XG4gICAgICBjb25zdCB0eEhhc2ggPSBhd2FpdCBmYXVjZXRTZXJ2aWNlLnJlcXVlc3RBbmRTZW5kRVRIKFxuICAgICAgICB0aGlzLlRBWElfQUREUkVTUyxcbiAgICAgICAgZXN0aW1hdGUuY29zdFxuICAgICAgKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ1BheW1lbnQgcHJvY2Vzc2VkOicsIHtcbiAgICAgICAgdG86IHRoaXMuVEFYSV9BRERSRVNTLFxuICAgICAgICBhbW91bnQ6IGVzdGltYXRlLmNvc3QsXG4gICAgICAgIHR4SGFzaFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3M6IHRoaXMuVEFYSV9BRERSRVNTLFxuICAgICAgICBhbW91bnQ6IGV0aGVycy5wYXJzZUV0aGVyKGVzdGltYXRlLmNvc3QudG9TdHJpbmcoKSkudG9TdHJpbmcoKSxcbiAgICAgICAgbmV0d29yazogJ2Jhc2Utc2Vwb2xpYScsXG4gICAgICAgIHR4SGFzaFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHByb2Nlc3MgcGF5bWVudDonLCBlcnJvcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiB0aGlzLlRBWElfQUREUkVTUyxcbiAgICAgICAgYW1vdW50OiBldGhlcnMucGFyc2VFdGhlcihlc3RpbWF0ZS5jb3N0LnRvU3RyaW5nKCkpLnRvU3RyaW5nKCksXG4gICAgICAgIG5ldHdvcms6ICdiYXNlLXNlcG9saWEnXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHZlcmlmeVBheW1lbnQodHhIYXNoOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVjZWlwdCA9IGF3YWl0IHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHR4SGFzaCk7XG4gICAgICByZXR1cm4gcmVjZWlwdCAhPT0gbnVsbCAmJiByZWNlaXB0LnN0YXR1cyA9PT0gMTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdmVyaWZ5aW5nIHBheW1lbnQ6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSAiXSwibmFtZXMiOlsiZXRoZXJzIiwiRmF1Y2V0U2VydmljZSIsIlRheGlTZXJ2aWNlIiwiZ2V0SW5zdGFuY2UiLCJpbnN0YW5jZSIsImVzdGltYXRlVHJpcCIsImZyb20iLCJ0byIsIm1vY2tEdXJhdGlvbiIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImNvc3QiLCJkdXJhdGlvbiIsImF2YWlsYWJsZSIsImdldFBheW1lbnREZXRhaWxzIiwiZXN0aW1hdGUiLCJmYXVjZXRTZXJ2aWNlIiwidHhIYXNoIiwicmVxdWVzdEFuZFNlbmRFVEgiLCJUQVhJX0FERFJFU1MiLCJjb25zb2xlIiwibG9nIiwiYW1vdW50IiwiYWRkcmVzcyIsInBhcnNlRXRoZXIiLCJ0b1N0cmluZyIsIm5ldHdvcmsiLCJlcnJvciIsInZlcmlmeVBheW1lbnQiLCJyZWNlaXB0IiwicHJvdmlkZXIiLCJnZXRUcmFuc2FjdGlvblJlY2VpcHQiLCJzdGF0dXMiLCJKc29uUnBjUHJvdmlkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/services/taxiService.ts\n"));

/***/ })

});