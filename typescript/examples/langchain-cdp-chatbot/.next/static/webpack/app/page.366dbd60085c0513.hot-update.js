"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/hooks/useChatbot.ts":
/*!*********************************!*\
  !*** ./src/hooks/useChatbot.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChatbot: function() { return /* binding */ useChatbot; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../../node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _services_chatbot__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/services/chatbot */ \"(app-pages-browser)/./src/services/chatbot.ts\");\n/* harmony import */ var _lib_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/storage */ \"(app-pages-browser)/./src/lib/storage.ts\");\n/* harmony import */ var _services_taxiService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/taxiService */ \"(app-pages-browser)/./src/services/taxiService.ts\");\n/* __next_internal_client_entry_do_not_use__ useChatbot auto */ \n\n\n\nfunction useChatbot() {\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Load chat history from localStorage on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const savedMessages = localStorage.getItem(\"chat_history\");\n        if (savedMessages) {\n            setMessages(JSON.parse(savedMessages));\n        }\n    }, []);\n    // Save messages to localStorage whenever they change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        localStorage.setItem(\"chat_history\", JSON.stringify(messages));\n    }, [\n        messages\n    ]);\n    const handleScheduleConflict = (newEvent, existingEvents)=>{\n        console.log(\"Checking conflicts for new event:\", {\n            title: newEvent.title,\n            start: newEvent.startTime,\n            priority: newEvent.priority\n        });\n        console.log(\"Existing events:\", existingEvents);\n        // Sort existing events by priority\n        const priorityOrder = {\n            \"urgent-important\": 3,\n            \"important\": 2,\n            \"urgent\": 1,\n            \"neither\": 0\n        };\n        // Find conflicting events\n        const conflicts = existingEvents.filter((event)=>{\n            const newStart = new Date(newEvent.startTime);\n            const newEnd = new Date(newEvent.endTime);\n            const eventStart = new Date(event.startTime);\n            const eventEnd = new Date(event.endTime);\n            const hasConflict = newStart >= eventStart && newStart < eventEnd || newEnd > eventStart && newEnd <= eventEnd || newStart <= eventStart && newEnd >= eventEnd;\n            if (hasConflict) {\n                console.log(\"Found conflict:\", {\n                    existingEvent: event.title,\n                    existingPriority: event.priority,\n                    newEvent: newEvent.title,\n                    newPriority: newEvent.priority\n                });\n            }\n            return hasConflict;\n        });\n        if (conflicts.length === 0) {\n            console.log(\"No conflicts found\");\n            return newEvent;\n        }\n        // Check if new event has higher priority\n        const newPriorityScore = priorityOrder[newEvent.priority];\n        const highestConflictScore = Math.max(...conflicts.map((e)=>priorityOrder[e.priority]));\n        console.log(\"Priority comparison:\", {\n            newEventScore: newPriorityScore,\n            highestConflictScore,\n            willRescheduleConflicts: newPriorityScore > highestConflictScore\n        });\n        if (newPriorityScore > highestConflictScore) {\n            // Move conflicting events\n            console.log(\"Moving conflicting events...\");\n            const storage = _lib_storage__WEBPACK_IMPORTED_MODULE_2__.StorageService.getInstance();\n            conflicts.forEach((conflict)=>{\n                // Move to next available time\n                const duration = new Date(conflict.endTime).getTime() - new Date(conflict.startTime).getTime();\n                const newStartTime = new Date(newEvent.endTime);\n                const newEndTime = new Date(newStartTime.getTime() + duration);\n                const updatedEvent = {\n                    ...conflict,\n                    startTime: newStartTime.toISOString(),\n                    endTime: newEndTime.toISOString()\n                };\n                console.log(\"Moving event:\", {\n                    event: conflict.title,\n                    from: conflict.startTime,\n                    to: updatedEvent.startTime\n                });\n                storage.updateTimeBlock(updatedEvent);\n            });\n            return newEvent;\n        } else {\n            // Find next available time for new event\n            console.log(\"Finding next available time for new event...\");\n            const duration = new Date(newEvent.endTime).getTime() - new Date(newEvent.startTime).getTime();\n            const lastConflict = conflicts.sort((a, b)=>new Date(b.endTime).getTime() - new Date(a.endTime).getTime())[0];\n            const newStartTime = new Date(lastConflict.endTime);\n            const newEndTime = new Date(newStartTime.getTime() + duration);\n            const rescheduledEvent = {\n                ...newEvent,\n                startTime: newStartTime.toISOString(),\n                endTime: newEndTime.toISOString()\n            };\n            console.log(\"Rescheduled new event:\", {\n                from: newEvent.startTime,\n                to: rescheduledEvent.startTime\n            });\n            return rescheduledEvent;\n        }\n    };\n    const parseTimeString = (timeStr)=>{\n        // Try ISO format first\n        let date = new Date(timeStr);\n        if (!isNaN(date.getTime())) {\n            return date;\n        }\n        // Try parsing human-readable time formats\n        const today = new Date();\n        const timeRegex = /(\\d{1,2}):(\\d{2})\\s*(AM|PM|am|pm)?/;\n        const match = timeStr.match(timeRegex);\n        if (match) {\n            let [_, hours, minutes, meridiem] = match;\n            let hour = parseInt(hours);\n            // Convert to 24-hour format if meridiem is provided\n            if (meridiem) {\n                if (meridiem.toUpperCase() === \"PM\" && hour < 12) hour += 12;\n                if (meridiem.toUpperCase() === \"AM\" && hour === 12) hour = 0;\n            }\n            date = new Date(today);\n            date.setHours(hour, parseInt(minutes), 0, 0);\n            return date;\n        }\n        throw new Error(\"Unable to parse time: \".concat(timeStr));\n    };\n    const parseDate = (dateStr)=>{\n        try {\n            // If it's just a time string, parse it as time\n            if (dateStr.match(/^\\d{1,2}:\\d{2}(\\s*[AaPp][Mm])?$/)) {\n                return parseTimeString(dateStr);\n            }\n            // Try parsing as full date\n            const date = new Date(dateStr);\n            if (!isNaN(date.getTime())) {\n                return date;\n            }\n            throw new Error(\"Invalid date: \".concat(dateStr));\n        } catch (error) {\n            console.error(\"Date parsing error:\", error);\n            throw new Error(\"Invalid date format: \".concat(dateStr));\n        }\n    };\n    const sendMessage = async (content)=>{\n        console.log(\"=== START sendMessage ===\");\n        setIsLoading(true);\n        try {\n            // Initialize agent\n            console.log(\"Initializing agent...\");\n            const { agent, prompt, functionHandlers } = await (0,_services_chatbot__WEBPACK_IMPORTED_MODULE_1__.initializeAgent)();\n            console.log(\"Agent initialized successfully\");\n            // Format the prompt\n            const formattedPrompt = await prompt.formatMessages({\n                input: content\n            });\n            // Call agent\n            console.log(\"Calling agent...\");\n            const response = await agent.invoke(formattedPrompt);\n            console.log(\"Agent response received:\", response);\n            // Extract content\n            let messageContent = response.content;\n            // Look for schedule task\n            const codeBlockMatch = messageContent.match(/```[\\s\\S]*?schedule_task\\(([\\s\\S]*?)\\)[\\s\\S]*?```/);\n            if (codeBlockMatch) {\n                const paramsText = codeBlockMatch[1];\n                const params = {\n                    title: (paramsText.match(/title=\"([^\"]+)\"/) || [])[1],\n                    startTime: (paramsText.match(/startTime=\"([^\"]+)\"/) || [])[1],\n                    endTime: (paramsText.match(/endTime=\"([^\"]+)\"/) || [])[1],\n                    priority: (paramsText.match(/priority=\"([^\"]+)\"/) || [])[1],\n                    location: (paramsText.match(/location=\"([^\"]+)\"/) || [])[1],\n                    needsTransport: paramsText.includes(\"needsTransport=True\"),\n                    delegatable: paramsText.includes(\"delegatable=True\")\n                };\n                if (params.title && params.startTime) {\n                    // Validate and parse dates\n                    const startTime = parseDate(params.startTime);\n                    const endTime = params.endTime ? parseDate(params.endTime) : new Date(startTime.getTime() + 60 * 60 * 1000);\n                    const storage = _lib_storage__WEBPACK_IMPORTED_MODULE_2__.StorageService.getInstance();\n                    const existingEvents = storage.getTimeBlocks();\n                    // Handle transportation if needed\n                    if (params.needsTransport && params.location) {\n                        const taxiService = _services_taxiService__WEBPACK_IMPORTED_MODULE_3__.TaxiService.getInstance();\n                        const estimate = await taxiService.estimateTrip(\"current_location\", params.location);\n                        if (estimate.available) {\n                            try {\n                                // Add buffer time for transportation\n                                const pickupTime = new Date(startTime.getTime());\n                                pickupTime.setMinutes(pickupTime.getMinutes() - estimate.duration);\n                                // Process payment first - this actually sends ETH\n                                console.log(\"Processing taxi payment...\");\n                                const paymentDetails = await taxiService.getPaymentDetails(\"current_location\", params.location);\n                                if (!paymentDetails.txHash) {\n                                    throw new Error(\"Failed to process payment\");\n                                }\n                                console.log(\"Payment processed:\", paymentDetails);\n                                // Wait for confirmation\n                                const isConfirmed = await taxiService.verifyPayment(paymentDetails.txHash);\n                                const paymentStatus = isConfirmed ? \"Confirmed\" : \"Failed\";\n                                if (!isConfirmed) {\n                                    throw new Error(\"Payment failed to confirm\");\n                                }\n                                const scheduledEvent = {\n                                    _id: crypto.randomUUID(),\n                                    title: params.title,\n                                    startTime: pickupTime.toISOString(),\n                                    endTime: endTime.toISOString(),\n                                    priority: params.priority || \"important\",\n                                    location: params.location,\n                                    transportDetails: {\n                                        pickupTime: pickupTime.toISOString(),\n                                        paymentHash: paymentDetails.txHash,\n                                        paymentStatus\n                                    },\n                                    delegatable: params.delegatable || false,\n                                    status: \"scheduled\",\n                                    created_at: new Date().toISOString(),\n                                    updated_at: new Date().toISOString()\n                                };\n                                messageContent = \"\\uD83D\\uDCC5 Event Scheduled: \".concat(params.title, \"\\n⏰ Time: \").concat(startTime.toLocaleString(), \" - \").concat(endTime.toLocaleString(), \"\\n\\uD83D\\uDCCD Location: \").concat(params.location, \"\\n\\uD83D\\uDE95 Transport: Taxi booked for \").concat(pickupTime.toLocaleTimeString(), \"\\n\\uD83D\\uDCB0 Payment: \").concat(paymentStatus, \"\\n\\uD83D\\uDCB3 Transaction: \").concat(paymentDetails.txHash);\n                                const finalEvent = handleScheduleConflict(scheduledEvent, existingEvents);\n                                storage.addTimeBlock(finalEvent);\n                                const event = new CustomEvent(\"calendarUpdate\", {\n                                    detail: finalEvent\n                                });\n                                window.dispatchEvent(event);\n                            } catch (error) {\n                                console.error(\"Failed to process taxi payment:\", error);\n                                messageContent = \"❌ Failed to schedule event: \".concat(error.message);\n                            }\n                        }\n                    }\n                }\n            }\n            // Add message to chat history\n            setMessages((prev)=>[\n                    ...prev,\n                    {\n                        content: messageContent,\n                        role: \"assistant\",\n                        timestamp: new Date().toISOString()\n                    }\n                ]);\n        } catch (error) {\n            console.error(\"Error in sendMessage:\", error);\n            setMessages((prev)=>[\n                    ...prev,\n                    {\n                        content: \"Error: \".concat(error.message),\n                        role: \"system\",\n                        timestamp: new Date().toISOString()\n                    }\n                ]);\n        } finally{\n            setIsLoading(false);\n        }\n    };\n    return {\n        messages,\n        setMessages,\n        isLoading,\n        sendMessage\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VDaGF0Ym90LnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztnRUFFNEM7QUFDUztBQUNOO0FBQ007QUFFOUMsU0FBU0s7SUFDZCxNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR1AsK0NBQVFBLENBQVEsRUFBRTtJQUNsRCxNQUFNLENBQUNRLFdBQVdDLGFBQWEsR0FBR1QsK0NBQVFBLENBQUM7SUFFM0MsK0NBQStDO0lBQy9DQyxnREFBU0EsQ0FBQztRQUNSLE1BQU1TLGdCQUFnQkMsYUFBYUMsT0FBTyxDQUFDO1FBQzNDLElBQUlGLGVBQWU7WUFDakJILFlBQVlNLEtBQUtDLEtBQUssQ0FBQ0o7UUFDekI7SUFDRixHQUFHLEVBQUU7SUFFTCxxREFBcUQ7SUFDckRULGdEQUFTQSxDQUFDO1FBQ1JVLGFBQWFJLE9BQU8sQ0FBQyxnQkFBZ0JGLEtBQUtHLFNBQVMsQ0FBQ1Y7SUFDdEQsR0FBRztRQUFDQTtLQUFTO0lBRWIsTUFBTVcseUJBQXlCLENBQUNDLFVBQXFCQztRQUNuREMsUUFBUUMsR0FBRyxDQUFDLHFDQUFxQztZQUMvQ0MsT0FBT0osU0FBU0ksS0FBSztZQUNyQkMsT0FBT0wsU0FBU00sU0FBUztZQUN6QkMsVUFBVVAsU0FBU08sUUFBUTtRQUM3QjtRQUNBTCxRQUFRQyxHQUFHLENBQUMsb0JBQW9CRjtRQUVoQyxtQ0FBbUM7UUFDbkMsTUFBTU8sZ0JBQWdCO1lBQ3BCLG9CQUFvQjtZQUNwQixhQUFhO1lBQ2IsVUFBVTtZQUNWLFdBQVc7UUFDYjtRQUVBLDBCQUEwQjtRQUMxQixNQUFNQyxZQUFZUixlQUFlUyxNQUFNLENBQUNDLENBQUFBO1lBQ3RDLE1BQU1DLFdBQVcsSUFBSUMsS0FBS2IsU0FBU00sU0FBUztZQUM1QyxNQUFNUSxTQUFTLElBQUlELEtBQUtiLFNBQVNlLE9BQU87WUFDeEMsTUFBTUMsYUFBYSxJQUFJSCxLQUFLRixNQUFNTCxTQUFTO1lBQzNDLE1BQU1XLFdBQVcsSUFBSUos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TUFBTWtELE9BQU87NEJBQy9EO3dCQUNGO29CQUNGO2dCQUNGO1lBQ0Y7WUFFQSw4QkFBOEI7WUFDOUJoSSxZQUFZaUksQ0FBQUEsT0FBUTt1QkFBSUE7b0JBQU07d0JBQzVCakQsU0FBU1M7d0JBQ1R5QyxNQUFNO3dCQUNOQyxXQUFXLElBQUkzRyxPQUFPMkIsV0FBVztvQkFDbkM7aUJBQUU7UUFFSixFQUFFLE9BQU8yQixPQUFPO1lBQ2RqRSxRQUFRaUUsS0FBSyxDQUFDLHlCQUF5QkE7WUFDdkM5RSxZQUFZaUksQ0FBQUEsT0FBUTt1QkFBSUE7b0JBQU07d0JBQzVCakQsU0FBUyxVQUF3QixPQUFkRixNQUFNa0QsT0FBTzt3QkFDaENFLE1BQU07d0JBQ05DLFdBQVcsSUFBSTNHLE9BQU8yQixXQUFXO29CQUNuQztpQkFBRTtRQUNKLFNBQVU7WUFDUmpELGFBQWE7UUFDZjtJQUNGO0lBRUEsT0FBTztRQUNMSDtRQUNBQztRQUNBQztRQUNBOEU7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9ob29rcy91c2VDaGF0Ym90LnRzP2Q0NmYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaW5pdGlhbGl6ZUFnZW50IH0gZnJvbSAnQC9zZXJ2aWNlcy9jaGF0Ym90JztcbmltcG9ydCB7IFN0b3JhZ2VTZXJ2aWNlIH0gZnJvbSAnQC9saWIvc3RvcmFnZSc7XG5pbXBvcnQgeyBUYXhpU2VydmljZSB9IGZyb20gJ0Avc2VydmljZXMvdGF4aVNlcnZpY2UnO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hhdGJvdCgpIHtcbiAgY29uc3QgW21lc3NhZ2VzLCBzZXRNZXNzYWdlc10gPSB1c2VTdGF0ZTxhbnlbXT4oW10pO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIC8vIExvYWQgY2hhdCBoaXN0b3J5IGZyb20gbG9jYWxTdG9yYWdlIG9uIG1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgc2F2ZWRNZXNzYWdlcyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdjaGF0X2hpc3RvcnknKTtcbiAgICBpZiAoc2F2ZWRNZXNzYWdlcykge1xuICAgICAgc2V0TWVzc2FnZXMoSlNPTi5wYXJzZShzYXZlZE1lc3NhZ2VzKSk7XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgLy8gU2F2ZSBtZXNzYWdlcyB0byBsb2NhbFN0b3JhZ2Ugd2hlbmV2ZXIgdGhleSBjaGFuZ2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnY2hhdF9oaXN0b3J5JywgSlNPTi5zdHJpbmdpZnkobWVzc2FnZXMpKTtcbiAgfSwgW21lc3NhZ2VzXSk7XG5cbiAgY29uc3QgaGFuZGxlU2NoZWR1bGVDb25mbGljdCA9IChuZXdFdmVudDogVGltZUJsb2NrLCBleGlzdGluZ0V2ZW50czogVGltZUJsb2NrW10pID0+IHtcbiAgICBjb25zb2xlLmxvZygnQ2hlY2tpbmcgY29uZmxpY3RzIGZvciBuZXcgZXZlbnQ6Jywge1xuICAgICAgdGl0bGU6IG5ld0V2ZW50LnRpdGxlLFxuICAgICAgc3RhcnQ6IG5ld0V2ZW50LnN0YXJ0VGltZSxcbiAgICAgIHByaW9yaXR5OiBuZXdFdmVudC5wcmlvcml0eVxuICAgIH0pO1xuICAgIGNvbnNvbGUubG9nKCdFeGlzdGluZyBldmVudHM6JywgZXhpc3RpbmdFdmVudHMpO1xuXG4gICAgLy8gU29ydCBleGlzdGluZyBldmVudHMgYnkgcHJpb3JpdHlcbiAgICBjb25zdCBwcmlvcml0eU9yZGVyID0ge1xuICAgICAgJ3VyZ2VudC1pbXBvcnRhbnQnOiAzLFxuICAgICAgJ2ltcG9ydGFudCc6IDIsXG4gICAgICAndXJnZW50JzogMSxcbiAgICAgICduZWl0aGVyJzogMFxuICAgIH07XG5cbiAgICAvLyBGaW5kIGNvbmZsaWN0aW5nIGV2ZW50c1xuICAgIGNvbnN0IGNvbmZsaWN0cyA9IGV4aXN0aW5nRXZlbnRzLmZpbHRlcihldmVudCA9PiB7XG4gICAgICBjb25zdCBuZXdTdGFydCA9IG5ldyBEYXRlKG5ld0V2ZW50LnN0YXJ0VGltZSk7XG4gICAgICBjb25zdCBuZXdFbmQgPSBuZXcgRGF0ZShuZXdFdmVudC5lbmRUaW1lKTtcbiAgICAgIGNvbnN0IGV2ZW50U3RhcnQgPSBuZXcgRGF0ZShldmVudC5zdGFydFRpbWUpO1xuICAgICAgY29uc3QgZXZlbnRFbmQgPSBuZXcgRGF0ZShldmVudC5lbmRUaW1lKTtcbiAgICAgIFxuICAgICAgY29uc3QgaGFzQ29uZmxpY3QgPSAoXG4gICAgICAgIChuZXdTdGFydCA+PSBldmVudFN0YXJ0ICYmIG5ld1N0YXJ0IDwgZXZlbnRFbmQpIHx8XG4gICAgICAgIChuZXdFbmQgPiBldmVudFN0YXJ0ICYmIG5ld0VuZCA8PSBldmVudEVuZCkgfHxcbiAgICAgICAgKG5ld1N0YXJ0IDw9IGV2ZW50U3RhcnQgJiYgbmV3RW5kID49IGV2ZW50RW5kKVxuICAgICAgKTtcblxuICAgICAgaWYgKGhhc0NvbmZsaWN0KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBjb25mbGljdDonLCB7XG4gICAgICAgICAgZXhpc3RpbmdFdmVudDogZXZlbnQudGl0bGUsXG4gICAgICAgICAgZXhpc3RpbmdQcmlvcml0eTogZXZlbnQucHJpb3JpdHksXG4gICAgICAgICAgbmV3RXZlbnQ6IG5ld0V2ZW50LnRpdGxlLFxuICAgICAgICAgIG5ld1ByaW9yaXR5OiBuZXdFdmVudC5wcmlvcml0eVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGhhc0NvbmZsaWN0O1xuICAgIH0pO1xuXG4gICAgaWYgKGNvbmZsaWN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCdObyBjb25mbGljdHMgZm91bmQnKTtcbiAgICAgIHJldHVybiBuZXdFdmVudDtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBuZXcgZXZlbnQgaGFzIGhpZ2hlciBwcmlvcml0eVxuICAgIGNvbnN0IG5ld1ByaW9yaXR5U2NvcmUgPSBwcmlvcml0eU9yZGVyW25ld0V2ZW50LnByaW9yaXR5XTtcbiAgICBjb25zdCBoaWdoZXN0Q29uZmxpY3RTY29yZSA9IE1hdGgubWF4KFxuICAgICAgLi4uY29uZmxpY3RzLm1hcChlID0+IHByaW9yaXR5T3JkZXJbZS5wcmlvcml0eV0pXG4gICAgKTtcblxuICAgIGNvbnNvbGUubG9nKCdQcmlvcml0eSBjb21wYXJpc29uOicsIHtcbiAgICAgIG5ld0V2ZW50U2NvcmU6IG5ld1ByaW9yaXR5U2NvcmUsXG4gICAgICBoaWdoZXN0Q29uZmxpY3RTY29yZSxcbiAgICAgIHdpbGxSZXNjaGVkdWxlQ29uZmxpY3RzOiBuZXdQcmlvcml0eVNjb3JlID4gaGlnaGVzdENvbmZsaWN0U2NvcmVcbiAgICB9KTtcblxuICAgIGlmIChuZXdQcmlvcml0eVNjb3JlID4gaGlnaGVzdENvbmZsaWN0U2NvcmUpIHtcbiAgICAgIC8vIE1vdmUgY29uZmxpY3RpbmcgZXZlbnRzXG4gICAgICBjb25zb2xlLmxvZygnTW92aW5nIGNvbmZsaWN0aW5nIGV2ZW50cy4uLicpO1xuICAgICAgY29uc3Qgc3RvcmFnZSA9IFN0b3JhZ2VTZXJ2aWNlLmdldEluc3RhbmNlKCk7XG4gICAgICBjb25mbGljdHMuZm9yRWFjaChjb25mbGljdCA9PiB7XG4gICAgICAgIC8vIE1vdmUgdG8gbmV4dCBhdmFpbGFibGUgdGltZVxuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IG5ldyBEYXRlKGNvbmZsaWN0LmVuZFRpbWUpLmdldFRpbWUoKSAtIG5ldyBEYXRlKGNvbmZsaWN0LnN0YXJ0VGltZSkuZ2V0VGltZSgpO1xuICAgICAgICBjb25zdCBuZXdTdGFydFRpbWUgPSBuZXcgRGF0ZShuZXdFdmVudC5lbmRUaW1lKTtcbiAgICAgICAgY29uc3QgbmV3RW5kVGltZSA9IG5ldyBEYXRlKG5ld1N0YXJ0VGltZS5nZXRUaW1lKCkgKyBkdXJhdGlvbik7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB1cGRhdGVkRXZlbnQgPSB7XG4gICAgICAgICAgLi4uY29uZmxpY3QsXG4gICAgICAgICAgc3RhcnRUaW1lOiBuZXdTdGFydFRpbWUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBlbmRUaW1lOiBuZXdFbmRUaW1lLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKCdNb3ZpbmcgZXZlbnQ6Jywge1xuICAgICAgICAgIGV2ZW50OiBjb25mbGljdC50aXRsZSxcbiAgICAgICAgICBmcm9tOiBjb25mbGljdC5zdGFydFRpbWUsXG4gICAgICAgICAgdG86IHVwZGF0ZWRFdmVudC5zdGFydFRpbWVcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBzdG9yYWdlLnVwZGF0ZVRpbWVCbG9jayh1cGRhdGVkRXZlbnQpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3RXZlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpbmQgbmV4dCBhdmFpbGFibGUgdGltZSBmb3IgbmV3IGV2ZW50XG4gICAgICBjb25zb2xlLmxvZygnRmluZGluZyBuZXh0IGF2YWlsYWJsZSB0aW1lIGZvciBuZXcgZXZlbnQuLi4nKTtcbiAgICAgIGNvbnN0IGR1cmF0aW9uID0gbmV3IERhdGUobmV3RXZlbnQuZW5kVGltZSkuZ2V0VGltZSgpIC0gbmV3IERhdGUobmV3RXZlbnQuc3RhcnRUaW1lKS5nZXRUaW1lKCk7XG4gICAgICBjb25zdCBsYXN0Q29uZmxpY3QgPSBjb25mbGljdHMuc29ydCgoYSwgYikgPT4gXG4gICAgICAgIG5ldyBEYXRlKGIuZW5kVGltZSkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYS5lbmRUaW1lKS5nZXRUaW1lKClcbiAgICAgIClbMF07XG4gICAgICBcbiAgICAgIGNvbnN0IG5ld1N0YXJ0VGltZSA9IG5ldyBEYXRlKGxhc3RDb25mbGljdC5lbmRUaW1lKTtcbiAgICAgIGNvbnN0IG5ld0VuZFRpbWUgPSBuZXcgRGF0ZShuZXdTdGFydFRpbWUuZ2V0VGltZSgpICsgZHVyYXRpb24pO1xuICAgICAgXG4gICAgICBjb25zdCByZXNjaGVkdWxlZEV2ZW50ID0ge1xuICAgICAgICAuLi5uZXdFdmVudCxcbiAgICAgICAgc3RhcnRUaW1lOiBuZXdTdGFydFRpbWUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgZW5kVGltZTogbmV3RW5kVGltZS50b0lTT1N0cmluZygpXG4gICAgICB9O1xuXG4gICAgICBjb25zb2xlLmxvZygnUmVzY2hlZHVsZWQgbmV3IGV2ZW50OicsIHtcbiAgICAgICAgZnJvbTogbmV3RXZlbnQuc3RhcnRUaW1lLFxuICAgICAgICB0bzogcmVzY2hlZHVsZWRFdmVudC5zdGFydFRpbWVcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4gcmVzY2hlZHVsZWRFdmVudDtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcGFyc2VUaW1lU3RyaW5nID0gKHRpbWVTdHI6IHN0cmluZyk6IERhdGUgPT4ge1xuICAgIC8vIFRyeSBJU08gZm9ybWF0IGZpcnN0XG4gICAgbGV0IGRhdGUgPSBuZXcgRGF0ZSh0aW1lU3RyKTtcbiAgICBpZiAoIWlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgLy8gVHJ5IHBhcnNpbmcgaHVtYW4tcmVhZGFibGUgdGltZSBmb3JtYXRzXG4gICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IHRpbWVSZWdleCA9IC8oXFxkezEsMn0pOihcXGR7Mn0pXFxzKihBTXxQTXxhbXxwbSk/LztcbiAgICBjb25zdCBtYXRjaCA9IHRpbWVTdHIubWF0Y2godGltZVJlZ2V4KTtcbiAgICBcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGxldCBbXywgaG91cnMsIG1pbnV0ZXMsIG1lcmlkaWVtXSA9IG1hdGNoO1xuICAgICAgbGV0IGhvdXIgPSBwYXJzZUludChob3Vycyk7XG4gICAgICBcbiAgICAgIC8vIENvbnZlcnQgdG8gMjQtaG91ciBmb3JtYXQgaWYgbWVyaWRpZW0gaXMgcHJvdmlkZWRcbiAgICAgIGlmIChtZXJpZGllbSkge1xuICAgICAgICBpZiAobWVyaWRpZW0udG9VcHBlckNhc2UoKSA9PT0gJ1BNJyAmJiBob3VyIDwgMTIpIGhvdXIgKz0gMTI7XG4gICAgICAgIGlmIChtZXJpZGllbS50b1VwcGVyQ2FzZSgpID09PSAnQU0nICYmIGhvdXIgPT09IDEyKSBob3VyID0gMDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZGF0ZSA9IG5ldyBEYXRlKHRvZGF5KTtcbiAgICAgIGRhdGUuc2V0SG91cnMoaG91ciwgcGFyc2VJbnQobWludXRlcyksIDAsIDApO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcGFyc2UgdGltZTogJHt0aW1lU3RyfWApO1xuICB9O1xuXG4gIGNvbnN0IHBhcnNlRGF0ZSA9IChkYXRlU3RyOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gSWYgaXQncyBqdXN0IGEgdGltZSBzdHJpbmcsIHBhcnNlIGl0IGFzIHRpbWVcbiAgICAgIGlmIChkYXRlU3RyLm1hdGNoKC9eXFxkezEsMn06XFxkezJ9KFxccypbQWFQcF1bTW1dKT8kLykpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlVGltZVN0cmluZyhkYXRlU3RyKTtcbiAgICAgIH1cblxuICAgICAgLy8gVHJ5IHBhcnNpbmcgYXMgZnVsbCBkYXRlXG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoZGF0ZVN0cik7XG4gICAgICBpZiAoIWlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGU6ICR7ZGF0ZVN0cn1gKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRGF0ZSBwYXJzaW5nIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRlIGZvcm1hdDogJHtkYXRlU3RyfWApO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBzZW5kTWVzc2FnZSA9IGFzeW5jIChjb250ZW50OiBzdHJpbmcpID0+IHtcbiAgICBjb25zb2xlLmxvZygnPT09IFNUQVJUIHNlbmRNZXNzYWdlID09PScpO1xuICAgIHNldElzTG9hZGluZyh0cnVlKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBJbml0aWFsaXplIGFnZW50XG4gICAgICBjb25zb2xlLmxvZygnSW5pdGlhbGl6aW5nIGFnZW50Li4uJyk7XG4gICAgICBjb25zdCB7IGFnZW50LCBwcm9tcHQsIGZ1bmN0aW9uSGFuZGxlcnMgfSA9IGF3YWl0IGluaXRpYWxpemVBZ2VudCgpO1xuICAgICAgY29uc29sZS5sb2coJ0FnZW50IGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseScpO1xuXG4gICAgICAvLyBGb3JtYXQgdGhlIHByb21wdFxuICAgICAgY29uc3QgZm9ybWF0dGVkUHJvbXB0ID0gYXdhaXQgcHJvbXB0LmZvcm1hdE1lc3NhZ2VzKHtcbiAgICAgICAgaW5wdXQ6IGNvbnRlbnRcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDYWxsIGFnZW50XG4gICAgICBjb25zb2xlLmxvZygnQ2FsbGluZyBhZ2VudC4uLicpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhZ2VudC5pbnZva2UoZm9ybWF0dGVkUHJvbXB0KTtcbiAgICAgIGNvbnNvbGUubG9nKCdBZ2VudCByZXNwb25zZSByZWNlaXZlZDonLCByZXNwb25zZSk7XG5cbiAgICAgIC8vIEV4dHJhY3QgY29udGVudFxuICAgICAgbGV0IG1lc3NhZ2VDb250ZW50ID0gcmVzcG9uc2UuY29udGVudDtcblxuICAgICAgLy8gTG9vayBmb3Igc2NoZWR1bGUgdGFza1xuICAgICAgY29uc3QgY29kZUJsb2NrTWF0Y2ggPSBtZXNzYWdlQ29udGVudC5tYXRjaCgvYGBgW1xcc1xcU10qP3NjaGVkdWxlX3Rhc2tcXCgoW1xcc1xcU10qPylcXClbXFxzXFxTXSo/YGBgLyk7XG4gICAgICBpZiAoY29kZUJsb2NrTWF0Y2gpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zVGV4dCA9IGNvZGVCbG9ja01hdGNoWzFdO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgdGl0bGU6IChwYXJhbXNUZXh0Lm1hdGNoKC90aXRsZT1cIihbXlwiXSspXCIvKSB8fCBbXSlbMV0sXG4gICAgICAgICAgc3RhcnRUaW1lOiAocGFyYW1zVGV4dC5tYXRjaCgvc3RhcnRUaW1lPVwiKFteXCJdKylcIi8pIHx8IFtdKVsxXSxcbiAgICAgICAgICBlbmRUaW1lOiAocGFyYW1zVGV4dC5tYXRjaCgvZW5kVGltZT1cIihbXlwiXSspXCIvKSB8fCBbXSlbMV0sXG4gICAgICAgICAgcHJpb3JpdHk6IChwYXJhbXNUZXh0Lm1hdGNoKC9wcmlvcml0eT1cIihbXlwiXSspXCIvKSB8fCBbXSlbMV0sXG4gICAgICAgICAgbG9jYXRpb246IChwYXJhbXNUZXh0Lm1hdGNoKC9sb2NhdGlvbj1cIihbXlwiXSspXCIvKSB8fCBbXSlbMV0sXG4gICAgICAgICAgbmVlZHNUcmFuc3BvcnQ6IHBhcmFtc1RleHQuaW5jbHVkZXMoJ25lZWRzVHJhbnNwb3J0PVRydWUnKSxcbiAgICAgICAgICBkZWxlZ2F0YWJsZTogcGFyYW1zVGV4dC5pbmNsdWRlcygnZGVsZWdhdGFibGU9VHJ1ZScpXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHBhcmFtcy50aXRsZSAmJiBwYXJhbXMuc3RhcnRUaW1lKSB7XG4gICAgICAgICAgLy8gVmFsaWRhdGUgYW5kIHBhcnNlIGRhdGVzXG4gICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGFyc2VEYXRlKHBhcmFtcy5zdGFydFRpbWUpO1xuICAgICAgICAgIGNvbnN0IGVuZFRpbWUgPSBwYXJhbXMuZW5kVGltZSA/IHBhcnNlRGF0ZShwYXJhbXMuZW5kVGltZSkgOiBcbiAgICAgICAgICAgIG5ldyBEYXRlKHN0YXJ0VGltZS5nZXRUaW1lKCkgKyA2MCAqIDYwICogMTAwMCk7XG5cbiAgICAgICAgICBjb25zdCBzdG9yYWdlID0gU3RvcmFnZVNlcnZpY2UuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICBjb25zdCBleGlzdGluZ0V2ZW50cyA9IHN0b3JhZ2UuZ2V0VGltZUJsb2NrcygpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEhhbmRsZSB0cmFuc3BvcnRhdGlvbiBpZiBuZWVkZWRcbiAgICAgICAgICBpZiAocGFyYW1zLm5lZWRzVHJhbnNwb3J0ICYmIHBhcmFtcy5sb2NhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgdGF4aVNlcnZpY2UgPSBUYXhpU2VydmljZS5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgY29uc3QgZXN0aW1hdGUgPSBhd2FpdCB0YXhpU2VydmljZS5lc3RpbWF0ZVRyaXAoJ2N1cnJlbnRfbG9jYXRpb24nLCBwYXJhbXMubG9jYXRpb24pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZXN0aW1hdGUuYXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGJ1ZmZlciB0aW1lIGZvciB0cmFuc3BvcnRhdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IHBpY2t1cFRpbWUgPSBuZXcgRGF0ZShzdGFydFRpbWUuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgICAgICBwaWNrdXBUaW1lLnNldE1pbnV0ZXMocGlja3VwVGltZS5nZXRNaW51dGVzKCkgLSBlc3RpbWF0ZS5kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBwYXltZW50IGZpcnN0IC0gdGhpcyBhY3R1YWxseSBzZW5kcyBFVEhcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUHJvY2Vzc2luZyB0YXhpIHBheW1lbnQuLi4nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXltZW50RGV0YWlscyA9IGF3YWl0IHRheGlTZXJ2aWNlLmdldFBheW1lbnREZXRhaWxzKCdjdXJyZW50X2xvY2F0aW9uJywgcGFyYW1zLmxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoIXBheW1lbnREZXRhaWxzLnR4SGFzaCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcHJvY2VzcyBwYXltZW50Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BheW1lbnQgcHJvY2Vzc2VkOicsIHBheW1lbnREZXRhaWxzKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBXYWl0IGZvciBjb25maXJtYXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBpc0NvbmZpcm1lZCA9IGF3YWl0IHRheGlTZXJ2aWNlLnZlcmlmeVBheW1lbnQocGF5bWVudERldGFpbHMudHhIYXNoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXltZW50U3RhdHVzID0gaXNDb25maXJtZWQgPyAnQ29uZmlybWVkJyA6ICdGYWlsZWQnO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICghaXNDb25maXJtZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGF5bWVudCBmYWlsZWQgdG8gY29uZmlybScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVkdWxlZEV2ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgX2lkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxuICAgICAgICAgICAgICAgICAgdGl0bGU6IHBhcmFtcy50aXRsZSxcbiAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogcGlja3VwVGltZS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgZW5kVGltZTogZW5kVGltZS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IHBhcmFtcy5wcmlvcml0eSB8fCBcImltcG9ydGFudFwiLFxuICAgICAgICAgICAgICAgICAgbG9jYXRpb246IHBhcmFtcy5sb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydERldGFpbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgcGlja3VwVGltZTogcGlja3VwVGltZS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICBwYXltZW50SGFzaDogcGF5bWVudERldGFpbHMudHhIYXNoLFxuICAgICAgICAgICAgICAgICAgICBwYXltZW50U3RhdHVzXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgZGVsZWdhdGFibGU6IHBhcmFtcy5kZWxlZ2F0YWJsZSB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIHN0YXR1czogJ3NjaGVkdWxlZCcsXG4gICAgICAgICAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgbWVzc2FnZUNvbnRlbnQgPSBg8J+ThSBFdmVudCBTY2hlZHVsZWQ6ICR7cGFyYW1zLnRpdGxlfVxu4o+wIFRpbWU6ICR7c3RhcnRUaW1lLnRvTG9jYWxlU3RyaW5nKCl9IC0gJHtlbmRUaW1lLnRvTG9jYWxlU3RyaW5nKCl9XG7wn5ONIExvY2F0aW9uOiAke3BhcmFtcy5sb2NhdGlvbn1cbvCfmpUgVHJhbnNwb3J0OiBUYXhpIGJvb2tlZCBmb3IgJHtwaWNrdXBUaW1lLnRvTG9jYWxlVGltZVN0cmluZygpfVxu8J+SsCBQYXltZW50OiAke3BheW1lbnRTdGF0dXN9XG7wn5KzIFRyYW5zYWN0aW9uOiAke3BheW1lbnREZXRhaWxzLnR4SGFzaH1gO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgZmluYWxFdmVudCA9IGhhbmRsZVNjaGVkdWxlQ29uZmxpY3Qoc2NoZWR1bGVkRXZlbnQsIGV4aXN0aW5nRXZlbnRzKTtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLmFkZFRpbWVCbG9jayhmaW5hbEV2ZW50KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdjYWxlbmRhclVwZGF0ZScsIHtcbiAgICAgICAgICAgICAgICAgIGRldGFpbDogZmluYWxFdmVudFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcHJvY2VzcyB0YXhpIHBheW1lbnQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VDb250ZW50ID0gYOKdjCBGYWlsZWQgdG8gc2NoZWR1bGUgZXZlbnQ6ICR7ZXJyb3IubWVzc2FnZX1gO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBtZXNzYWdlIHRvIGNoYXQgaGlzdG9yeVxuICAgICAgc2V0TWVzc2FnZXMocHJldiA9PiBbLi4ucHJldiwge1xuICAgICAgICBjb250ZW50OiBtZXNzYWdlQ29udGVudCxcbiAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9XSk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gc2VuZE1lc3NhZ2U6JywgZXJyb3IpO1xuICAgICAgc2V0TWVzc2FnZXMocHJldiA9PiBbLi4ucHJldiwge1xuICAgICAgICBjb250ZW50OiBgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgICByb2xlOiAnc3lzdGVtJyxcbiAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH1dKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlcyxcbiAgICBzZXRNZXNzYWdlcyxcbiAgICBpc0xvYWRpbmcsXG4gICAgc2VuZE1lc3NhZ2VcbiAgfTtcbn0gIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiaW5pdGlhbGl6ZUFnZW50IiwiU3RvcmFnZVNlcnZpY2UiLCJUYXhpU2VydmljZSIsInVzZUNoYXRib3QiLCJtZXNzYWdlcyIsInNldE1lc3NhZ2VzIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwic2F2ZWRNZXNzYWdlcyIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJKU09OIiwicGFyc2UiLCJzZXRJdGVtIiwic3RyaW5naWZ5IiwiaGFuZGxlU2NoZWR1bGVDb25mbGljdCIsIm5ld0V2ZW50IiwiZXhpc3RpbmdFdmVudHMiLCJjb25zb2xlIiwibG9nIiwidGl0bGUiLCJzdGFydCIsInN0YXJ0VGltZSIsInByaW9yaXR5IiwicHJpb3JpdHlPcmRlciIsImNvbmZsaWN0cyIsImZpbHRlciIsImV2ZW50IiwibmV3U3RhcnQiLCJEYXRlIiwibmV3RW5kIiwiZW5kVGltZSIsImV2ZW50U3RhcnQiLCJldmVudEVuZCIsImhhc0NvbmZsaWN0IiwiZXhpc3RpbmdFdmVudCIsImV4aXN0aW5nUHJpb3JpdHkiLCJuZXdQcmlvcml0eSIsImxlbmd0aCIsIm5ld1ByaW9yaXR5U2NvcmUiLCJoaWdoZXN0Q29uZmxpY3RTY29yZSIsIk1hdGgiLCJtYXgiLCJtYXAiLCJlIiwibmV3RXZlbnRTY29yZSIsIndpbGxSZXNjaGVkdWxlQ29uZmxpY3RzIiwic3RvcmFnZSIsImdldEluc3RhbmNlIiwiZm9yRWFjaCIsImNvbmZsaWN0IiwiZHVyYXRpb24iLCJnZXRUaW1lIiwibmV3U3RhcnRUaW1lIiwibmV3RW5kVGltZSIsInVwZGF0ZWRFdmVudCIsInRvSVNPU3RyaW5nIiwiZnJvbSIsInRvIiwidXBkYXRlVGltZUJsb2NrIiwibGFzdENvbmZsaWN0Iiwic29ydCIsImEiLCJiIiwicmVzY2hlZHVsZWRFdmVudCIsInBhcnNlVGltZVN0cmluZyIsInRpbWVTdHIiLCJkYXRlIiwiaXNOYU4iLCJ0b2RheSIsInRpbWVSZWdleCIsIm1hdGNoIiwiXyIsImhvdXJzIiwibWludXRlcyIsIm1lcmlkaWVtIiwiaG91ciIsInBhcnNlSW50IiwidG9VcHBlckNhc2UiLCJzZXRIb3VycyIsIkVycm9yIiwicGFyc2VEYXRlIiwiZGF0ZVN0ciIsImVycm9yIiwic2VuZE1lc3NhZ2UiLCJjb250ZW50IiwiYWdlbnQiLCJwcm9tcHQiLCJmdW5jdGlvbkhhbmRsZXJzIiwiZm9ybWF0dGVkUHJvbXB0IiwiZm9ybWF0TWVzc2FnZXMiLCJpbnB1dCIsInJlc3BvbnNlIiwiaW52b2tlIiwibWVzc2FnZUNvbnRlbnQiLCJjb2RlQmxvY2tNYXRjaCIsInBhcmFtc1RleHQiLCJwYXJhbXMiLCJsb2NhdGlvbiIsIm5lZWRzVHJhbnNwb3J0IiwiaW5jbHVkZXMiLCJkZWxlZ2F0YWJsZSIsImdldFRpbWVCbG9ja3MiLCJ0YXhpU2VydmljZSIsImVzdGltYXRlIiwiZXN0aW1hdGVUcmlwIiwiYXZhaWxhYmxlIiwicGlja3VwVGltZSIsInNldE1pbnV0ZXMiLCJnZXRNaW51dGVzIiwicGF5bWVudERldGFpbHMiLCJnZXRQYXltZW50RGV0YWlscyIsInR4SGFzaCIsImlzQ29uZmlybWVkIiwidmVyaWZ5UGF5bWVudCIsInBheW1lbnRTdGF0dXMiLCJzY2hlZHVsZWRFdmVudCIsIl9pZCIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJ0cmFuc3BvcnREZXRhaWxzIiwicGF5bWVudEhhc2giLCJzdGF0dXMiLCJjcmVhdGVkX2F0IiwidXBkYXRlZF9hdCIsInRvTG9jYWxlU3RyaW5nIiwidG9Mb2NhbGVUaW1lU3RyaW5nIiwiZmluYWxFdmVudCIsImFkZFRpbWVCbG9jayIsIkN1c3RvbUV2ZW50IiwiZGV0YWlsIiwid2luZG93IiwiZGlzcGF0Y2hFdmVudCIsIm1lc3NhZ2UiLCJwcmV2Iiwicm9sZSIsInRpbWVzdGFtcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useChatbot.ts\n"));

/***/ })

});